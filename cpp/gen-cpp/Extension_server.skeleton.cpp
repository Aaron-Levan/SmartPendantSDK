// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Extension.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::yaskawa::ext::api;

class ExtensionHandler : virtual public ExtensionIf {
 public:
  ExtensionHandler() {
    // Your initialization goes here
  }

  /**
   * Version of API the service implements.
   * Smart Pendant | API version
   * 2.0           | 2.0.4
   * 2.1           | 2.1.0
   */
  void apiVersion(Version& _return) {
    // Your implementation goes here
    printf("apiVersion\n");
  }

  /**
   * Register extension with Smart Pendant API service.
   * Extension must exist in the extension database (i.e. through installation)
   * 
   * @param canonicalName
   * @param launchKey
   * @param version
   * @param vendor
   * @param supportedLanguages
   */
  ExtensionID registerExtension(const std::string& canonicalName, const std::string& launchKey, const Version& version, const std::string& vendor, const std::set<std::string> & supportedLanguages) {
    // Your implementation goes here
    printf("registerExtension\n");
  }

  void unregisterExtension(const ExtensionID id) {
    // Your implementation goes here
    printf("unregisterExtension\n");
  }

  /**
   * Indicate liveliness
   * API service will automatically unregister extensions that are unresponsive for some period.
   * If extension is not regularly calling events(), call ping() to indicate the extension is operational.
   * 
   * @param id
   */
  void ping(const ExtensionID id) {
    // Your implementation goes here
    printf("ping\n");
  }

  /**
   * Obtain ID handle for Robot Conroller API
   * 
   * @param id
   */
  ControllerID controller(const ExtensionID id) {
    // Your implementation goes here
    printf("controller\n");
  }

  /**
   * Obtain ID handle for Pendant UI API
   * 
   * @param id
   */
  PendantID pendant(const ExtensionID id) {
    // Your implementation goes here
    printf("pendant\n");
  }

  /**
   * Log message to standard pendant logging facility
   * Visible to end-users upon plain-text log file export.
   * Note that Debug level logging is ignored unless in Developer access level.
   * 
   * @param id
   * @param level
   * @param message
   */
  void log(const ExtensionID id, const LoggingLevel::type level, const std::string& message) {
    // Your implementation goes here
    printf("log\n");
  }

  /**
   * Subscribe to receive log message events via events()
   * 
   * @param id
   */
  void subscribeLoggingEvents(const ExtensionID id) {
    // Your implementation goes here
    printf("subscribeLoggingEvents\n");
  }

  void unsubscribeLoggingEvents(const ExtensionID id) {
    // Your implementation goes here
    printf("unsubscribeLoggingEvents\n");
  }

  /**
   * Obtain list of logging events that have occured since last call
   * NB: For development troubleshooting only, logging events
   * only available when development access enabled
   * 
   * @param id
   */
  void logEvents(std::vector<LoggingEvent> & _return, const ExtensionID id) {
    // Your implementation goes here
    printf("logEvents\n");
  }

  void publicKey(std::string& _return, const ExtensionID id) {
    // Your implementation goes here
    printf("publicKey\n");
  }

  void oneTimeAuthToken(std::string& _return, const ExtensionID id, const std::string& oneTimeSalt, const std::string& publicKey) {
    // Your implementation goes here
    printf("oneTimeAuthToken\n");
  }

  void installPackage(std::vector<std::string> & _return, const ExtensionID id, const std::string& authToken, const std::string& packageData, const std::string& overridePasscodeEnc) {
    // Your implementation goes here
    printf("installPackage\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::std::shared_ptr<ExtensionHandler> handler(new ExtensionHandler());
  ::std::shared_ptr<TProcessor> processor(new ExtensionProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

