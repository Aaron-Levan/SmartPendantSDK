/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef extension_TYPES_H
#define extension_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace yaskawa { namespace ext { namespace api {

/**
 * Orientations in 3D can be represented either as:
 * * A 4-element unit-length Quaternion (x,y,z,w)
 * * A 3x3 transformation matrix
 * * A 3-vector of Euler angles
 *     (Tait/Cardan-Bryant) Roll, Pitch, Yaw angles (alpha,beta,gamma).
 *     This is equivelent to EulerXYZ and assumes that the
 *      x-axis points forward, y-axis points right and the z-axis up.
 *      (Aeronautical convention)
 */
struct OrientationRepresentation {
  enum type {
    Quaternion = 0,
    Matrix = 1,
    EulerRPY = 2
  };
};

extern const std::map<int, const char*> _OrientationRepresentation_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const OrientationRepresentation::type& val);

std::string to_string(const OrientationRepresentation::type& val);

struct LoggingLevel {
  enum type {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Critical = 3
  };
};

extern const std::map<int, const char*> _LoggingLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const LoggingLevel::type& val);

std::string to_string(const LoggingLevel::type& val);

/**
 * A Coordinate Frame is a reference frame in space
 * against which concrete coordinates are relative.
 * 
 * In 3D space a frame can be represented by an origin
 * and the direction of the x,y & z axes - explicitly or
 * otherwise.
 * 
 * * Implicit - the coordinate frame is implicit in its type (e.g. predefined)
 *            (e.g. the base frame is relative to the fixed mount of the robot)
 * * Transform - the frame is represented by a standard 4x4 transformation matrix
 * * OffsetOrient - the frame is represented by an origin and orientation in 3D
 * * OriginPlane - the frame is defined by an origin and two additional points making up a plane
 */
struct CoordFrameRepresentation {
  enum type {
    Implicit = 0,
    Transform = 1,
    OffsetOrient = 2,
    OriginPlane = 3
  };
};

extern const std::map<int, const char*> _CoordFrameRepresentation_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CoordFrameRepresentation::type& val);

std::string to_string(const CoordFrameRepresentation::type& val);

/**
 * Type of predefined coordinate frames (representaton is implicit)
 * * Joint - the joint space of the robot (dimension equals the number of axes / dof)
 * * World - Cartesian frame of environment (typically coincident with the robot base)
 * * Base  - Cartesian frame of the base mount of the robot
 *           (for robots not mounted on a moveable base, fixed relative to the robot frame)
 * * Robot - Cartesian frame of the robot (e.g. from first axis)
 * * ToolPlate - Cartesian frame of the tool mounting plate
 * * ToolTip - Cartesian frame of the tip of the tool (i.e. End-Effector)
 *             (this depends on the specific tool)
 * * User - Cartesian frame configured by user stored in the controller
 *          (multiple user frames can be defined and referenced by index)
 */
struct PredefinedCoordFrameType {
  enum type {
    Joint = 1,
    World = 2,
    Base = 7,
    Robot = 3,
    ToolPlate = 4,
    ToolTip = 5,
    User = 6,
    None = 0
  };
};

extern const std::map<int, const char*> _PredefinedCoordFrameType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PredefinedCoordFrameType::type& val);

std::string to_string(const PredefinedCoordFrameType::type& val);

struct DistanceUnit {
  enum type {
    None = 0,
    Millimeter = 1,
    Inch = 2,
    Meter = 3
  };
};

extern const std::map<int, const char*> _DistanceUnit_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const DistanceUnit::type& val);

std::string to_string(const DistanceUnit::type& val);

struct OrientationUnit {
  enum type {
    None = 0,
    Pulse = 1,
    Radian = 2,
    Degree = 3
  };
};

extern const std::map<int, const char*> _OrientationUnit_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const OrientationUnit::type& val);

std::string to_string(const OrientationUnit::type& val);

struct PendantEventType {
  enum type {
    Startup = 0,
    Shutdown = 1,
    SwitchedScreen = 2,
    PopupOpened = 3,
    PopupClosed = 4,
    UtilityOpened = 5,
    UtilityClosed = 6,
    UtilityMoved = 7,
    Clicked = 8,
    Pressed = 9,
    Released = 10,
    TextEdited = 11,
    Accepted = 12,
    EditingFinished = 13,
    CheckedChanged = 14,
    Activated = 15,
    PanelOpened = 16,
    PanelClosed = 17,
    Canceled = 18,
    Other = 16384
  };
};

extern const std::map<int, const char*> _PendantEventType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PendantEventType::type& val);

std::string to_string(const PendantEventType::type& val);

struct IntegrationPoint {
  enum type {
    UtilityWindow = 0,
    NavigationPanel = 10,
    ProgrammingCommandBar = 20,
    ProgrammingHeaderBar = 30,
    SmartFrameJogPanelTopLeft = 40,
    SmartFrameJogPanelTopRight = 41,
    SmartFrameJogPanelTopAny = 44,
    SmartFrameJogPanelBottomLeft = 45,
    SmartFrameJogPanelBottomCenter = 46,
    SmartFrameJogPanelBottomRight = 47,
    SmartFrameJogPanelBottomAny = 49,
    JogPanelTopCenter = 50
  };
};

extern const std::map<int, const char*> _IntegrationPoint_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const IntegrationPoint::type& val);

std::string to_string(const IntegrationPoint::type& val);

struct Disposition {
  enum type {
    Negative = 1,
    Neutral = 0,
    Positive = 2
  };
};

extern const std::map<int, const char*> _Disposition_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Disposition::type& val);

std::string to_string(const Disposition::type& val);

struct ControllerEventType {
  enum type {
    Connected = 0,
    RobotModel = 1,
    ExclusiveControl = 2,
    CycleTime = 3,
    PowerOnTime = 4,
    ServoOnTime = 5,
    EnabledOptionsChanged = 6,
    OperationMode = 7,
    ServoState = 8,
    PlaybackState = 9,
    SpeedOverride = 10,
    ActiveTool = 11,
    AlarmActive = 12,
    ActiveAlarmsChanged = 13,
    RestartRequired = 14,
    EStopEngaged = 15,
    EnableSwitchActive = 16,
    RemoteMode = 17,
    JoggingActive = 18,
    JoggingSpeedChanged = 19,
    JoggingModeChanged = 20,
    RobotTCPPosition = 21,
    BrakeRelease = 22,
    SoftLimitRelease = 23,
    SelfInterferenceRelease = 24,
    AllLimitsRelease = 25,
    ParametersChanged = 26,
    PredefinedPositionsChanged = 27,
    FeatureAvailabilityChanged = 28,
    JointLimitsChanged = 29,
    JointMotorPulseDegreeRatioChanged = 30,
    FunctionalSafetyHardwareAvailable = 31,
    NetworkInterfacesChanged = 32,
    CurrentRobot = 33,
    JobTagsChanged = 34,
    JobListChanged = 35,
    JobStackChanged = 36,
    CurrentJob = 37,
    DefaultJob = 38,
    ToolsChanged = 39,
    ToolIOsChanged = 40,
    UserFramesChanged = 41,
    ZonesChanged = 42,
    SafetyRobotRangeLimitDataChanged = 43,
    SafetyAxisSpeedMonitorDataChanged = 44,
    SafetySpeedLimitDataChanged = 45,
    SafetyExternalForceMonitorFileChanged = 46,
    SafetyIOListChanged = 47,
    VariablesChanged = 48,
    VariableNamesChanged = 49,
    IONamesChanged = 50,
    IOValueChanged = 51,
    PermissionGranted = 1000,
    PermissionRevoked = 1001
  };
};

extern const std::map<int, const char*> _ControllerEventType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ControllerEventType::type& val);

std::string to_string(const ControllerEventType::type& val);

struct OperationMode {
  enum type {
    Automatic = 0,
    Manual = 1
  };
};

extern const std::map<int, const char*> _OperationMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const OperationMode::type& val);

std::string to_string(const OperationMode::type& val);

struct ServoState {
  enum type {
    Off = 0,
    Ready = 1,
    On = 2
  };
};

extern const std::map<int, const char*> _ServoState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ServoState::type& val);

std::string to_string(const ServoState::type& val);

struct PlaybackState {
  enum type {
    Run = 0,
    Hold = 1,
    Idle = 2
  };
};

extern const std::map<int, const char*> _PlaybackState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PlaybackState::type& val);

std::string to_string(const PlaybackState::type& val);

struct ControlGroupType {
  enum type {
    Robot = 0,
    Base = 1,
    Station = 2,
    Combined = 254,
    None = 255
  };
};

extern const std::map<int, const char*> _ControlGroupType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ControlGroupType::type& val);

std::string to_string(const ControlGroupType::type& val);

struct Scope {
  enum type {
    Local = 0,
    Global = 1
  };
};

extern const std::map<int, const char*> _Scope_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Scope::type& val);

std::string to_string(const Scope::type& val);

/**
 * Variable address space
 */
struct AddressSpace {
  enum type {
    Unified = 0,
    Byte = 1,
    Int = 2,
    DoubleInt = 3,
    Real = 4,
    String = 5,
    Position = 6
  };
};

extern const std::map<int, const char*> _AddressSpace_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const AddressSpace::type& val);

std::string to_string(const AddressSpace::type& val);

struct ZoneAction {
  enum type {
    Status = 0,
    Alarm = 1
  };
};

extern const std::map<int, const char*> _ZoneAction_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ZoneAction::type& val);

std::string to_string(const ZoneAction::type& val);

typedef int64_t ExtensionID;

typedef int64_t ControllerID;

typedef int64_t PendantID;

typedef std::vector<double>  Vector;

typedef std::vector<int64_t>  IVector;

typedef Vector Point;

typedef std::map<std::string, class Data>  DataSet;

typedef int32_t RobotIndex;

typedef int32_t ToolIndex;

typedef int32_t UserFrameIndex;

typedef int32_t ZoneIndex;

class InvalidID;

class IllegalArgument;

class Matrix;

class Orient;

class VectorOrient;

class PointPlane;

class Version;

class CoordinateFrame;

class Position;

class Any;

class LoggingEvent;

class Series;

class Category;

class DataPoint;

class Data;

class PendantEvent;

class PropValues;

class ControllerEvent;

class SimpleControlGroup;

class CombinedControlGroup;

class ControlGroup;

class RobotJobInfo;

class Tool;

class VariableAddress;

class Zone;


class InvalidID : public ::apache::thrift::TException {
 public:

  InvalidID(const InvalidID&) noexcept;
  InvalidID& operator=(const InvalidID&) noexcept;
  InvalidID() noexcept {
  }

  virtual ~InvalidID() noexcept;

  bool operator == (const InvalidID & /* rhs */) const
  {
    return true;
  }
  bool operator != (const InvalidID &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidID & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(InvalidID &a, InvalidID &b);

std::ostream& operator<<(std::ostream& out, const InvalidID& obj);


class IllegalArgument : public ::apache::thrift::TException {
 public:

  IllegalArgument(const IllegalArgument&);
  IllegalArgument& operator=(const IllegalArgument&);
  IllegalArgument() noexcept
                  : msg() {
  }

  virtual ~IllegalArgument() noexcept;
  std::string msg;

  void __set_msg(const std::string& val);

  bool operator == (const IllegalArgument & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const IllegalArgument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IllegalArgument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(IllegalArgument &a, IllegalArgument &b);

std::ostream& operator<<(std::ostream& out, const IllegalArgument& obj);

typedef struct _Matrix__isset {
  _Matrix__isset() : rows(false), cols(false), m(false) {}
  bool rows :1;
  bool cols :1;
  bool m :1;
} _Matrix__isset;

class Matrix : public virtual ::apache::thrift::TBase {
 public:

  Matrix(const Matrix&);
  Matrix& operator=(const Matrix&);
  Matrix() noexcept
         : rows(0),
           cols(0) {
  }

  virtual ~Matrix() noexcept;
  int64_t rows;
  int64_t cols;
  std::vector<Vector>  m;

  _Matrix__isset __isset;

  void __set_rows(const int64_t val);

  void __set_cols(const int64_t val);

  void __set_m(const std::vector<Vector> & val);

  bool operator == (const Matrix & rhs) const
  {
    if (!(rows == rhs.rows))
      return false;
    if (!(cols == rhs.cols))
      return false;
    if (!(m == rhs.m))
      return false;
    return true;
  }
  bool operator != (const Matrix &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Matrix & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Matrix &a, Matrix &b);

std::ostream& operator<<(std::ostream& out, const Matrix& obj);

typedef struct _Orient__isset {
  _Orient__isset() : rep(true), v(false), m(false) {}
  bool rep :1;
  bool v :1;
  bool m :1;
} _Orient__isset;

/**
 * If rep is Quaternion or EulerRPY then v contains the elements,
 * otherwise if rep is Matrix m contains the 3x3 transform
 */
class Orient : public virtual ::apache::thrift::TBase {
 public:

  Orient(const Orient&);
  Orient& operator=(const Orient&);
  Orient() noexcept
         : rep(static_cast<OrientationRepresentation::type>(2)) {
  }

  virtual ~Orient() noexcept;
  /**
   * 
   * @see OrientationRepresentation
   */
  OrientationRepresentation::type rep;
  Vector v;
  Matrix m;

  _Orient__isset __isset;

  void __set_rep(const OrientationRepresentation::type val);

  void __set_v(const Vector& val);

  void __set_m(const Matrix& val);

  bool operator == (const Orient & rhs) const
  {
    if (!(rep == rhs.rep))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    if (__isset.m != rhs.__isset.m)
      return false;
    else if (__isset.m && !(m == rhs.m))
      return false;
    return true;
  }
  bool operator != (const Orient &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Orient & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Orient &a, Orient &b);

std::ostream& operator<<(std::ostream& out, const Orient& obj);

typedef struct _VectorOrient__isset {
  _VectorOrient__isset() : v(false), o(false) {}
  bool v :1;
  bool o :1;
} _VectorOrient__isset;

class VectorOrient : public virtual ::apache::thrift::TBase {
 public:

  VectorOrient(const VectorOrient&);
  VectorOrient& operator=(const VectorOrient&);
  VectorOrient() noexcept {
  }

  virtual ~VectorOrient() noexcept;
  Vector v;
  Orient o;

  _VectorOrient__isset __isset;

  void __set_v(const Vector& val);

  void __set_o(const Orient& val);

  bool operator == (const VectorOrient & rhs) const
  {
    if (!(v == rhs.v))
      return false;
    if (!(o == rhs.o))
      return false;
    return true;
  }
  bool operator != (const VectorOrient &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VectorOrient & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(VectorOrient &a, VectorOrient &b);

std::ostream& operator<<(std::ostream& out, const VectorOrient& obj);

typedef struct _PointPlane__isset {
  _PointPlane__isset() : origin(false), xx(false), xy(false) {}
  bool origin :1;
  bool xx :1;
  bool xy :1;
} _PointPlane__isset;

/**
 * Position and Orientaiton in 3D defined by
 * an origin point and two points that define a plane
 */
class PointPlane : public virtual ::apache::thrift::TBase {
 public:

  PointPlane(const PointPlane&);
  PointPlane& operator=(const PointPlane&);
  PointPlane() noexcept {
  }

  virtual ~PointPlane() noexcept;
  Point origin;
  Point xx;
  Point xy;

  _PointPlane__isset __isset;

  void __set_origin(const Point& val);

  void __set_xx(const Point& val);

  void __set_xy(const Point& val);

  bool operator == (const PointPlane & rhs) const
  {
    if (!(origin == rhs.origin))
      return false;
    if (!(xx == rhs.xx))
      return false;
    if (!(xy == rhs.xy))
      return false;
    return true;
  }
  bool operator != (const PointPlane &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PointPlane & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PointPlane &a, PointPlane &b);

std::ostream& operator<<(std::ostream& out, const PointPlane& obj);

typedef struct _Version__isset {
  _Version__isset() : nmajor(false), nminor(false), npatch(false), release(false), build(false) {}
  bool nmajor :1;
  bool nminor :1;
  bool npatch :1;
  bool release :1;
  bool build :1;
} _Version__isset;

class Version : public virtual ::apache::thrift::TBase {
 public:

  Version(const Version&);
  Version& operator=(const Version&);
  Version() noexcept
          : nmajor(0),
            nminor(0),
            npatch(0),
            release(),
            build() {
  }

  virtual ~Version() noexcept;
  int16_t nmajor;
  int16_t nminor;
  int16_t npatch;
  std::string release;
  std::string build;

  _Version__isset __isset;

  void __set_nmajor(const int16_t val);

  void __set_nminor(const int16_t val);

  void __set_npatch(const int16_t val);

  void __set_release(const std::string& val);

  void __set_build(const std::string& val);

  bool operator == (const Version & rhs) const
  {
    if (!(nmajor == rhs.nmajor))
      return false;
    if (!(nminor == rhs.nminor))
      return false;
    if (!(npatch == rhs.npatch))
      return false;
    if (__isset.release != rhs.__isset.release)
      return false;
    else if (__isset.release && !(release == rhs.release))
      return false;
    if (__isset.build != rhs.__isset.build)
      return false;
    else if (__isset.build && !(build == rhs.build))
      return false;
    return true;
  }
  bool operator != (const Version &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Version & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Version &a, Version &b);

std::ostream& operator<<(std::ostream& out, const Version& obj);

typedef struct _CoordinateFrame__isset {
  _CoordinateFrame__isset() : rep(true), predefined(false), name(false), robot(false), tool(false), transform(false), vecorient(false), userFrame(false), pointplane(false) {}
  bool rep :1;
  bool predefined :1;
  bool name :1;
  bool robot :1;
  bool tool :1;
  bool transform :1;
  bool vecorient :1;
  bool userFrame :1;
  bool pointplane :1;
} _CoordinateFrame__isset;

/**
 * Represents a coordinate frame
 * Used as a reference frame for position coordinates
 * 
 * If rep is Implicit then it represents one of the predefined
 * frames defined by the physical configuration of the cell, robot and/or tool.
 * If predefined is:
 * * Joint - the frame is in the axis space of the robot joints (hence dimension is dof of the robot)
 * * World - the fixed Cartesian frame of the cell (often coincident with Base)
 * * Base - the base mount of the robot - requires robot set
 * * Robot - the robot itself (e.g. origin at first axis) - requires robot set
 *           (unless mounted on a moveable base, fixed offet, possibly 0, from base)
 * * ToolPlate - toolplate of the end-effector (as when no tool mounted)
 * * ToolTip - 'business end' of the tool.  Depends on which tool is mounted/active
 *             and requires tool be set
 * * User - User defined frames configured in the controller - requires userFrame set.
 *          User frames also have an associated tool in the YRC Controller, hence requires
 *          tool to be set.  pointplane may be set if user frame is defined
 *          via origin point and points in plane
 * 
 * If rep is Transform then transform Matrix must be valid
 * If rep is OffsetOrient, vecorient must be valid
 */
class CoordinateFrame : public virtual ::apache::thrift::TBase {
 public:

  CoordinateFrame(const CoordinateFrame&);
  CoordinateFrame& operator=(const CoordinateFrame&);
  CoordinateFrame() noexcept
                  : rep(static_cast<CoordFrameRepresentation::type>(0)),
                    predefined(static_cast<PredefinedCoordFrameType::type>(0)),
                    name(),
                    robot(0),
                    tool(0),
                    userFrame(0) {
  }

  virtual ~CoordinateFrame() noexcept;
  /**
   * 
   * @see CoordFrameRepresentation
   */
  CoordFrameRepresentation::type rep;
  /**
   * 
   * @see PredefinedCoordFrameType
   */
  PredefinedCoordFrameType::type predefined;
  std::string name;
  RobotIndex robot;
  ToolIndex tool;
  Matrix transform;
  VectorOrient vecorient;
  UserFrameIndex userFrame;
  PointPlane pointplane;

  _CoordinateFrame__isset __isset;

  void __set_rep(const CoordFrameRepresentation::type val);

  void __set_predefined(const PredefinedCoordFrameType::type val);

  void __set_name(const std::string& val);

  void __set_robot(const RobotIndex val);

  void __set_tool(const ToolIndex val);

  void __set_transform(const Matrix& val);

  void __set_vecorient(const VectorOrient& val);

  void __set_userFrame(const UserFrameIndex val);

  void __set_pointplane(const PointPlane& val);

  bool operator == (const CoordinateFrame & rhs) const
  {
    if (!(rep == rhs.rep))
      return false;
    if (!(predefined == rhs.predefined))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.robot != rhs.__isset.robot)
      return false;
    else if (__isset.robot && !(robot == rhs.robot))
      return false;
    if (__isset.tool != rhs.__isset.tool)
      return false;
    else if (__isset.tool && !(tool == rhs.tool))
      return false;
    if (__isset.transform != rhs.__isset.transform)
      return false;
    else if (__isset.transform && !(transform == rhs.transform))
      return false;
    if (__isset.vecorient != rhs.__isset.vecorient)
      return false;
    else if (__isset.vecorient && !(vecorient == rhs.vecorient))
      return false;
    if (__isset.userFrame != rhs.__isset.userFrame)
      return false;
    else if (__isset.userFrame && !(userFrame == rhs.userFrame))
      return false;
    if (__isset.pointplane != rhs.__isset.pointplane)
      return false;
    else if (__isset.pointplane && !(pointplane == rhs.pointplane))
      return false;
    return true;
  }
  bool operator != (const CoordinateFrame &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoordinateFrame & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CoordinateFrame &a, CoordinateFrame &b);

std::ostream& operator<<(std::ostream& out, const CoordinateFrame& obj);

typedef struct _Position__isset {
  _Position__isset() : frame(false), distUnit(false), orientUnit(false), pos(false), orient(false), joints(false), closure(false) {}
  bool frame :1;
  bool distUnit :1;
  bool orientUnit :1;
  bool pos :1;
  bool orient :1;
  bool joints :1;
  bool closure :1;
} _Position__isset;

class Position : public virtual ::apache::thrift::TBase {
 public:

  Position(const Position&);
  Position& operator=(const Position&);
  Position() noexcept
           : distUnit(static_cast<DistanceUnit::type>(0)),
             orientUnit(static_cast<OrientationUnit::type>(0)) {
  }

  virtual ~Position() noexcept;
  CoordinateFrame frame;
  /**
   * 
   * @see DistanceUnit
   */
  DistanceUnit::type distUnit;
  /**
   * 
   * @see OrientationUnit
   */
  OrientationUnit::type orientUnit;
  Vector pos;
  Orient orient;
  Vector joints;
  IVector closure;

  _Position__isset __isset;

  void __set_frame(const CoordinateFrame& val);

  void __set_distUnit(const DistanceUnit::type val);

  void __set_orientUnit(const OrientationUnit::type val);

  void __set_pos(const Vector& val);

  void __set_orient(const Orient& val);

  void __set_joints(const Vector& val);

  void __set_closure(const IVector& val);

  bool operator == (const Position & rhs) const
  {
    if (!(frame == rhs.frame))
      return false;
    if (__isset.distUnit != rhs.__isset.distUnit)
      return false;
    else if (__isset.distUnit && !(distUnit == rhs.distUnit))
      return false;
    if (!(orientUnit == rhs.orientUnit))
      return false;
    if (__isset.pos != rhs.__isset.pos)
      return false;
    else if (__isset.pos && !(pos == rhs.pos))
      return false;
    if (__isset.orient != rhs.__isset.orient)
      return false;
    else if (__isset.orient && !(orient == rhs.orient))
      return false;
    if (__isset.joints != rhs.__isset.joints)
      return false;
    else if (__isset.joints && !(joints == rhs.joints))
      return false;
    if (__isset.closure != rhs.__isset.closure)
      return false;
    else if (__isset.closure && !(closure == rhs.closure))
      return false;
    return true;
  }
  bool operator != (const Position &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Position & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Position &a, Position &b);

std::ostream& operator<<(std::ostream& out, const Position& obj);

typedef struct _Any__isset {
  _Any__isset() : bValue(false), iValue(false), rValue(false), sValue(false), vValue(false), pValue(false), aValue(false), mValue(false) {}
  bool bValue :1;
  bool iValue :1;
  bool rValue :1;
  bool sValue :1;
  bool vValue :1;
  bool pValue :1;
  bool aValue :1;
  bool mValue :1;
} _Any__isset;

/**
 * Useful union for holding one of several data types
 */
class Any : public virtual ::apache::thrift::TBase {
 public:

  Any(const Any&);
  Any& operator=(const Any&);
  Any() noexcept
      : bValue(0),
        iValue(0),
        rValue(0),
        sValue() {
  }

  virtual ~Any() noexcept;
  bool bValue;
  int64_t iValue;
  double rValue;
  std::string sValue;
  Vector vValue;
  Position pValue;
  std::vector<Any>  aValue;
  std::map<std::string, Any>  mValue;

  _Any__isset __isset;

  void __set_bValue(const bool val);

  void __set_iValue(const int64_t val);

  void __set_rValue(const double val);

  void __set_sValue(const std::string& val);

  void __set_vValue(const Vector& val);

  void __set_pValue(const Position& val);

  void __set_aValue(const std::vector<Any> & val);

  void __set_mValue(const std::map<std::string, Any> & val);

  bool operator == (const Any & rhs) const
  {
    if (__isset.bValue != rhs.__isset.bValue)
      return false;
    else if (__isset.bValue && !(bValue == rhs.bValue))
      return false;
    if (__isset.iValue != rhs.__isset.iValue)
      return false;
    else if (__isset.iValue && !(iValue == rhs.iValue))
      return false;
    if (__isset.rValue != rhs.__isset.rValue)
      return false;
    else if (__isset.rValue && !(rValue == rhs.rValue))
      return false;
    if (__isset.sValue != rhs.__isset.sValue)
      return false;
    else if (__isset.sValue && !(sValue == rhs.sValue))
      return false;
    if (__isset.vValue != rhs.__isset.vValue)
      return false;
    else if (__isset.vValue && !(vValue == rhs.vValue))
      return false;
    if (__isset.pValue != rhs.__isset.pValue)
      return false;
    else if (__isset.pValue && !(pValue == rhs.pValue))
      return false;
    if (__isset.aValue != rhs.__isset.aValue)
      return false;
    else if (__isset.aValue && !(aValue == rhs.aValue))
      return false;
    if (__isset.mValue != rhs.__isset.mValue)
      return false;
    else if (__isset.mValue && !(mValue == rhs.mValue))
      return false;
    return true;
  }
  bool operator != (const Any &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Any & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Any &a, Any &b);

std::ostream& operator<<(std::ostream& out, const Any& obj);

typedef struct _LoggingEvent__isset {
  _LoggingEvent__isset() : timestamp(false), datetime(false), level(false), entry(false) {}
  bool timestamp :1;
  bool datetime :1;
  bool level :1;
  bool entry :1;
} _LoggingEvent__isset;

class LoggingEvent : public virtual ::apache::thrift::TBase {
 public:

  LoggingEvent(const LoggingEvent&);
  LoggingEvent& operator=(const LoggingEvent&);
  LoggingEvent() noexcept
               : timestamp(0),
                 datetime(),
                 level(static_cast<LoggingLevel::type>(0)),
                 entry() {
  }

  virtual ~LoggingEvent() noexcept;
  int64_t timestamp;
  std::string datetime;
  /**
   * 
   * @see LoggingLevel
   */
  LoggingLevel::type level;
  std::string entry;

  _LoggingEvent__isset __isset;

  void __set_timestamp(const int64_t val);

  void __set_datetime(const std::string& val);

  void __set_level(const LoggingLevel::type val);

  void __set_entry(const std::string& val);

  bool operator == (const LoggingEvent & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(datetime == rhs.datetime))
      return false;
    if (!(level == rhs.level))
      return false;
    if (!(entry == rhs.entry))
      return false;
    return true;
  }
  bool operator != (const LoggingEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LoggingEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(LoggingEvent &a, LoggingEvent &b);

std::ostream& operator<<(std::ostream& out, const LoggingEvent& obj);

typedef struct _Series__isset {
  _Series__isset() : x(false), y(false), z(false), color(false), vertex(false), style(false), hidden(false), maxPts(false) {}
  bool x :1;
  bool y :1;
  bool z :1;
  bool color :1;
  bool vertex :1;
  bool style :1;
  bool hidden :1;
  bool maxPts :1;
} _Series__isset;

/**
 * Data structures for passing values to charts for plotting
 * 
 * Series data is used for line and scatter charts, while
 * category data is used for pie and bar charts
 */
class Series : public virtual ::apache::thrift::TBase {
 public:

  Series(const Series&);
  Series& operator=(const Series&);
  Series() noexcept
         : color(),
           vertex(),
           style(),
           hidden(0),
           maxPts(0) {
  }

  virtual ~Series() noexcept;
  Vector x;
  Vector y;
  Vector z;
  std::string color;
  std::string vertex;
  std::string style;
  bool hidden;
  int32_t maxPts;

  _Series__isset __isset;

  void __set_x(const Vector& val);

  void __set_y(const Vector& val);

  void __set_z(const Vector& val);

  void __set_color(const std::string& val);

  void __set_vertex(const std::string& val);

  void __set_style(const std::string& val);

  void __set_hidden(const bool val);

  void __set_maxPts(const int32_t val);

  bool operator == (const Series & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (__isset.z != rhs.__isset.z)
      return false;
    else if (__isset.z && !(z == rhs.z))
      return false;
    if (__isset.color != rhs.__isset.color)
      return false;
    else if (__isset.color && !(color == rhs.color))
      return false;
    if (__isset.vertex != rhs.__isset.vertex)
      return false;
    else if (__isset.vertex && !(vertex == rhs.vertex))
      return false;
    if (__isset.style != rhs.__isset.style)
      return false;
    else if (__isset.style && !(style == rhs.style))
      return false;
    if (__isset.hidden != rhs.__isset.hidden)
      return false;
    else if (__isset.hidden && !(hidden == rhs.hidden))
      return false;
    if (__isset.maxPts != rhs.__isset.maxPts)
      return false;
    else if (__isset.maxPts && !(maxPts == rhs.maxPts))
      return false;
    return true;
  }
  bool operator != (const Series &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Series & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Series &a, Series &b);

std::ostream& operator<<(std::ostream& out, const Series& obj);

typedef struct _Category__isset {
  _Category__isset() : v(false), color(false), hidden(false) {}
  bool v :1;
  bool color :1;
  bool hidden :1;
} _Category__isset;

class Category : public virtual ::apache::thrift::TBase {
 public:

  Category(const Category&);
  Category& operator=(const Category&);
  Category() noexcept
           : v(0),
             color(),
             hidden(0) {
  }

  virtual ~Category() noexcept;
  double v;
  std::string color;
  bool hidden;

  _Category__isset __isset;

  void __set_v(const double val);

  void __set_color(const std::string& val);

  void __set_hidden(const bool val);

  bool operator == (const Category & rhs) const
  {
    if (!(v == rhs.v))
      return false;
    if (__isset.color != rhs.__isset.color)
      return false;
    else if (__isset.color && !(color == rhs.color))
      return false;
    if (__isset.hidden != rhs.__isset.hidden)
      return false;
    else if (__isset.hidden && !(hidden == rhs.hidden))
      return false;
    return true;
  }
  bool operator != (const Category &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Category & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Category &a, Category &b);

std::ostream& operator<<(std::ostream& out, const Category& obj);

typedef struct _DataPoint__isset {
  _DataPoint__isset() : x(false), y(false), z(false) {}
  bool x :1;
  bool y :1;
  bool z :1;
} _DataPoint__isset;

class DataPoint : public virtual ::apache::thrift::TBase {
 public:

  DataPoint(const DataPoint&) noexcept;
  DataPoint& operator=(const DataPoint&) noexcept;
  DataPoint() noexcept
            : x(0),
              y(0),
              z(0) {
  }

  virtual ~DataPoint() noexcept;
  double x;
  double y;
  double z;

  _DataPoint__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_z(const double val);

  bool operator == (const DataPoint & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (__isset.z != rhs.__isset.z)
      return false;
    else if (__isset.z && !(z == rhs.z))
      return false;
    return true;
  }
  bool operator != (const DataPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataPoint &a, DataPoint &b);

std::ostream& operator<<(std::ostream& out, const DataPoint& obj);

typedef struct _Data__isset {
  _Data__isset() : sData(false), cData(false) {}
  bool sData :1;
  bool cData :1;
} _Data__isset;

class Data : public virtual ::apache::thrift::TBase {
 public:

  Data(const Data&);
  Data& operator=(const Data&);
  Data() noexcept {
  }

  virtual ~Data() noexcept;
  Series sData;
  Category cData;

  _Data__isset __isset;

  void __set_sData(const Series& val);

  void __set_cData(const Category& val);

  bool operator == (const Data & rhs) const
  {
    if (__isset.sData != rhs.__isset.sData)
      return false;
    else if (__isset.sData && !(sData == rhs.sData))
      return false;
    if (__isset.cData != rhs.__isset.cData)
      return false;
    else if (__isset.cData && !(cData == rhs.cData))
      return false;
    return true;
  }
  bool operator != (const Data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Data &a, Data &b);

std::ostream& operator<<(std::ostream& out, const Data& obj);

typedef struct _PendantEvent__isset {
  _PendantEvent__isset() : props(false) {}
  bool props :1;
} _PendantEvent__isset;

class PendantEvent : public virtual ::apache::thrift::TBase {
 public:

  PendantEvent(const PendantEvent&);
  PendantEvent& operator=(const PendantEvent&);
  PendantEvent() noexcept
               : eventType(static_cast<PendantEventType::type>(0)) {
  }

  virtual ~PendantEvent() noexcept;
  /**
   * 
   * @see PendantEventType
   */
  PendantEventType::type eventType;
  std::map<std::string, Any>  props;

  _PendantEvent__isset __isset;

  void __set_eventType(const PendantEventType::type val);

  void __set_props(const std::map<std::string, Any> & val);

  bool operator == (const PendantEvent & rhs) const
  {
    if (!(eventType == rhs.eventType))
      return false;
    if (__isset.props != rhs.__isset.props)
      return false;
    else if (__isset.props && !(props == rhs.props))
      return false;
    return true;
  }
  bool operator != (const PendantEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PendantEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PendantEvent &a, PendantEvent &b);

std::ostream& operator<<(std::ostream& out, const PendantEvent& obj);


class PropValues : public virtual ::apache::thrift::TBase {
 public:

  PropValues(const PropValues&);
  PropValues& operator=(const PropValues&);
  PropValues() noexcept
             : itemID() {
  }

  virtual ~PropValues() noexcept;
  std::string itemID;
  std::map<std::string, Any>  props;

  void __set_itemID(const std::string& val);

  void __set_props(const std::map<std::string, Any> & val);

  bool operator == (const PropValues & rhs) const
  {
    if (!(itemID == rhs.itemID))
      return false;
    if (!(props == rhs.props))
      return false;
    return true;
  }
  bool operator != (const PropValues &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PropValues & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PropValues &a, PropValues &b);

std::ostream& operator<<(std::ostream& out, const PropValues& obj);

typedef struct _ControllerEvent__isset {
  _ControllerEvent__isset() : props(false) {}
  bool props :1;
} _ControllerEvent__isset;

class ControllerEvent : public virtual ::apache::thrift::TBase {
 public:

  ControllerEvent(const ControllerEvent&);
  ControllerEvent& operator=(const ControllerEvent&);
  ControllerEvent() noexcept
                  : eventType(static_cast<ControllerEventType::type>(0)) {
  }

  virtual ~ControllerEvent() noexcept;
  /**
   * 
   * @see ControllerEventType
   */
  ControllerEventType::type eventType;
  std::map<std::string, Any>  props;

  _ControllerEvent__isset __isset;

  void __set_eventType(const ControllerEventType::type val);

  void __set_props(const std::map<std::string, Any> & val);

  bool operator == (const ControllerEvent & rhs) const
  {
    if (!(eventType == rhs.eventType))
      return false;
    if (__isset.props != rhs.__isset.props)
      return false;
    else if (__isset.props && !(props == rhs.props))
      return false;
    return true;
  }
  bool operator != (const ControllerEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ControllerEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ControllerEvent &a, ControllerEvent &b);

std::ostream& operator<<(std::ostream& out, const ControllerEvent& obj);

typedef struct _SimpleControlGroup__isset {
  _SimpleControlGroup__isset() : type(false), index(false) {}
  bool type :1;
  bool index :1;
} _SimpleControlGroup__isset;

/**
 * A simple control group (of axes)
 * A Robot, Robot Base (e.g. rail) or Station
 */
class SimpleControlGroup : public virtual ::apache::thrift::TBase {
 public:

  SimpleControlGroup(const SimpleControlGroup&) noexcept;
  SimpleControlGroup& operator=(const SimpleControlGroup&) noexcept;
  SimpleControlGroup() noexcept
                     : type(static_cast<ControlGroupType::type>(0)),
                       index(0) {
  }

  virtual ~SimpleControlGroup() noexcept;
  /**
   * 
   * @see ControlGroupType
   */
  ControlGroupType::type type;
  int8_t index;

  _SimpleControlGroup__isset __isset;

  void __set_type(const ControlGroupType::type val);

  void __set_index(const int8_t val);

  bool operator == (const SimpleControlGroup & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.index != rhs.__isset.index)
      return false;
    else if (__isset.index && !(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const SimpleControlGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SimpleControlGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SimpleControlGroup &a, SimpleControlGroup &b);

std::ostream& operator<<(std::ostream& out, const SimpleControlGroup& obj);

typedef struct _CombinedControlGroup__isset {
  _CombinedControlGroup__isset() : groups(false), master(false) {}
  bool groups :1;
  bool master :1;
} _CombinedControlGroup__isset;

/**
 * Set of simple control groups combined into a new
 * control group, optionally designating a master
 */
class CombinedControlGroup : public virtual ::apache::thrift::TBase {
 public:

  CombinedControlGroup(const CombinedControlGroup&);
  CombinedControlGroup& operator=(const CombinedControlGroup&);
  CombinedControlGroup() noexcept {
  }

  virtual ~CombinedControlGroup() noexcept;
  std::vector<SimpleControlGroup>  groups;
  SimpleControlGroup master;

  _CombinedControlGroup__isset __isset;

  void __set_groups(const std::vector<SimpleControlGroup> & val);

  void __set_master(const SimpleControlGroup& val);

  bool operator == (const CombinedControlGroup & rhs) const
  {
    if (!(groups == rhs.groups))
      return false;
    if (__isset.master != rhs.__isset.master)
      return false;
    else if (__isset.master && !(master == rhs.master))
      return false;
    return true;
  }
  bool operator != (const CombinedControlGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CombinedControlGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CombinedControlGroup &a, CombinedControlGroup &b);

std::ostream& operator<<(std::ostream& out, const CombinedControlGroup& obj);

typedef struct _ControlGroup__isset {
  _ControlGroup__isset() : type(false), number(false), sgroup(false), cgroup(false) {}
  bool type :1;
  bool number :1;
  bool sgroup :1;
  bool cgroup :1;
} _ControlGroup__isset;

/**
 * General control group
 * May be
 * * simple, such as a single Robot OR
 * * a combined control group consisting of multiple
 *   simple control groups.
 */
class ControlGroup : public virtual ::apache::thrift::TBase {
 public:

  ControlGroup(const ControlGroup&);
  ControlGroup& operator=(const ControlGroup&);
  ControlGroup() noexcept
               : type(static_cast<ControlGroupType::type>(0)),
                 number(0) {
  }

  virtual ~ControlGroup() noexcept;
  /**
   * 
   * @see ControlGroupType
   */
  ControlGroupType::type type;
  int8_t number;
  SimpleControlGroup sgroup;
  CombinedControlGroup cgroup;

  _ControlGroup__isset __isset;

  void __set_type(const ControlGroupType::type val);

  void __set_number(const int8_t val);

  void __set_sgroup(const SimpleControlGroup& val);

  void __set_cgroup(const CombinedControlGroup& val);

  bool operator == (const ControlGroup & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(number == rhs.number))
      return false;
    if (__isset.sgroup != rhs.__isset.sgroup)
      return false;
    else if (__isset.sgroup && !(sgroup == rhs.sgroup))
      return false;
    if (__isset.cgroup != rhs.__isset.cgroup)
      return false;
    else if (__isset.cgroup && !(cgroup == rhs.cgroup))
      return false;
    return true;
  }
  bool operator != (const ControlGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ControlGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ControlGroup &a, ControlGroup &b);

std::ostream& operator<<(std::ostream& out, const ControlGroup& obj);

typedef struct _RobotJobInfo__isset {
  _RobotJobInfo__isset() : name(false), programmingLanguage(false), jobType(false), editable(false), timestamp(false), datetime(false), comment(false), frame(false), controlling(false) {}
  bool name :1;
  bool programmingLanguage :1;
  bool jobType :1;
  bool editable :1;
  bool timestamp :1;
  bool datetime :1;
  bool comment :1;
  bool frame :1;
  bool controlling :1;
} _RobotJobInfo__isset;

class RobotJobInfo : public virtual ::apache::thrift::TBase {
 public:

  RobotJobInfo(const RobotJobInfo&);
  RobotJobInfo& operator=(const RobotJobInfo&);
  RobotJobInfo() noexcept
               : name(),
                 programmingLanguage(),
                 jobType(),
                 editable(0),
                 timestamp(0),
                 datetime(),
                 comment() {
  }

  virtual ~RobotJobInfo() noexcept;
  std::string name;
  std::string programmingLanguage;
  std::string jobType;
  bool editable;
  int64_t timestamp;
  std::string datetime;
  std::string comment;
  CoordinateFrame frame;
  ControlGroup controlling;

  _RobotJobInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_programmingLanguage(const std::string& val);

  void __set_jobType(const std::string& val);

  void __set_editable(const bool val);

  void __set_timestamp(const int64_t val);

  void __set_datetime(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_frame(const CoordinateFrame& val);

  void __set_controlling(const ControlGroup& val);

  bool operator == (const RobotJobInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(programmingLanguage == rhs.programmingLanguage))
      return false;
    if (!(jobType == rhs.jobType))
      return false;
    if (!(editable == rhs.editable))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(datetime == rhs.datetime))
      return false;
    if (!(comment == rhs.comment))
      return false;
    if (!(frame == rhs.frame))
      return false;
    if (!(controlling == rhs.controlling))
      return false;
    return true;
  }
  bool operator != (const RobotJobInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RobotJobInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RobotJobInfo &a, RobotJobInfo &b);

std::ostream& operator<<(std::ostream& out, const RobotJobInfo& obj);

typedef struct _Tool__isset {
  _Tool__isset() : index(false), name(false), weight(false), offset(false), orient(false), centerOfMass(false), momentOfInertia(false), blockIOName(false) {}
  bool index :1;
  bool name :1;
  bool weight :1;
  bool offset :1;
  bool orient :1;
  bool centerOfMass :1;
  bool momentOfInertia :1;
  bool blockIOName :1;
} _Tool__isset;

class Tool : public virtual ::apache::thrift::TBase {
 public:

  Tool(const Tool&);
  Tool& operator=(const Tool&);
  Tool() noexcept
       : index(0),
         name(),
         weight(0),
         blockIOName() {
  }

  virtual ~Tool() noexcept;
  ToolIndex index;
  std::string name;
  double weight;
  Vector offset;
  Orient orient;
  Vector centerOfMass;
  Vector momentOfInertia;
  std::string blockIOName;

  _Tool__isset __isset;

  void __set_index(const ToolIndex val);

  void __set_name(const std::string& val);

  void __set_weight(const double val);

  void __set_offset(const Vector& val);

  void __set_orient(const Orient& val);

  void __set_centerOfMass(const Vector& val);

  void __set_momentOfInertia(const Vector& val);

  void __set_blockIOName(const std::string& val);

  bool operator == (const Tool & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.weight != rhs.__isset.weight)
      return false;
    else if (__isset.weight && !(weight == rhs.weight))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.orient != rhs.__isset.orient)
      return false;
    else if (__isset.orient && !(orient == rhs.orient))
      return false;
    if (__isset.centerOfMass != rhs.__isset.centerOfMass)
      return false;
    else if (__isset.centerOfMass && !(centerOfMass == rhs.centerOfMass))
      return false;
    if (__isset.momentOfInertia != rhs.__isset.momentOfInertia)
      return false;
    else if (__isset.momentOfInertia && !(momentOfInertia == rhs.momentOfInertia))
      return false;
    if (__isset.blockIOName != rhs.__isset.blockIOName)
      return false;
    else if (__isset.blockIOName && !(blockIOName == rhs.blockIOName))
      return false;
    return true;
  }
  bool operator != (const Tool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Tool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Tool &a, Tool &b);

std::ostream& operator<<(std::ostream& out, const Tool& obj);

typedef struct _VariableAddress__isset {
  _VariableAddress__isset() : scope(true), aspace(true), address(false) {}
  bool scope :1;
  bool aspace :1;
  bool address :1;
} _VariableAddress__isset;

/**
 * Variable address (scope, address-space & address/index)
 */
class VariableAddress : public virtual ::apache::thrift::TBase {
 public:

  VariableAddress(const VariableAddress&) noexcept;
  VariableAddress& operator=(const VariableAddress&) noexcept;
  VariableAddress() noexcept
                  : scope(static_cast<Scope::type>(1)),
                    aspace(static_cast<AddressSpace::type>(0)),
                    address(0) {
  }

  virtual ~VariableAddress() noexcept;
  /**
   * 
   * @see Scope
   */
  Scope::type scope;
  /**
   * 
   * @see AddressSpace
   */
  AddressSpace::type aspace;
  int64_t address;

  _VariableAddress__isset __isset;

  void __set_scope(const Scope::type val);

  void __set_aspace(const AddressSpace::type val);

  void __set_address(const int64_t val);

  bool operator == (const VariableAddress & rhs) const
  {
    if (!(scope == rhs.scope))
      return false;
    if (!(aspace == rhs.aspace))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const VariableAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VariableAddress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(VariableAddress &a, VariableAddress &b);

std::ostream& operator<<(std::ostream& out, const VariableAddress& obj);

typedef struct _Zone__isset {
  _Zone__isset() : number(false), name(false), enabled(false), action(false), minPos(false), maxPos(false) {}
  bool number :1;
  bool name :1;
  bool enabled :1;
  bool action :1;
  bool minPos :1;
  bool maxPos :1;
} _Zone__isset;

/**
 * Zone - a region in space
 * * In joint space, defined by minimum and maximum joint angles
 * * In Cartesian space, a lower/min and upper/max corner defining a rectangular prism (a box)
 *   (only Base, Robot and User-Frames are supported for Cartesian zones)
 * 
 * Action determines if an I/O status signal changes in response to zone entry/exit,
 * or if an Alarm is issued upon entry.
 * 
 * Note: index is 0-based, interface Zone Numbers are 1-based
 */
class Zone : public virtual ::apache::thrift::TBase {
 public:

  Zone(const Zone&);
  Zone& operator=(const Zone&);
  Zone() noexcept
       : number(0),
         name(),
         enabled(0),
         action(static_cast<ZoneAction::type>(0)) {
  }

  virtual ~Zone() noexcept;
  int16_t number;
  std::string name;
  bool enabled;
  /**
   * 
   * @see ZoneAction
   */
  ZoneAction::type action;
  Position minPos;
  Position maxPos;

  _Zone__isset __isset;

  void __set_number(const int16_t val);

  void __set_name(const std::string& val);

  void __set_enabled(const bool val);

  void __set_action(const ZoneAction::type val);

  void __set_minPos(const Position& val);

  void __set_maxPos(const Position& val);

  bool operator == (const Zone & rhs) const
  {
    if (!(number == rhs.number))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.enabled != rhs.__isset.enabled)
      return false;
    else if (__isset.enabled && !(enabled == rhs.enabled))
      return false;
    if (__isset.action != rhs.__isset.action)
      return false;
    else if (__isset.action && !(action == rhs.action))
      return false;
    if (__isset.minPos != rhs.__isset.minPos)
      return false;
    else if (__isset.minPos && !(minPos == rhs.minPos))
      return false;
    if (__isset.maxPos != rhs.__isset.maxPos)
      return false;
    else if (__isset.maxPos && !(maxPos == rhs.maxPos))
      return false;
    return true;
  }
  bool operator != (const Zone &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Zone & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Zone &a, Zone &b);

std::ostream& operator<<(std::ostream& out, const Zone& obj);

}}} // namespace

#endif
