/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "extension_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace yaskawa { namespace ext { namespace api {

int _kOrientationRepresentationValues[] = {
  OrientationRepresentation::Quaternion,
  OrientationRepresentation::Matrix,
  OrientationRepresentation::EulerRPY
};
const char* _kOrientationRepresentationNames[] = {
  "Quaternion",
  "Matrix",
  "EulerRPY"
};
const std::map<int, const char*> _OrientationRepresentation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOrientationRepresentationValues, _kOrientationRepresentationNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const OrientationRepresentation::type& val) {
  std::map<int, const char*>::const_iterator it = _OrientationRepresentation_VALUES_TO_NAMES.find(val);
  if (it != _OrientationRepresentation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const OrientationRepresentation::type& val) {
  std::map<int, const char*>::const_iterator it = _OrientationRepresentation_VALUES_TO_NAMES.find(val);
  if (it != _OrientationRepresentation_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLoggingLevelValues[] = {
  LoggingLevel::Debug,
  LoggingLevel::Info,
  LoggingLevel::Warn,
  LoggingLevel::Critical
};
const char* _kLoggingLevelNames[] = {
  "Debug",
  "Info",
  "Warn",
  "Critical"
};
const std::map<int, const char*> _LoggingLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLoggingLevelValues, _kLoggingLevelNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LoggingLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LoggingLevel_VALUES_TO_NAMES.find(val);
  if (it != _LoggingLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LoggingLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LoggingLevel_VALUES_TO_NAMES.find(val);
  if (it != _LoggingLevel_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCoordFrameRepresentationValues[] = {
  CoordFrameRepresentation::Implicit,
  CoordFrameRepresentation::Transform,
  CoordFrameRepresentation::OffsetOrient,
  CoordFrameRepresentation::OriginPlane
};
const char* _kCoordFrameRepresentationNames[] = {
  "Implicit",
  "Transform",
  "OffsetOrient",
  "OriginPlane"
};
const std::map<int, const char*> _CoordFrameRepresentation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCoordFrameRepresentationValues, _kCoordFrameRepresentationNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CoordFrameRepresentation::type& val) {
  std::map<int, const char*>::const_iterator it = _CoordFrameRepresentation_VALUES_TO_NAMES.find(val);
  if (it != _CoordFrameRepresentation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CoordFrameRepresentation::type& val) {
  std::map<int, const char*>::const_iterator it = _CoordFrameRepresentation_VALUES_TO_NAMES.find(val);
  if (it != _CoordFrameRepresentation_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPredefinedCoordFrameTypeValues[] = {
  PredefinedCoordFrameType::Joint,
  PredefinedCoordFrameType::World,
  PredefinedCoordFrameType::Base,
  PredefinedCoordFrameType::Robot,
  PredefinedCoordFrameType::ToolPlate,
  PredefinedCoordFrameType::ToolTip,
  PredefinedCoordFrameType::User,
  PredefinedCoordFrameType::None
};
const char* _kPredefinedCoordFrameTypeNames[] = {
  "Joint",
  "World",
  "Base",
  "Robot",
  "ToolPlate",
  "ToolTip",
  "User",
  "None"
};
const std::map<int, const char*> _PredefinedCoordFrameType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kPredefinedCoordFrameTypeValues, _kPredefinedCoordFrameTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PredefinedCoordFrameType::type& val) {
  std::map<int, const char*>::const_iterator it = _PredefinedCoordFrameType_VALUES_TO_NAMES.find(val);
  if (it != _PredefinedCoordFrameType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PredefinedCoordFrameType::type& val) {
  std::map<int, const char*>::const_iterator it = _PredefinedCoordFrameType_VALUES_TO_NAMES.find(val);
  if (it != _PredefinedCoordFrameType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDistanceUnitValues[] = {
  DistanceUnit::None,
  DistanceUnit::Millimeter,
  DistanceUnit::Inch,
  DistanceUnit::Meter
};
const char* _kDistanceUnitNames[] = {
  "None",
  "Millimeter",
  "Inch",
  "Meter"
};
const std::map<int, const char*> _DistanceUnit_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kDistanceUnitValues, _kDistanceUnitNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DistanceUnit::type& val) {
  std::map<int, const char*>::const_iterator it = _DistanceUnit_VALUES_TO_NAMES.find(val);
  if (it != _DistanceUnit_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DistanceUnit::type& val) {
  std::map<int, const char*>::const_iterator it = _DistanceUnit_VALUES_TO_NAMES.find(val);
  if (it != _DistanceUnit_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kOrientationUnitValues[] = {
  OrientationUnit::None,
  OrientationUnit::Pulse,
  OrientationUnit::Radian,
  OrientationUnit::Degree
};
const char* _kOrientationUnitNames[] = {
  "None",
  "Pulse",
  "Radian",
  "Degree"
};
const std::map<int, const char*> _OrientationUnit_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kOrientationUnitValues, _kOrientationUnitNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const OrientationUnit::type& val) {
  std::map<int, const char*>::const_iterator it = _OrientationUnit_VALUES_TO_NAMES.find(val);
  if (it != _OrientationUnit_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const OrientationUnit::type& val) {
  std::map<int, const char*>::const_iterator it = _OrientationUnit_VALUES_TO_NAMES.find(val);
  if (it != _OrientationUnit_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPendantEventTypeValues[] = {
  PendantEventType::Startup,
  PendantEventType::Shutdown,
  PendantEventType::SwitchedScreen,
  PendantEventType::PopupOpened,
  PendantEventType::PopupClosed,
  PendantEventType::UtilityOpened,
  PendantEventType::UtilityClosed,
  PendantEventType::UtilityMoved,
  PendantEventType::Clicked,
  PendantEventType::Pressed,
  PendantEventType::Released,
  PendantEventType::TextEdited,
  PendantEventType::Accepted,
  PendantEventType::EditingFinished,
  PendantEventType::CheckedChanged,
  PendantEventType::Activated,
  PendantEventType::PanelOpened,
  PendantEventType::PanelClosed,
  PendantEventType::Canceled,
  PendantEventType::Other
};
const char* _kPendantEventTypeNames[] = {
  "Startup",
  "Shutdown",
  "SwitchedScreen",
  "PopupOpened",
  "PopupClosed",
  "UtilityOpened",
  "UtilityClosed",
  "UtilityMoved",
  "Clicked",
  "Pressed",
  "Released",
  "TextEdited",
  "Accepted",
  "EditingFinished",
  "CheckedChanged",
  "Activated",
  "PanelOpened",
  "PanelClosed",
  "Canceled",
  "Other"
};
const std::map<int, const char*> _PendantEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kPendantEventTypeValues, _kPendantEventTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PendantEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PendantEventType_VALUES_TO_NAMES.find(val);
  if (it != _PendantEventType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PendantEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PendantEventType_VALUES_TO_NAMES.find(val);
  if (it != _PendantEventType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kIntegrationPointValues[] = {
  IntegrationPoint::UtilityWindow,
  IntegrationPoint::NavigationPanel,
  IntegrationPoint::ProgrammingCommandBar,
  IntegrationPoint::ProgrammingHeaderBar,
  IntegrationPoint::SmartFrameJogPanelTopLeft,
  IntegrationPoint::SmartFrameJogPanelTopRight,
  IntegrationPoint::SmartFrameJogPanelTopAny,
  IntegrationPoint::SmartFrameJogPanelBottomLeft,
  IntegrationPoint::SmartFrameJogPanelBottomCenter,
  IntegrationPoint::SmartFrameJogPanelBottomRight,
  IntegrationPoint::SmartFrameJogPanelBottomAny,
  IntegrationPoint::JogPanelTopCenter
};
const char* _kIntegrationPointNames[] = {
  "UtilityWindow",
  "NavigationPanel",
  "ProgrammingCommandBar",
  "ProgrammingHeaderBar",
  "SmartFrameJogPanelTopLeft",
  "SmartFrameJogPanelTopRight",
  "SmartFrameJogPanelTopAny",
  "SmartFrameJogPanelBottomLeft",
  "SmartFrameJogPanelBottomCenter",
  "SmartFrameJogPanelBottomRight",
  "SmartFrameJogPanelBottomAny",
  "JogPanelTopCenter"
};
const std::map<int, const char*> _IntegrationPoint_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kIntegrationPointValues, _kIntegrationPointNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const IntegrationPoint::type& val) {
  std::map<int, const char*>::const_iterator it = _IntegrationPoint_VALUES_TO_NAMES.find(val);
  if (it != _IntegrationPoint_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const IntegrationPoint::type& val) {
  std::map<int, const char*>::const_iterator it = _IntegrationPoint_VALUES_TO_NAMES.find(val);
  if (it != _IntegrationPoint_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDispositionValues[] = {
  Disposition::Negative,
  Disposition::Neutral,
  Disposition::Positive
};
const char* _kDispositionNames[] = {
  "Negative",
  "Neutral",
  "Positive"
};
const std::map<int, const char*> _Disposition_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kDispositionValues, _kDispositionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Disposition::type& val) {
  std::map<int, const char*>::const_iterator it = _Disposition_VALUES_TO_NAMES.find(val);
  if (it != _Disposition_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Disposition::type& val) {
  std::map<int, const char*>::const_iterator it = _Disposition_VALUES_TO_NAMES.find(val);
  if (it != _Disposition_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kControllerEventTypeValues[] = {
  ControllerEventType::Connected,
  ControllerEventType::RobotModel,
  ControllerEventType::ExclusiveControl,
  ControllerEventType::CycleTime,
  ControllerEventType::PowerOnTime,
  ControllerEventType::ServoOnTime,
  ControllerEventType::EnabledOptionsChanged,
  ControllerEventType::OperationMode,
  ControllerEventType::ServoState,
  ControllerEventType::PlaybackState,
  ControllerEventType::SpeedOverride,
  ControllerEventType::ActiveTool,
  ControllerEventType::AlarmActive,
  ControllerEventType::ActiveAlarmsChanged,
  ControllerEventType::RestartRequired,
  ControllerEventType::EStopEngaged,
  ControllerEventType::EnableSwitchActive,
  ControllerEventType::RemoteMode,
  ControllerEventType::JoggingActive,
  ControllerEventType::JoggingSpeedChanged,
  ControllerEventType::JoggingModeChanged,
  ControllerEventType::RobotTCPPosition,
  ControllerEventType::BrakeRelease,
  ControllerEventType::SoftLimitRelease,
  ControllerEventType::SelfInterferenceRelease,
  ControllerEventType::AllLimitsRelease,
  ControllerEventType::ParametersChanged,
  ControllerEventType::PredefinedPositionsChanged,
  ControllerEventType::FeatureAvailabilityChanged,
  ControllerEventType::JointLimitsChanged,
  ControllerEventType::JointMotorPulseDegreeRatioChanged,
  ControllerEventType::FunctionalSafetyHardwareAvailable,
  ControllerEventType::NetworkInterfacesChanged,
  ControllerEventType::CurrentRobot,
  ControllerEventType::JobTagsChanged,
  ControllerEventType::JobListChanged,
  ControllerEventType::JobStackChanged,
  ControllerEventType::CurrentJob,
  ControllerEventType::DefaultJob,
  ControllerEventType::ToolsChanged,
  ControllerEventType::ToolIOsChanged,
  ControllerEventType::UserFramesChanged,
  ControllerEventType::ZonesChanged,
  ControllerEventType::SafetyRobotRangeLimitDataChanged,
  ControllerEventType::SafetyAxisSpeedMonitorDataChanged,
  ControllerEventType::SafetySpeedLimitDataChanged,
  ControllerEventType::SafetyExternalForceMonitorFileChanged,
  ControllerEventType::SafetyIOListChanged,
  ControllerEventType::VariablesChanged,
  ControllerEventType::VariableNamesChanged,
  ControllerEventType::IONamesChanged,
  ControllerEventType::IOValueChanged,
  ControllerEventType::PermissionGranted,
  ControllerEventType::PermissionRevoked
};
const char* _kControllerEventTypeNames[] = {
  "Connected",
  "RobotModel",
  "ExclusiveControl",
  "CycleTime",
  "PowerOnTime",
  "ServoOnTime",
  "EnabledOptionsChanged",
  "OperationMode",
  "ServoState",
  "PlaybackState",
  "SpeedOverride",
  "ActiveTool",
  "AlarmActive",
  "ActiveAlarmsChanged",
  "RestartRequired",
  "EStopEngaged",
  "EnableSwitchActive",
  "RemoteMode",
  "JoggingActive",
  "JoggingSpeedChanged",
  "JoggingModeChanged",
  "RobotTCPPosition",
  "BrakeRelease",
  "SoftLimitRelease",
  "SelfInterferenceRelease",
  "AllLimitsRelease",
  "ParametersChanged",
  "PredefinedPositionsChanged",
  "FeatureAvailabilityChanged",
  "JointLimitsChanged",
  "JointMotorPulseDegreeRatioChanged",
  "FunctionalSafetyHardwareAvailable",
  "NetworkInterfacesChanged",
  "CurrentRobot",
  "JobTagsChanged",
  "JobListChanged",
  "JobStackChanged",
  "CurrentJob",
  "DefaultJob",
  "ToolsChanged",
  "ToolIOsChanged",
  "UserFramesChanged",
  "ZonesChanged",
  "SafetyRobotRangeLimitDataChanged",
  "SafetyAxisSpeedMonitorDataChanged",
  "SafetySpeedLimitDataChanged",
  "SafetyExternalForceMonitorFileChanged",
  "SafetyIOListChanged",
  "VariablesChanged",
  "VariableNamesChanged",
  "IONamesChanged",
  "IOValueChanged",
  "PermissionGranted",
  "PermissionRevoked"
};
const std::map<int, const char*> _ControllerEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(54, _kControllerEventTypeValues, _kControllerEventTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ControllerEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _ControllerEventType_VALUES_TO_NAMES.find(val);
  if (it != _ControllerEventType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ControllerEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _ControllerEventType_VALUES_TO_NAMES.find(val);
  if (it != _ControllerEventType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kOperationModeValues[] = {
  OperationMode::Automatic,
  OperationMode::Manual
};
const char* _kOperationModeNames[] = {
  "Automatic",
  "Manual"
};
const std::map<int, const char*> _OperationMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kOperationModeValues, _kOperationModeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const OperationMode::type& val) {
  std::map<int, const char*>::const_iterator it = _OperationMode_VALUES_TO_NAMES.find(val);
  if (it != _OperationMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const OperationMode::type& val) {
  std::map<int, const char*>::const_iterator it = _OperationMode_VALUES_TO_NAMES.find(val);
  if (it != _OperationMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kServoStateValues[] = {
  ServoState::Off,
  ServoState::Ready,
  ServoState::On
};
const char* _kServoStateNames[] = {
  "Off",
  "Ready",
  "On"
};
const std::map<int, const char*> _ServoState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kServoStateValues, _kServoStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ServoState::type& val) {
  std::map<int, const char*>::const_iterator it = _ServoState_VALUES_TO_NAMES.find(val);
  if (it != _ServoState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ServoState::type& val) {
  std::map<int, const char*>::const_iterator it = _ServoState_VALUES_TO_NAMES.find(val);
  if (it != _ServoState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPlaybackStateValues[] = {
  PlaybackState::Run,
  PlaybackState::Hold,
  PlaybackState::Idle
};
const char* _kPlaybackStateNames[] = {
  "Run",
  "Hold",
  "Idle"
};
const std::map<int, const char*> _PlaybackState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPlaybackStateValues, _kPlaybackStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PlaybackState::type& val) {
  std::map<int, const char*>::const_iterator it = _PlaybackState_VALUES_TO_NAMES.find(val);
  if (it != _PlaybackState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PlaybackState::type& val) {
  std::map<int, const char*>::const_iterator it = _PlaybackState_VALUES_TO_NAMES.find(val);
  if (it != _PlaybackState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kControlGroupTypeValues[] = {
  ControlGroupType::Robot,
  ControlGroupType::Base,
  ControlGroupType::Station,
  ControlGroupType::Combined,
  ControlGroupType::None
};
const char* _kControlGroupTypeNames[] = {
  "Robot",
  "Base",
  "Station",
  "Combined",
  "None"
};
const std::map<int, const char*> _ControlGroupType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kControlGroupTypeValues, _kControlGroupTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ControlGroupType::type& val) {
  std::map<int, const char*>::const_iterator it = _ControlGroupType_VALUES_TO_NAMES.find(val);
  if (it != _ControlGroupType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ControlGroupType::type& val) {
  std::map<int, const char*>::const_iterator it = _ControlGroupType_VALUES_TO_NAMES.find(val);
  if (it != _ControlGroupType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kScopeValues[] = {
  Scope::Local,
  Scope::Global
};
const char* _kScopeNames[] = {
  "Local",
  "Global"
};
const std::map<int, const char*> _Scope_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kScopeValues, _kScopeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Scope::type& val) {
  std::map<int, const char*>::const_iterator it = _Scope_VALUES_TO_NAMES.find(val);
  if (it != _Scope_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Scope::type& val) {
  std::map<int, const char*>::const_iterator it = _Scope_VALUES_TO_NAMES.find(val);
  if (it != _Scope_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kAddressSpaceValues[] = {
  AddressSpace::Unified,
  AddressSpace::Byte,
  AddressSpace::Int,
  AddressSpace::DoubleInt,
  AddressSpace::Real,
  AddressSpace::String,
  AddressSpace::Position
};
const char* _kAddressSpaceNames[] = {
  "Unified",
  "Byte",
  "Int",
  "DoubleInt",
  "Real",
  "String",
  "Position"
};
const std::map<int, const char*> _AddressSpace_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kAddressSpaceValues, _kAddressSpaceNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const AddressSpace::type& val) {
  std::map<int, const char*>::const_iterator it = _AddressSpace_VALUES_TO_NAMES.find(val);
  if (it != _AddressSpace_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const AddressSpace::type& val) {
  std::map<int, const char*>::const_iterator it = _AddressSpace_VALUES_TO_NAMES.find(val);
  if (it != _AddressSpace_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kZoneActionValues[] = {
  ZoneAction::Status,
  ZoneAction::Alarm
};
const char* _kZoneActionNames[] = {
  "Status",
  "Alarm"
};
const std::map<int, const char*> _ZoneAction_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kZoneActionValues, _kZoneActionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ZoneAction::type& val) {
  std::map<int, const char*>::const_iterator it = _ZoneAction_VALUES_TO_NAMES.find(val);
  if (it != _ZoneAction_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ZoneAction::type& val) {
  std::map<int, const char*>::const_iterator it = _ZoneAction_VALUES_TO_NAMES.find(val);
  if (it != _ZoneAction_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


InvalidID::~InvalidID() noexcept {
}

std::ostream& operator<<(std::ostream& out, const InvalidID& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidID::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidID");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidID &a, InvalidID &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

InvalidID::InvalidID(const InvalidID& other0) noexcept : TException() {
  (void) other0;
}
InvalidID& InvalidID::operator=(const InvalidID& other1) noexcept {
  (void) other1;
  return *this;
}
void InvalidID::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidID(";
  out << ")";
}

const char* InvalidID::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidID";
  }
}


IllegalArgument::~IllegalArgument() noexcept {
}


void IllegalArgument::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const IllegalArgument& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IllegalArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_msg = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          isset_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_msg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IllegalArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IllegalArgument");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IllegalArgument &a, IllegalArgument &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
}

IllegalArgument::IllegalArgument(const IllegalArgument& other2) : TException() {
  msg = other2.msg;
}
IllegalArgument& IllegalArgument::operator=(const IllegalArgument& other3) {
  msg = other3.msg;
  return *this;
}
void IllegalArgument::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IllegalArgument(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* IllegalArgument::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: IllegalArgument";
  }
}


Matrix::~Matrix() noexcept {
}


void Matrix::__set_rows(const int64_t val) {
  this->rows = val;
}

void Matrix::__set_cols(const int64_t val) {
  this->cols = val;
}

void Matrix::__set_m(const std::vector<Vector> & val) {
  this->m = val;
}
std::ostream& operator<<(std::ostream& out, const Matrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Matrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows);
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cols);
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->m.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->m.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              {
                this->m[_i8].clear();
                uint32_t _size9;
                ::apache::thrift::protocol::TType _etype12;
                xfer += iprot->readListBegin(_etype12, _size9);
                this->m[_i8].resize(_size9);
                uint32_t _i13;
                for (_i13 = 0; _i13 < _size9; ++_i13)
                {
                  xfer += iprot->readDouble(this->m[_i8][_i13]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.m = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Matrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Matrix");

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("m", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->m.size()));
    std::vector<Vector> ::const_iterator _iter14;
    for (_iter14 = this->m.begin(); _iter14 != this->m.end(); ++_iter14)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter14).size()));
        std::vector<double> ::const_iterator _iter15;
        for (_iter15 = (*_iter14).begin(); _iter15 != (*_iter14).end(); ++_iter15)
        {
          xfer += oprot->writeDouble((*_iter15));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Matrix &a, Matrix &b) {
  using ::std::swap;
  swap(a.rows, b.rows);
  swap(a.cols, b.cols);
  swap(a.m, b.m);
  swap(a.__isset, b.__isset);
}

Matrix::Matrix(const Matrix& other16) {
  rows = other16.rows;
  cols = other16.cols;
  m = other16.m;
  __isset = other16.__isset;
}
Matrix& Matrix::operator=(const Matrix& other17) {
  rows = other17.rows;
  cols = other17.cols;
  m = other17.m;
  __isset = other17.__isset;
  return *this;
}
void Matrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Matrix(";
  out << "rows=" << to_string(rows);
  out << ", " << "cols=" << to_string(cols);
  out << ", " << "m=" << to_string(m);
  out << ")";
}


Orient::~Orient() noexcept {
}


void Orient::__set_rep(const OrientationRepresentation::type val) {
  this->rep = val;
}

void Orient::__set_v(const Vector& val) {
  this->v = val;
__isset.v = true;
}

void Orient::__set_m(const Matrix& val) {
  this->m = val;
__isset.m = true;
}
std::ostream& operator<<(std::ostream& out, const Orient& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Orient::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->rep = static_cast<OrientationRepresentation::type>(ecast18);
          this->__isset.rep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->v.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readDouble(this->v[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->m.read(iprot);
          this->__isset.m = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Orient::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Orient");

  xfer += oprot->writeFieldBegin("rep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->rep));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->v.size()));
      std::vector<double> ::const_iterator _iter24;
      for (_iter24 = this->v.begin(); _iter24 != this->v.end(); ++_iter24)
      {
        xfer += oprot->writeDouble((*_iter24));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.m) {
    xfer += oprot->writeFieldBegin("m", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->m.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Orient &a, Orient &b) {
  using ::std::swap;
  swap(a.rep, b.rep);
  swap(a.v, b.v);
  swap(a.m, b.m);
  swap(a.__isset, b.__isset);
}

Orient::Orient(const Orient& other25) {
  rep = other25.rep;
  v = other25.v;
  m = other25.m;
  __isset = other25.__isset;
}
Orient& Orient::operator=(const Orient& other26) {
  rep = other26.rep;
  v = other26.v;
  m = other26.m;
  __isset = other26.__isset;
  return *this;
}
void Orient::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Orient(";
  out << "rep=" << to_string(rep);
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ", " << "m="; (__isset.m ? (out << to_string(m)) : (out << "<null>"));
  out << ")";
}


VectorOrient::~VectorOrient() noexcept {
}


void VectorOrient::__set_v(const Vector& val) {
  this->v = val;
}

void VectorOrient::__set_o(const Orient& val) {
  this->o = val;
}
std::ostream& operator<<(std::ostream& out, const VectorOrient& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VectorOrient::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->v.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readDouble(this->v[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->o.read(iprot);
          this->__isset.o = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VectorOrient::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VectorOrient");

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->v.size()));
    std::vector<double> ::const_iterator _iter32;
    for (_iter32 = this->v.begin(); _iter32 != this->v.end(); ++_iter32)
    {
      xfer += oprot->writeDouble((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("o", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->o.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VectorOrient &a, VectorOrient &b) {
  using ::std::swap;
  swap(a.v, b.v);
  swap(a.o, b.o);
  swap(a.__isset, b.__isset);
}

VectorOrient::VectorOrient(const VectorOrient& other33) {
  v = other33.v;
  o = other33.o;
  __isset = other33.__isset;
}
VectorOrient& VectorOrient::operator=(const VectorOrient& other34) {
  v = other34.v;
  o = other34.o;
  __isset = other34.__isset;
  return *this;
}
void VectorOrient::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VectorOrient(";
  out << "v=" << to_string(v);
  out << ", " << "o=" << to_string(o);
  out << ")";
}


PointPlane::~PointPlane() noexcept {
}


void PointPlane::__set_origin(const Point& val) {
  this->origin = val;
}

void PointPlane::__set_xx(const Point& val) {
  this->xx = val;
}

void PointPlane::__set_xy(const Point& val) {
  this->xy = val;
}
std::ostream& operator<<(std::ostream& out, const PointPlane& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PointPlane::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->origin.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->origin.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += iprot->readDouble(this->origin[_i39]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->xx.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->xx.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += iprot->readDouble(this->xx[_i44]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.xx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->xy.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->xy.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += iprot->readDouble(this->xy[_i49]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.xy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PointPlane::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PointPlane");

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->origin.size()));
    std::vector<double> ::const_iterator _iter50;
    for (_iter50 = this->origin.begin(); _iter50 != this->origin.end(); ++_iter50)
    {
      xfer += oprot->writeDouble((*_iter50));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xx", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->xx.size()));
    std::vector<double> ::const_iterator _iter51;
    for (_iter51 = this->xx.begin(); _iter51 != this->xx.end(); ++_iter51)
    {
      xfer += oprot->writeDouble((*_iter51));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xy", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->xy.size()));
    std::vector<double> ::const_iterator _iter52;
    for (_iter52 = this->xy.begin(); _iter52 != this->xy.end(); ++_iter52)
    {
      xfer += oprot->writeDouble((*_iter52));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PointPlane &a, PointPlane &b) {
  using ::std::swap;
  swap(a.origin, b.origin);
  swap(a.xx, b.xx);
  swap(a.xy, b.xy);
  swap(a.__isset, b.__isset);
}

PointPlane::PointPlane(const PointPlane& other53) {
  origin = other53.origin;
  xx = other53.xx;
  xy = other53.xy;
  __isset = other53.__isset;
}
PointPlane& PointPlane::operator=(const PointPlane& other54) {
  origin = other54.origin;
  xx = other54.xx;
  xy = other54.xy;
  __isset = other54.__isset;
  return *this;
}
void PointPlane::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PointPlane(";
  out << "origin=" << to_string(origin);
  out << ", " << "xx=" << to_string(xx);
  out << ", " << "xy=" << to_string(xy);
  out << ")";
}


Version::~Version() noexcept {
}


void Version::__set_nmajor(const int16_t val) {
  this->nmajor = val;
}

void Version::__set_nminor(const int16_t val) {
  this->nminor = val;
}

void Version::__set_npatch(const int16_t val) {
  this->npatch = val;
}

void Version::__set_release(const std::string& val) {
  this->release = val;
__isset.release = true;
}

void Version::__set_build(const std::string& val) {
  this->build = val;
__isset.build = true;
}
std::ostream& operator<<(std::ostream& out, const Version& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Version::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->nmajor);
          this->__isset.nmajor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->nminor);
          this->__isset.nminor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->npatch);
          this->__isset.npatch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->release);
          this->__isset.release = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->build);
          this->__isset.build = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Version::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Version");

  xfer += oprot->writeFieldBegin("nmajor", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->nmajor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nminor", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->nminor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("npatch", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->npatch);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.release) {
    xfer += oprot->writeFieldBegin("release", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->release);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.build) {
    xfer += oprot->writeFieldBegin("build", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->build);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Version &a, Version &b) {
  using ::std::swap;
  swap(a.nmajor, b.nmajor);
  swap(a.nminor, b.nminor);
  swap(a.npatch, b.npatch);
  swap(a.release, b.release);
  swap(a.build, b.build);
  swap(a.__isset, b.__isset);
}

Version::Version(const Version& other55) {
  nmajor = other55.nmajor;
  nminor = other55.nminor;
  npatch = other55.npatch;
  release = other55.release;
  build = other55.build;
  __isset = other55.__isset;
}
Version& Version::operator=(const Version& other56) {
  nmajor = other56.nmajor;
  nminor = other56.nminor;
  npatch = other56.npatch;
  release = other56.release;
  build = other56.build;
  __isset = other56.__isset;
  return *this;
}
void Version::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Version(";
  out << "nmajor=" << to_string(nmajor);
  out << ", " << "nminor=" << to_string(nminor);
  out << ", " << "npatch=" << to_string(npatch);
  out << ", " << "release="; (__isset.release ? (out << to_string(release)) : (out << "<null>"));
  out << ", " << "build="; (__isset.build ? (out << to_string(build)) : (out << "<null>"));
  out << ")";
}


CoordinateFrame::~CoordinateFrame() noexcept {
}


void CoordinateFrame::__set_rep(const CoordFrameRepresentation::type val) {
  this->rep = val;
}

void CoordinateFrame::__set_predefined(const PredefinedCoordFrameType::type val) {
  this->predefined = val;
}

void CoordinateFrame::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void CoordinateFrame::__set_robot(const RobotIndex val) {
  this->robot = val;
__isset.robot = true;
}

void CoordinateFrame::__set_tool(const ToolIndex val) {
  this->tool = val;
__isset.tool = true;
}

void CoordinateFrame::__set_transform(const Matrix& val) {
  this->transform = val;
__isset.transform = true;
}

void CoordinateFrame::__set_vecorient(const VectorOrient& val) {
  this->vecorient = val;
__isset.vecorient = true;
}

void CoordinateFrame::__set_userFrame(const UserFrameIndex val) {
  this->userFrame = val;
__isset.userFrame = true;
}

void CoordinateFrame::__set_pointplane(const PointPlane& val) {
  this->pointplane = val;
__isset.pointplane = true;
}
std::ostream& operator<<(std::ostream& out, const CoordinateFrame& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoordinateFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast57;
          xfer += iprot->readI32(ecast57);
          this->rep = static_cast<CoordFrameRepresentation::type>(ecast57);
          this->__isset.rep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->predefined = static_cast<PredefinedCoordFrameType::type>(ecast58);
          this->__isset.predefined = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->robot);
          this->__isset.robot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tool);
          this->__isset.tool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vecorient.read(iprot);
          this->__isset.vecorient = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userFrame);
          this->__isset.userFrame = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pointplane.read(iprot);
          this->__isset.pointplane = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoordinateFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoordinateFrame");

  xfer += oprot->writeFieldBegin("rep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->rep));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("predefined", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->predefined));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.robot) {
    xfer += oprot->writeFieldBegin("robot", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->robot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tool) {
    xfer += oprot->writeFieldBegin("tool", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->tool);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transform) {
    xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->transform.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vecorient) {
    xfer += oprot->writeFieldBegin("vecorient", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->vecorient.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userFrame) {
    xfer += oprot->writeFieldBegin("userFrame", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->userFrame);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pointplane) {
    xfer += oprot->writeFieldBegin("pointplane", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->pointplane.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoordinateFrame &a, CoordinateFrame &b) {
  using ::std::swap;
  swap(a.rep, b.rep);
  swap(a.predefined, b.predefined);
  swap(a.name, b.name);
  swap(a.robot, b.robot);
  swap(a.tool, b.tool);
  swap(a.transform, b.transform);
  swap(a.vecorient, b.vecorient);
  swap(a.userFrame, b.userFrame);
  swap(a.pointplane, b.pointplane);
  swap(a.__isset, b.__isset);
}

CoordinateFrame::CoordinateFrame(const CoordinateFrame& other59) {
  rep = other59.rep;
  predefined = other59.predefined;
  name = other59.name;
  robot = other59.robot;
  tool = other59.tool;
  transform = other59.transform;
  vecorient = other59.vecorient;
  userFrame = other59.userFrame;
  pointplane = other59.pointplane;
  __isset = other59.__isset;
}
CoordinateFrame& CoordinateFrame::operator=(const CoordinateFrame& other60) {
  rep = other60.rep;
  predefined = other60.predefined;
  name = other60.name;
  robot = other60.robot;
  tool = other60.tool;
  transform = other60.transform;
  vecorient = other60.vecorient;
  userFrame = other60.userFrame;
  pointplane = other60.pointplane;
  __isset = other60.__isset;
  return *this;
}
void CoordinateFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoordinateFrame(";
  out << "rep=" << to_string(rep);
  out << ", " << "predefined=" << to_string(predefined);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "robot="; (__isset.robot ? (out << to_string(robot)) : (out << "<null>"));
  out << ", " << "tool="; (__isset.tool ? (out << to_string(tool)) : (out << "<null>"));
  out << ", " << "transform="; (__isset.transform ? (out << to_string(transform)) : (out << "<null>"));
  out << ", " << "vecorient="; (__isset.vecorient ? (out << to_string(vecorient)) : (out << "<null>"));
  out << ", " << "userFrame="; (__isset.userFrame ? (out << to_string(userFrame)) : (out << "<null>"));
  out << ", " << "pointplane="; (__isset.pointplane ? (out << to_string(pointplane)) : (out << "<null>"));
  out << ")";
}


Position::~Position() noexcept {
}


void Position::__set_frame(const CoordinateFrame& val) {
  this->frame = val;
}

void Position::__set_distUnit(const DistanceUnit::type val) {
  this->distUnit = val;
__isset.distUnit = true;
}

void Position::__set_orientUnit(const OrientationUnit::type val) {
  this->orientUnit = val;
}

void Position::__set_pos(const Vector& val) {
  this->pos = val;
__isset.pos = true;
}

void Position::__set_orient(const Orient& val) {
  this->orient = val;
__isset.orient = true;
}

void Position::__set_joints(const Vector& val) {
  this->joints = val;
__isset.joints = true;
}

void Position::__set_closure(const IVector& val) {
  this->closure = val;
__isset.closure = true;
}
std::ostream& operator<<(std::ostream& out, const Position& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Position::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frame.read(iprot);
          this->__isset.frame = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast61;
          xfer += iprot->readI32(ecast61);
          this->distUnit = static_cast<DistanceUnit::type>(ecast61);
          this->__isset.distUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast62;
          xfer += iprot->readI32(ecast62);
          this->orientUnit = static_cast<OrientationUnit::type>(ecast62);
          this->__isset.orientUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pos.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->pos.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += iprot->readDouble(this->pos[_i67]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->orient.read(iprot);
          this->__isset.orient = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->joints.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            xfer += iprot->readListBegin(_etype71, _size68);
            this->joints.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              xfer += iprot->readDouble(this->joints[_i72]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.joints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->closure.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->closure.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += iprot->readI64(this->closure[_i77]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.closure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Position::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Position");

  xfer += oprot->writeFieldBegin("frame", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->frame.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.distUnit) {
    xfer += oprot->writeFieldBegin("distUnit", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(static_cast<int32_t>(this->distUnit));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("orientUnit", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->orientUnit));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->pos.size()));
      std::vector<double> ::const_iterator _iter78;
      for (_iter78 = this->pos.begin(); _iter78 != this->pos.end(); ++_iter78)
      {
        xfer += oprot->writeDouble((*_iter78));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orient) {
    xfer += oprot->writeFieldBegin("orient", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->orient.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.joints) {
    xfer += oprot->writeFieldBegin("joints", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->joints.size()));
      std::vector<double> ::const_iterator _iter79;
      for (_iter79 = this->joints.begin(); _iter79 != this->joints.end(); ++_iter79)
      {
        xfer += oprot->writeDouble((*_iter79));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.closure) {
    xfer += oprot->writeFieldBegin("closure", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->closure.size()));
      std::vector<int64_t> ::const_iterator _iter80;
      for (_iter80 = this->closure.begin(); _iter80 != this->closure.end(); ++_iter80)
      {
        xfer += oprot->writeI64((*_iter80));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Position &a, Position &b) {
  using ::std::swap;
  swap(a.frame, b.frame);
  swap(a.distUnit, b.distUnit);
  swap(a.orientUnit, b.orientUnit);
  swap(a.pos, b.pos);
  swap(a.orient, b.orient);
  swap(a.joints, b.joints);
  swap(a.closure, b.closure);
  swap(a.__isset, b.__isset);
}

Position::Position(const Position& other81) {
  frame = other81.frame;
  distUnit = other81.distUnit;
  orientUnit = other81.orientUnit;
  pos = other81.pos;
  orient = other81.orient;
  joints = other81.joints;
  closure = other81.closure;
  __isset = other81.__isset;
}
Position& Position::operator=(const Position& other82) {
  frame = other82.frame;
  distUnit = other82.distUnit;
  orientUnit = other82.orientUnit;
  pos = other82.pos;
  orient = other82.orient;
  joints = other82.joints;
  closure = other82.closure;
  __isset = other82.__isset;
  return *this;
}
void Position::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Position(";
  out << "frame=" << to_string(frame);
  out << ", " << "distUnit="; (__isset.distUnit ? (out << to_string(distUnit)) : (out << "<null>"));
  out << ", " << "orientUnit=" << to_string(orientUnit);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "orient="; (__isset.orient ? (out << to_string(orient)) : (out << "<null>"));
  out << ", " << "joints="; (__isset.joints ? (out << to_string(joints)) : (out << "<null>"));
  out << ", " << "closure="; (__isset.closure ? (out << to_string(closure)) : (out << "<null>"));
  out << ")";
}


Any::~Any() noexcept {
}


void Any::__set_bValue(const bool val) {
  this->bValue = val;
__isset.bValue = true;
}

void Any::__set_iValue(const int64_t val) {
  this->iValue = val;
__isset.iValue = true;
}

void Any::__set_rValue(const double val) {
  this->rValue = val;
__isset.rValue = true;
}

void Any::__set_sValue(const std::string& val) {
  this->sValue = val;
__isset.sValue = true;
}

void Any::__set_vValue(const Vector& val) {
  this->vValue = val;
__isset.vValue = true;
}

void Any::__set_pValue(const Position& val) {
  this->pValue = val;
__isset.pValue = true;
}

void Any::__set_aValue(const std::vector<Any> & val) {
  this->aValue = val;
__isset.aValue = true;
}

void Any::__set_mValue(const std::map<std::string, Any> & val) {
  this->mValue = val;
__isset.mValue = true;
}
std::ostream& operator<<(std::ostream& out, const Any& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Any::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bValue);
          this->__isset.bValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iValue);
          this->__isset.iValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->rValue);
          this->__isset.rValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sValue);
          this->__isset.sValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vValue.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->vValue.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += iprot->readDouble(this->vValue[_i87]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pValue.read(iprot);
          this->__isset.pValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aValue.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->aValue.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += this->aValue[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->mValue.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _ktype94;
            ::apache::thrift::protocol::TType _vtype95;
            xfer += iprot->readMapBegin(_ktype94, _vtype95, _size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              std::string _key98;
              xfer += iprot->readString(_key98);
              Any& _val99 = this->mValue[_key98];
              xfer += _val99.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.mValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Any::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Any");

  if (this->__isset.bValue) {
    xfer += oprot->writeFieldBegin("bValue", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->bValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iValue) {
    xfer += oprot->writeFieldBegin("iValue", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->iValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rValue) {
    xfer += oprot->writeFieldBegin("rValue", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->rValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sValue) {
    xfer += oprot->writeFieldBegin("sValue", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->sValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vValue) {
    xfer += oprot->writeFieldBegin("vValue", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->vValue.size()));
      std::vector<double> ::const_iterator _iter100;
      for (_iter100 = this->vValue.begin(); _iter100 != this->vValue.end(); ++_iter100)
      {
        xfer += oprot->writeDouble((*_iter100));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pValue) {
    xfer += oprot->writeFieldBegin("pValue", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->pValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aValue) {
    xfer += oprot->writeFieldBegin("aValue", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aValue.size()));
      std::vector<Any> ::const_iterator _iter101;
      for (_iter101 = this->aValue.begin(); _iter101 != this->aValue.end(); ++_iter101)
      {
        xfer += (*_iter101).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mValue) {
    xfer += oprot->writeFieldBegin("mValue", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mValue.size()));
      std::map<std::string, Any> ::const_iterator _iter102;
      for (_iter102 = this->mValue.begin(); _iter102 != this->mValue.end(); ++_iter102)
      {
        xfer += oprot->writeString(_iter102->first);
        xfer += _iter102->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Any &a, Any &b) {
  using ::std::swap;
  swap(a.bValue, b.bValue);
  swap(a.iValue, b.iValue);
  swap(a.rValue, b.rValue);
  swap(a.sValue, b.sValue);
  swap(a.vValue, b.vValue);
  swap(a.pValue, b.pValue);
  swap(a.aValue, b.aValue);
  swap(a.mValue, b.mValue);
  swap(a.__isset, b.__isset);
}

Any::Any(const Any& other103) {
  bValue = other103.bValue;
  iValue = other103.iValue;
  rValue = other103.rValue;
  sValue = other103.sValue;
  vValue = other103.vValue;
  pValue = other103.pValue;
  aValue = other103.aValue;
  mValue = other103.mValue;
  __isset = other103.__isset;
}
Any& Any::operator=(const Any& other104) {
  bValue = other104.bValue;
  iValue = other104.iValue;
  rValue = other104.rValue;
  sValue = other104.sValue;
  vValue = other104.vValue;
  pValue = other104.pValue;
  aValue = other104.aValue;
  mValue = other104.mValue;
  __isset = other104.__isset;
  return *this;
}
void Any::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Any(";
  out << "bValue="; (__isset.bValue ? (out << to_string(bValue)) : (out << "<null>"));
  out << ", " << "iValue="; (__isset.iValue ? (out << to_string(iValue)) : (out << "<null>"));
  out << ", " << "rValue="; (__isset.rValue ? (out << to_string(rValue)) : (out << "<null>"));
  out << ", " << "sValue="; (__isset.sValue ? (out << to_string(sValue)) : (out << "<null>"));
  out << ", " << "vValue="; (__isset.vValue ? (out << to_string(vValue)) : (out << "<null>"));
  out << ", " << "pValue="; (__isset.pValue ? (out << to_string(pValue)) : (out << "<null>"));
  out << ", " << "aValue="; (__isset.aValue ? (out << to_string(aValue)) : (out << "<null>"));
  out << ", " << "mValue="; (__isset.mValue ? (out << to_string(mValue)) : (out << "<null>"));
  out << ")";
}


LoggingEvent::~LoggingEvent() noexcept {
}


void LoggingEvent::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void LoggingEvent::__set_datetime(const std::string& val) {
  this->datetime = val;
}

void LoggingEvent::__set_level(const LoggingLevel::type val) {
  this->level = val;
}

void LoggingEvent::__set_entry(const std::string& val) {
  this->entry = val;
}
std::ostream& operator<<(std::ostream& out, const LoggingEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoggingEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datetime);
          this->__isset.datetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->level = static_cast<LoggingLevel::type>(ecast105);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entry);
          this->__isset.entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoggingEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoggingEvent");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("datetime", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->datetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->level));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->entry);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoggingEvent &a, LoggingEvent &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.datetime, b.datetime);
  swap(a.level, b.level);
  swap(a.entry, b.entry);
  swap(a.__isset, b.__isset);
}

LoggingEvent::LoggingEvent(const LoggingEvent& other106) {
  timestamp = other106.timestamp;
  datetime = other106.datetime;
  level = other106.level;
  entry = other106.entry;
  __isset = other106.__isset;
}
LoggingEvent& LoggingEvent::operator=(const LoggingEvent& other107) {
  timestamp = other107.timestamp;
  datetime = other107.datetime;
  level = other107.level;
  entry = other107.entry;
  __isset = other107.__isset;
  return *this;
}
void LoggingEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoggingEvent(";
  out << "timestamp=" << to_string(timestamp);
  out << ", " << "datetime=" << to_string(datetime);
  out << ", " << "level=" << to_string(level);
  out << ", " << "entry=" << to_string(entry);
  out << ")";
}


Series::~Series() noexcept {
}


void Series::__set_x(const Vector& val) {
  this->x = val;
}

void Series::__set_y(const Vector& val) {
  this->y = val;
}

void Series::__set_z(const Vector& val) {
  this->z = val;
__isset.z = true;
}

void Series::__set_color(const std::string& val) {
  this->color = val;
__isset.color = true;
}

void Series::__set_vertex(const std::string& val) {
  this->vertex = val;
__isset.vertex = true;
}

void Series::__set_style(const std::string& val) {
  this->style = val;
__isset.style = true;
}

void Series::__set_hidden(const bool val) {
  this->hidden = val;
__isset.hidden = true;
}

void Series::__set_maxPts(const int32_t val) {
  this->maxPts = val;
__isset.maxPts = true;
}
std::ostream& operator<<(std::ostream& out, const Series& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Series::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->x.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _etype111;
            xfer += iprot->readListBegin(_etype111, _size108);
            this->x.resize(_size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              xfer += iprot->readDouble(this->x[_i112]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->y.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readListBegin(_etype116, _size113);
            this->y.resize(_size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              xfer += iprot->readDouble(this->y[_i117]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->z.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->z.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readDouble(this->z[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->color);
          this->__isset.color = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vertex);
          this->__isset.vertex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->style);
          this->__isset.style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hidden);
          this->__isset.hidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxPts);
          this->__isset.maxPts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Series::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Series");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->x.size()));
    std::vector<double> ::const_iterator _iter123;
    for (_iter123 = this->x.begin(); _iter123 != this->x.end(); ++_iter123)
    {
      xfer += oprot->writeDouble((*_iter123));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->y.size()));
    std::vector<double> ::const_iterator _iter124;
    for (_iter124 = this->y.begin(); _iter124 != this->y.end(); ++_iter124)
    {
      xfer += oprot->writeDouble((*_iter124));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.z) {
    xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->z.size()));
      std::vector<double> ::const_iterator _iter125;
      for (_iter125 = this->z.begin(); _iter125 != this->z.end(); ++_iter125)
      {
        xfer += oprot->writeDouble((*_iter125));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.color) {
    xfer += oprot->writeFieldBegin("color", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->color);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vertex) {
    xfer += oprot->writeFieldBegin("vertex", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->vertex);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.style) {
    xfer += oprot->writeFieldBegin("style", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hidden) {
    xfer += oprot->writeFieldBegin("hidden", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->hidden);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxPts) {
    xfer += oprot->writeFieldBegin("maxPts", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->maxPts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Series &a, Series &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.color, b.color);
  swap(a.vertex, b.vertex);
  swap(a.style, b.style);
  swap(a.hidden, b.hidden);
  swap(a.maxPts, b.maxPts);
  swap(a.__isset, b.__isset);
}

Series::Series(const Series& other126) {
  x = other126.x;
  y = other126.y;
  z = other126.z;
  color = other126.color;
  vertex = other126.vertex;
  style = other126.style;
  hidden = other126.hidden;
  maxPts = other126.maxPts;
  __isset = other126.__isset;
}
Series& Series::operator=(const Series& other127) {
  x = other127.x;
  y = other127.y;
  z = other127.z;
  color = other127.color;
  vertex = other127.vertex;
  style = other127.style;
  hidden = other127.hidden;
  maxPts = other127.maxPts;
  __isset = other127.__isset;
  return *this;
}
void Series::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Series(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z="; (__isset.z ? (out << to_string(z)) : (out << "<null>"));
  out << ", " << "color="; (__isset.color ? (out << to_string(color)) : (out << "<null>"));
  out << ", " << "vertex="; (__isset.vertex ? (out << to_string(vertex)) : (out << "<null>"));
  out << ", " << "style="; (__isset.style ? (out << to_string(style)) : (out << "<null>"));
  out << ", " << "hidden="; (__isset.hidden ? (out << to_string(hidden)) : (out << "<null>"));
  out << ", " << "maxPts="; (__isset.maxPts ? (out << to_string(maxPts)) : (out << "<null>"));
  out << ")";
}


Category::~Category() noexcept {
}


void Category::__set_v(const double val) {
  this->v = val;
}

void Category::__set_color(const std::string& val) {
  this->color = val;
__isset.color = true;
}

void Category::__set_hidden(const bool val) {
  this->hidden = val;
__isset.hidden = true;
}
std::ostream& operator<<(std::ostream& out, const Category& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Category::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->color);
          this->__isset.color = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hidden);
          this->__isset.hidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Category::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Category");

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.color) {
    xfer += oprot->writeFieldBegin("color", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->color);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hidden) {
    xfer += oprot->writeFieldBegin("hidden", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->hidden);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Category &a, Category &b) {
  using ::std::swap;
  swap(a.v, b.v);
  swap(a.color, b.color);
  swap(a.hidden, b.hidden);
  swap(a.__isset, b.__isset);
}

Category::Category(const Category& other128) {
  v = other128.v;
  color = other128.color;
  hidden = other128.hidden;
  __isset = other128.__isset;
}
Category& Category::operator=(const Category& other129) {
  v = other129.v;
  color = other129.color;
  hidden = other129.hidden;
  __isset = other129.__isset;
  return *this;
}
void Category::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Category(";
  out << "v=" << to_string(v);
  out << ", " << "color="; (__isset.color ? (out << to_string(color)) : (out << "<null>"));
  out << ", " << "hidden="; (__isset.hidden ? (out << to_string(hidden)) : (out << "<null>"));
  out << ")";
}


DataPoint::~DataPoint() noexcept {
}


void DataPoint::__set_x(const double val) {
  this->x = val;
}

void DataPoint::__set_y(const double val) {
  this->y = val;
}

void DataPoint::__set_z(const double val) {
  this->z = val;
__isset.z = true;
}
std::ostream& operator<<(std::ostream& out, const DataPoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DataPoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataPoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataPoint");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.z) {
    xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->z);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataPoint &a, DataPoint &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

DataPoint::DataPoint(const DataPoint& other130) noexcept {
  x = other130.x;
  y = other130.y;
  z = other130.z;
  __isset = other130.__isset;
}
DataPoint& DataPoint::operator=(const DataPoint& other131) noexcept {
  x = other131.x;
  y = other131.y;
  z = other131.z;
  __isset = other131.__isset;
  return *this;
}
void DataPoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataPoint(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z="; (__isset.z ? (out << to_string(z)) : (out << "<null>"));
  out << ")";
}


Data::~Data() noexcept {
}


void Data::__set_sData(const Series& val) {
  this->sData = val;
__isset.sData = true;
}

void Data::__set_cData(const Category& val) {
  this->cData = val;
__isset.cData = true;
}
std::ostream& operator<<(std::ostream& out, const Data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sData.read(iprot);
          this->__isset.sData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cData.read(iprot);
          this->__isset.cData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Data");

  if (this->__isset.sData) {
    xfer += oprot->writeFieldBegin("sData", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cData) {
    xfer += oprot->writeFieldBegin("cData", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->cData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data &a, Data &b) {
  using ::std::swap;
  swap(a.sData, b.sData);
  swap(a.cData, b.cData);
  swap(a.__isset, b.__isset);
}

Data::Data(const Data& other132) {
  sData = other132.sData;
  cData = other132.cData;
  __isset = other132.__isset;
}
Data& Data::operator=(const Data& other133) {
  sData = other133.sData;
  cData = other133.cData;
  __isset = other133.__isset;
  return *this;
}
void Data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Data(";
  out << "sData="; (__isset.sData ? (out << to_string(sData)) : (out << "<null>"));
  out << ", " << "cData="; (__isset.cData ? (out << to_string(cData)) : (out << "<null>"));
  out << ")";
}


PendantEvent::~PendantEvent() noexcept {
}


void PendantEvent::__set_eventType(const PendantEventType::type val) {
  this->eventType = val;
}

void PendantEvent::__set_props(const std::map<std::string, Any> & val) {
  this->props = val;
__isset.props = true;
}
std::ostream& operator<<(std::ostream& out, const PendantEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PendantEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast134;
          xfer += iprot->readI32(ecast134);
          this->eventType = static_cast<PendantEventType::type>(ecast134);
          isset_eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->props.clear();
            uint32_t _size135;
            ::apache::thrift::protocol::TType _ktype136;
            ::apache::thrift::protocol::TType _vtype137;
            xfer += iprot->readMapBegin(_ktype136, _vtype137, _size135);
            uint32_t _i139;
            for (_i139 = 0; _i139 < _size135; ++_i139)
            {
              std::string _key140;
              xfer += iprot->readString(_key140);
              Any& _val141 = this->props[_key140];
              xfer += _val141.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.props = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PendantEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PendantEvent");

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->eventType));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.props) {
    xfer += oprot->writeFieldBegin("props", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->props.size()));
      std::map<std::string, Any> ::const_iterator _iter142;
      for (_iter142 = this->props.begin(); _iter142 != this->props.end(); ++_iter142)
      {
        xfer += oprot->writeString(_iter142->first);
        xfer += _iter142->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PendantEvent &a, PendantEvent &b) {
  using ::std::swap;
  swap(a.eventType, b.eventType);
  swap(a.props, b.props);
  swap(a.__isset, b.__isset);
}

PendantEvent::PendantEvent(const PendantEvent& other143) {
  eventType = other143.eventType;
  props = other143.props;
  __isset = other143.__isset;
}
PendantEvent& PendantEvent::operator=(const PendantEvent& other144) {
  eventType = other144.eventType;
  props = other144.props;
  __isset = other144.__isset;
  return *this;
}
void PendantEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PendantEvent(";
  out << "eventType=" << to_string(eventType);
  out << ", " << "props="; (__isset.props ? (out << to_string(props)) : (out << "<null>"));
  out << ")";
}


PropValues::~PropValues() noexcept {
}


void PropValues::__set_itemID(const std::string& val) {
  this->itemID = val;
}

void PropValues::__set_props(const std::map<std::string, Any> & val) {
  this->props = val;
}
std::ostream& operator<<(std::ostream& out, const PropValues& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PropValues::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_itemID = false;
  bool isset_props = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->itemID);
          isset_itemID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->props.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _ktype146;
            ::apache::thrift::protocol::TType _vtype147;
            xfer += iprot->readMapBegin(_ktype146, _vtype147, _size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              std::string _key150;
              xfer += iprot->readString(_key150);
              Any& _val151 = this->props[_key150];
              xfer += _val151.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_props = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_itemID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_props)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PropValues::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PropValues");

  xfer += oprot->writeFieldBegin("itemID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->itemID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("props", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->props.size()));
    std::map<std::string, Any> ::const_iterator _iter152;
    for (_iter152 = this->props.begin(); _iter152 != this->props.end(); ++_iter152)
    {
      xfer += oprot->writeString(_iter152->first);
      xfer += _iter152->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PropValues &a, PropValues &b) {
  using ::std::swap;
  swap(a.itemID, b.itemID);
  swap(a.props, b.props);
}

PropValues::PropValues(const PropValues& other153) {
  itemID = other153.itemID;
  props = other153.props;
}
PropValues& PropValues::operator=(const PropValues& other154) {
  itemID = other154.itemID;
  props = other154.props;
  return *this;
}
void PropValues::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PropValues(";
  out << "itemID=" << to_string(itemID);
  out << ", " << "props=" << to_string(props);
  out << ")";
}


ControllerEvent::~ControllerEvent() noexcept {
}


void ControllerEvent::__set_eventType(const ControllerEventType::type val) {
  this->eventType = val;
}

void ControllerEvent::__set_props(const std::map<std::string, Any> & val) {
  this->props = val;
__isset.props = true;
}
std::ostream& operator<<(std::ostream& out, const ControllerEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ControllerEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast155;
          xfer += iprot->readI32(ecast155);
          this->eventType = static_cast<ControllerEventType::type>(ecast155);
          isset_eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->props.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _ktype157;
            ::apache::thrift::protocol::TType _vtype158;
            xfer += iprot->readMapBegin(_ktype157, _vtype158, _size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              std::string _key161;
              xfer += iprot->readString(_key161);
              Any& _val162 = this->props[_key161];
              xfer += _val162.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.props = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ControllerEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ControllerEvent");

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->eventType));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.props) {
    xfer += oprot->writeFieldBegin("props", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->props.size()));
      std::map<std::string, Any> ::const_iterator _iter163;
      for (_iter163 = this->props.begin(); _iter163 != this->props.end(); ++_iter163)
      {
        xfer += oprot->writeString(_iter163->first);
        xfer += _iter163->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ControllerEvent &a, ControllerEvent &b) {
  using ::std::swap;
  swap(a.eventType, b.eventType);
  swap(a.props, b.props);
  swap(a.__isset, b.__isset);
}

ControllerEvent::ControllerEvent(const ControllerEvent& other164) {
  eventType = other164.eventType;
  props = other164.props;
  __isset = other164.__isset;
}
ControllerEvent& ControllerEvent::operator=(const ControllerEvent& other165) {
  eventType = other165.eventType;
  props = other165.props;
  __isset = other165.__isset;
  return *this;
}
void ControllerEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ControllerEvent(";
  out << "eventType=" << to_string(eventType);
  out << ", " << "props="; (__isset.props ? (out << to_string(props)) : (out << "<null>"));
  out << ")";
}


SimpleControlGroup::~SimpleControlGroup() noexcept {
}


void SimpleControlGroup::__set_type(const ControlGroupType::type val) {
  this->type = val;
}

void SimpleControlGroup::__set_index(const int8_t val) {
  this->index = val;
__isset.index = true;
}
std::ostream& operator<<(std::ostream& out, const SimpleControlGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SimpleControlGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast166;
          xfer += iprot->readI32(ecast166);
          this->type = static_cast<ControlGroupType::type>(ecast166);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimpleControlGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SimpleControlGroup");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.index) {
    xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_BYTE, 2);
    xfer += oprot->writeByte(this->index);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimpleControlGroup &a, SimpleControlGroup &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.index, b.index);
  swap(a.__isset, b.__isset);
}

SimpleControlGroup::SimpleControlGroup(const SimpleControlGroup& other167) noexcept {
  type = other167.type;
  index = other167.index;
  __isset = other167.__isset;
}
SimpleControlGroup& SimpleControlGroup::operator=(const SimpleControlGroup& other168) noexcept {
  type = other168.type;
  index = other168.index;
  __isset = other168.__isset;
  return *this;
}
void SimpleControlGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SimpleControlGroup(";
  out << "type=" << to_string(type);
  out << ", " << "index="; (__isset.index ? (out << to_string(index)) : (out << "<null>"));
  out << ")";
}


CombinedControlGroup::~CombinedControlGroup() noexcept {
}


void CombinedControlGroup::__set_groups(const std::vector<SimpleControlGroup> & val) {
  this->groups = val;
}

void CombinedControlGroup::__set_master(const SimpleControlGroup& val) {
  this->master = val;
__isset.master = true;
}
std::ostream& operator<<(std::ostream& out, const CombinedControlGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CombinedControlGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groups.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->groups.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += this->groups[_i173].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->master.read(iprot);
          this->__isset.master = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CombinedControlGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CombinedControlGroup");

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->groups.size()));
    std::vector<SimpleControlGroup> ::const_iterator _iter174;
    for (_iter174 = this->groups.begin(); _iter174 != this->groups.end(); ++_iter174)
    {
      xfer += (*_iter174).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.master) {
    xfer += oprot->writeFieldBegin("master", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->master.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CombinedControlGroup &a, CombinedControlGroup &b) {
  using ::std::swap;
  swap(a.groups, b.groups);
  swap(a.master, b.master);
  swap(a.__isset, b.__isset);
}

CombinedControlGroup::CombinedControlGroup(const CombinedControlGroup& other175) {
  groups = other175.groups;
  master = other175.master;
  __isset = other175.__isset;
}
CombinedControlGroup& CombinedControlGroup::operator=(const CombinedControlGroup& other176) {
  groups = other176.groups;
  master = other176.master;
  __isset = other176.__isset;
  return *this;
}
void CombinedControlGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CombinedControlGroup(";
  out << "groups=" << to_string(groups);
  out << ", " << "master="; (__isset.master ? (out << to_string(master)) : (out << "<null>"));
  out << ")";
}


ControlGroup::~ControlGroup() noexcept {
}


void ControlGroup::__set_type(const ControlGroupType::type val) {
  this->type = val;
}

void ControlGroup::__set_number(const int8_t val) {
  this->number = val;
}

void ControlGroup::__set_sgroup(const SimpleControlGroup& val) {
  this->sgroup = val;
__isset.sgroup = true;
}

void ControlGroup::__set_cgroup(const CombinedControlGroup& val) {
  this->cgroup = val;
__isset.cgroup = true;
}
std::ostream& operator<<(std::ostream& out, const ControlGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ControlGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast177;
          xfer += iprot->readI32(ecast177);
          this->type = static_cast<ControlGroupType::type>(ecast177);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sgroup.read(iprot);
          this->__isset.sgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cgroup.read(iprot);
          this->__isset.cgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ControlGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ControlGroup");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->number);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sgroup) {
    xfer += oprot->writeFieldBegin("sgroup", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->sgroup.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cgroup) {
    xfer += oprot->writeFieldBegin("cgroup", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->cgroup.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ControlGroup &a, ControlGroup &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.number, b.number);
  swap(a.sgroup, b.sgroup);
  swap(a.cgroup, b.cgroup);
  swap(a.__isset, b.__isset);
}

ControlGroup::ControlGroup(const ControlGroup& other178) {
  type = other178.type;
  number = other178.number;
  sgroup = other178.sgroup;
  cgroup = other178.cgroup;
  __isset = other178.__isset;
}
ControlGroup& ControlGroup::operator=(const ControlGroup& other179) {
  type = other179.type;
  number = other179.number;
  sgroup = other179.sgroup;
  cgroup = other179.cgroup;
  __isset = other179.__isset;
  return *this;
}
void ControlGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ControlGroup(";
  out << "type=" << to_string(type);
  out << ", " << "number=" << to_string(number);
  out << ", " << "sgroup="; (__isset.sgroup ? (out << to_string(sgroup)) : (out << "<null>"));
  out << ", " << "cgroup="; (__isset.cgroup ? (out << to_string(cgroup)) : (out << "<null>"));
  out << ")";
}


RobotJobInfo::~RobotJobInfo() noexcept {
}


void RobotJobInfo::__set_name(const std::string& val) {
  this->name = val;
}

void RobotJobInfo::__set_programmingLanguage(const std::string& val) {
  this->programmingLanguage = val;
}

void RobotJobInfo::__set_jobType(const std::string& val) {
  this->jobType = val;
}

void RobotJobInfo::__set_editable(const bool val) {
  this->editable = val;
}

void RobotJobInfo::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void RobotJobInfo::__set_datetime(const std::string& val) {
  this->datetime = val;
}

void RobotJobInfo::__set_comment(const std::string& val) {
  this->comment = val;
}

void RobotJobInfo::__set_frame(const CoordinateFrame& val) {
  this->frame = val;
}

void RobotJobInfo::__set_controlling(const ControlGroup& val) {
  this->controlling = val;
}
std::ostream& operator<<(std::ostream& out, const RobotJobInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RobotJobInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->programmingLanguage);
          this->__isset.programmingLanguage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobType);
          this->__isset.jobType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->editable);
          this->__isset.editable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datetime);
          this->__isset.datetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frame.read(iprot);
          this->__isset.frame = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->controlling.read(iprot);
          this->__isset.controlling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RobotJobInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RobotJobInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("programmingLanguage", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->programmingLanguage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jobType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->jobType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("editable", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->editable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("datetime", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->datetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("frame", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->frame.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("controlling", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->controlling.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RobotJobInfo &a, RobotJobInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.programmingLanguage, b.programmingLanguage);
  swap(a.jobType, b.jobType);
  swap(a.editable, b.editable);
  swap(a.timestamp, b.timestamp);
  swap(a.datetime, b.datetime);
  swap(a.comment, b.comment);
  swap(a.frame, b.frame);
  swap(a.controlling, b.controlling);
  swap(a.__isset, b.__isset);
}

RobotJobInfo::RobotJobInfo(const RobotJobInfo& other180) {
  name = other180.name;
  programmingLanguage = other180.programmingLanguage;
  jobType = other180.jobType;
  editable = other180.editable;
  timestamp = other180.timestamp;
  datetime = other180.datetime;
  comment = other180.comment;
  frame = other180.frame;
  controlling = other180.controlling;
  __isset = other180.__isset;
}
RobotJobInfo& RobotJobInfo::operator=(const RobotJobInfo& other181) {
  name = other181.name;
  programmingLanguage = other181.programmingLanguage;
  jobType = other181.jobType;
  editable = other181.editable;
  timestamp = other181.timestamp;
  datetime = other181.datetime;
  comment = other181.comment;
  frame = other181.frame;
  controlling = other181.controlling;
  __isset = other181.__isset;
  return *this;
}
void RobotJobInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RobotJobInfo(";
  out << "name=" << to_string(name);
  out << ", " << "programmingLanguage=" << to_string(programmingLanguage);
  out << ", " << "jobType=" << to_string(jobType);
  out << ", " << "editable=" << to_string(editable);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ", " << "datetime=" << to_string(datetime);
  out << ", " << "comment=" << to_string(comment);
  out << ", " << "frame=" << to_string(frame);
  out << ", " << "controlling=" << to_string(controlling);
  out << ")";
}


Tool::~Tool() noexcept {
}


void Tool::__set_index(const ToolIndex val) {
  this->index = val;
}

void Tool::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void Tool::__set_weight(const double val) {
  this->weight = val;
__isset.weight = true;
}

void Tool::__set_offset(const Vector& val) {
  this->offset = val;
__isset.offset = true;
}

void Tool::__set_orient(const Orient& val) {
  this->orient = val;
__isset.orient = true;
}

void Tool::__set_centerOfMass(const Vector& val) {
  this->centerOfMass = val;
__isset.centerOfMass = true;
}

void Tool::__set_momentOfInertia(const Vector& val) {
  this->momentOfInertia = val;
__isset.momentOfInertia = true;
}

void Tool::__set_blockIOName(const std::string& val) {
  this->blockIOName = val;
__isset.blockIOName = true;
}
std::ostream& operator<<(std::ostream& out, const Tool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Tool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _etype185;
            xfer += iprot->readListBegin(_etype185, _size182);
            this->offset.resize(_size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              xfer += iprot->readDouble(this->offset[_i186]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->orient.read(iprot);
          this->__isset.orient = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->centerOfMass.clear();
            uint32_t _size187;
            ::apache::thrift::protocol::TType _etype190;
            xfer += iprot->readListBegin(_etype190, _size187);
            this->centerOfMass.resize(_size187);
            uint32_t _i191;
            for (_i191 = 0; _i191 < _size187; ++_i191)
            {
              xfer += iprot->readDouble(this->centerOfMass[_i191]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.centerOfMass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->momentOfInertia.clear();
            uint32_t _size192;
            ::apache::thrift::protocol::TType _etype195;
            xfer += iprot->readListBegin(_etype195, _size192);
            this->momentOfInertia.resize(_size192);
            uint32_t _i196;
            for (_i196 = 0; _i196 < _size192; ++_i196)
            {
              xfer += iprot->readDouble(this->momentOfInertia[_i196]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.momentOfInertia = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->blockIOName);
          this->__isset.blockIOName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Tool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Tool");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.weight) {
    xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->weight);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->offset.size()));
      std::vector<double> ::const_iterator _iter197;
      for (_iter197 = this->offset.begin(); _iter197 != this->offset.end(); ++_iter197)
      {
        xfer += oprot->writeDouble((*_iter197));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orient) {
    xfer += oprot->writeFieldBegin("orient", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->orient.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.centerOfMass) {
    xfer += oprot->writeFieldBegin("centerOfMass", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->centerOfMass.size()));
      std::vector<double> ::const_iterator _iter198;
      for (_iter198 = this->centerOfMass.begin(); _iter198 != this->centerOfMass.end(); ++_iter198)
      {
        xfer += oprot->writeDouble((*_iter198));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.momentOfInertia) {
    xfer += oprot->writeFieldBegin("momentOfInertia", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->momentOfInertia.size()));
      std::vector<double> ::const_iterator _iter199;
      for (_iter199 = this->momentOfInertia.begin(); _iter199 != this->momentOfInertia.end(); ++_iter199)
      {
        xfer += oprot->writeDouble((*_iter199));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockIOName) {
    xfer += oprot->writeFieldBegin("blockIOName", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->blockIOName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Tool &a, Tool &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.name, b.name);
  swap(a.weight, b.weight);
  swap(a.offset, b.offset);
  swap(a.orient, b.orient);
  swap(a.centerOfMass, b.centerOfMass);
  swap(a.momentOfInertia, b.momentOfInertia);
  swap(a.blockIOName, b.blockIOName);
  swap(a.__isset, b.__isset);
}

Tool::Tool(const Tool& other200) {
  index = other200.index;
  name = other200.name;
  weight = other200.weight;
  offset = other200.offset;
  orient = other200.orient;
  centerOfMass = other200.centerOfMass;
  momentOfInertia = other200.momentOfInertia;
  blockIOName = other200.blockIOName;
  __isset = other200.__isset;
}
Tool& Tool::operator=(const Tool& other201) {
  index = other201.index;
  name = other201.name;
  weight = other201.weight;
  offset = other201.offset;
  orient = other201.orient;
  centerOfMass = other201.centerOfMass;
  momentOfInertia = other201.momentOfInertia;
  blockIOName = other201.blockIOName;
  __isset = other201.__isset;
  return *this;
}
void Tool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Tool(";
  out << "index=" << to_string(index);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "weight="; (__isset.weight ? (out << to_string(weight)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "orient="; (__isset.orient ? (out << to_string(orient)) : (out << "<null>"));
  out << ", " << "centerOfMass="; (__isset.centerOfMass ? (out << to_string(centerOfMass)) : (out << "<null>"));
  out << ", " << "momentOfInertia="; (__isset.momentOfInertia ? (out << to_string(momentOfInertia)) : (out << "<null>"));
  out << ", " << "blockIOName="; (__isset.blockIOName ? (out << to_string(blockIOName)) : (out << "<null>"));
  out << ")";
}


VariableAddress::~VariableAddress() noexcept {
}


void VariableAddress::__set_scope(const Scope::type val) {
  this->scope = val;
}

void VariableAddress::__set_aspace(const AddressSpace::type val) {
  this->aspace = val;
}

void VariableAddress::__set_address(const int64_t val) {
  this->address = val;
}
std::ostream& operator<<(std::ostream& out, const VariableAddress& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VariableAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast202;
          xfer += iprot->readI32(ecast202);
          this->scope = static_cast<Scope::type>(ecast202);
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast203;
          xfer += iprot->readI32(ecast203);
          this->aspace = static_cast<AddressSpace::type>(ecast203);
          this->__isset.aspace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->address);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VariableAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VariableAddress");

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->scope));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aspace", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->aspace));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VariableAddress &a, VariableAddress &b) {
  using ::std::swap;
  swap(a.scope, b.scope);
  swap(a.aspace, b.aspace);
  swap(a.address, b.address);
  swap(a.__isset, b.__isset);
}

VariableAddress::VariableAddress(const VariableAddress& other204) noexcept {
  scope = other204.scope;
  aspace = other204.aspace;
  address = other204.address;
  __isset = other204.__isset;
}
VariableAddress& VariableAddress::operator=(const VariableAddress& other205) noexcept {
  scope = other205.scope;
  aspace = other205.aspace;
  address = other205.address;
  __isset = other205.__isset;
  return *this;
}
void VariableAddress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VariableAddress(";
  out << "scope=" << to_string(scope);
  out << ", " << "aspace=" << to_string(aspace);
  out << ", " << "address=" << to_string(address);
  out << ")";
}


Zone::~Zone() noexcept {
}


void Zone::__set_number(const int16_t val) {
  this->number = val;
}

void Zone::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void Zone::__set_enabled(const bool val) {
  this->enabled = val;
__isset.enabled = true;
}

void Zone::__set_action(const ZoneAction::type val) {
  this->action = val;
__isset.action = true;
}

void Zone::__set_minPos(const Position& val) {
  this->minPos = val;
__isset.minPos = true;
}

void Zone::__set_maxPos(const Position& val) {
  this->maxPos = val;
__isset.maxPos = true;
}
std::ostream& operator<<(std::ostream& out, const Zone& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Zone::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast206;
          xfer += iprot->readI32(ecast206);
          this->action = static_cast<ZoneAction::type>(ecast206);
          this->__isset.action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->minPos.read(iprot);
          this->__isset.minPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->maxPos.read(iprot);
          this->__isset.maxPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Zone::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Zone");

  xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->number);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enabled) {
    xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.action) {
    xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->action));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minPos) {
    xfer += oprot->writeFieldBegin("minPos", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->minPos.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxPos) {
    xfer += oprot->writeFieldBegin("maxPos", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->maxPos.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Zone &a, Zone &b) {
  using ::std::swap;
  swap(a.number, b.number);
  swap(a.name, b.name);
  swap(a.enabled, b.enabled);
  swap(a.action, b.action);
  swap(a.minPos, b.minPos);
  swap(a.maxPos, b.maxPos);
  swap(a.__isset, b.__isset);
}

Zone::Zone(const Zone& other207) {
  number = other207.number;
  name = other207.name;
  enabled = other207.enabled;
  action = other207.action;
  minPos = other207.minPos;
  maxPos = other207.maxPos;
  __isset = other207.__isset;
}
Zone& Zone::operator=(const Zone& other208) {
  number = other208.number;
  name = other208.name;
  enabled = other208.enabled;
  action = other208.action;
  minPos = other208.minPos;
  maxPos = other208.maxPos;
  __isset = other208.__isset;
  return *this;
}
void Zone::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Zone(";
  out << "number=" << to_string(number);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "enabled="; (__isset.enabled ? (out << to_string(enabled)) : (out << "<null>"));
  out << ", " << "action="; (__isset.action ? (out << to_string(action)) : (out << "<null>"));
  out << ", " << "minPos="; (__isset.minPos ? (out << to_string(minPos)) : (out << "<null>"));
  out << ", " << "maxPos="; (__isset.maxPos ? (out << to_string(maxPos)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
