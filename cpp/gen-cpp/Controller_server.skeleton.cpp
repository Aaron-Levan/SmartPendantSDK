// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Controller.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::yaskawa::ext::api;

class ControllerHandler : virtual public ControllerIf {
 public:
  ControllerHandler() {
    // Your initialization goes here
  }

  /**
   * Request specified permissions.
   * 
   * @param c
   * @param permissions
   */
  bool requestPermissions(const ControllerID c, const std::set<std::string> & permissions) {
    // Your implementation goes here
    printf("requestPermissions\n");
  }

  /**
   * Check permisions obtained.
   * 
   * @param c
   * @param permission
   */
  bool havePermission(const ControllerID c, const std::string& permission) {
    // Your implementation goes here
    printf("havePermission\n");
  }

  /**
   * Relinquish permissions (no effect if not held).
   * 
   * @param c
   * @param permissions
   */
  void relinquishPermissions(const ControllerID c, const std::set<std::string> & permissions) {
    // Your implementation goes here
    printf("relinquishPermissions\n");
  }

  /**
   * Connect to the specified Robot Controller (by IP adress or hostname if DNS available)
   * Typically, the pendant will already be connected to a controller when extensions are started,
   * so calling connect() is not required.
   * 
   * @param c
   * @param hostName
   */
  void connect(const ControllerID c, const std::string& hostName) {
    // Your implementation goes here
    printf("connect\n");
  }

  /**
   * Disconnect from the connected controller.  This leaves the pendant in the 'disconnected' state.
   * When disconnected, many functions are unavailable or will return default values.
   * 
   * @param c
   */
  void disconnect(const ControllerID c) {
    // Your implementation goes here
    printf("disconnect\n");
  }

  /**
   * Subscribe to the specified events, if not already.
   * Note: If using a Yaskawa supplied client library with event consumer callback support,
   *       registering an event consumer callback will automatically subscribe to the appropriate event.
   * 
   * @param c
   * @param types
   */
  void subscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) {
    // Your implementation goes here
    printf("subscribeEventTypes\n");
  }

  /**
   * Unsubscribe from the specified events.
   * If called directly, this may causes event consumers for the events not to be called.
   * 
   * @param c
   * @param types
   */
  void unsubscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) {
    // Your implementation goes here
    printf("unsubscribeEventTypes\n");
  }

  /**
   * Poll the API Service for pending events.
   * Note: If using a Yaskawa supplied client library, this does not need to be called explicitly.
   * 
   * @param c
   */
  void events(std::vector<ControllerEvent> & _return, const ControllerID c) {
    // Your implementation goes here
    printf("events\n");
  }

  /**
   * Returns true if the pendant is connected to a robot controller
   * 
   * @param c
   */
  bool connected(const ControllerID c) {
    // Your implementation goes here
    printf("connected\n");
  }

  /**
   * Returns the hostname or IP address of the robot controller to which the pendant is connected, if any
   * 
   * @param c
   */
  void connectedHostName(std::string& _return, const ControllerID c) {
    // Your implementation goes here
    printf("connectedHostName\n");
  }

  /**
   * The software version string of the robot controller system software.
   * 
   * @param c
   */
  void softwareVersion(std::string& _return, const ControllerID c) {
    // Your implementation goes here
    printf("softwareVersion\n");
  }

  /**
   * Returns true if the pendant is only monitoring the robot controller to which it is connected.  This
   * implies that no functions that modify the controller and/or robot state will succeed.
   * 
   * @param c
   */
  bool monitoring(const ControllerID c) {
    // Your implementation goes here
    printf("monitoring\n");
  }

  /**
   * Returns true if this pendant is the single-point-of-control for the connected Robot Controller.
   * If not, most functions that modify the controller and/or robot state will fail.
   * 
   * @param c
   */
  bool haveExclusiveControl(const ControllerID c) {
    // Your implementation goes here
    printf("haveExclusiveControl\n");
  }

  /**
   * Current operation mode of the controller
   * Automatic (aka Play) - running jobs
   * Manual (aka Teach) - for editing jobs, teaching points, jogging, setup etc.
   * 
   * @param c
   */
  OperationMode::type operationMode(const ControllerID c) {
    // Your implementation goes here
    printf("operationMode\n");
  }

  /**
   * Are the servo drives engaged?
   * On - yes, robot(s) are being actively controlled
   * Off - no.  Typically brakes are engaged (unless brake-release engaged)
   * Ready - ready to engage servos.  Typically requires operator to use servo enable switch.
   * 
   * @param c
   */
  ServoState::type servoState(const ControllerID c) {
    // Your implementation goes here
    printf("servoState\n");
  }

  /**
   * Indicates if a job us running or stopped.
   * Run - jobs are running (robot may be moving)
   * Held - jobs were running but have been held/paused.
   * Idle - no jobs are running
   * 
   * @param c
   */
  PlaybackState::type playbackState(const ControllerID c) {
    // Your implementation goes here
    printf("playbackState\n");
  }

  /**
   * Run the current robot job from the current line.  Requires Servos engaged & Automatic/Play operation and 'jobcontrol' permission.
   * 
   * @param c
   */
  void run(const ControllerID c) {
    // Your implementation goes here
    printf("run\n");
  }

  /**
   * Pause running job (servoes will remain engaged. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void pause(const ControllerID c) {
    // Your implementation goes here
    printf("pause\n");
  }

  /**
   * Resume running job from paused state. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void resume(const ControllerID c) {
    // Your implementation goes here
    printf("resume\n");
  }

  /**
   * Stop runnng job (will stop motion and disengage servos). 'jobcontrol' permission required.
   * 
   * @param c
   */
  void stop(const ControllerID c) {
    // Your implementation goes here
    printf("stop\n");
  }

  /**
   * Name of the current job (e.g. job being run or edited)
   * Empty if none.
   * 
   * @param c
   */
  void currentJob(std::string& _return, const ControllerID c) {
    // Your implementation goes here
    printf("currentJob\n");
  }

  /**
   * Set the current job. 'jobcontrol' permission required. Pass line=1 for start of job, line=0 for default/no-change.
   * 
   * @param c
   * @param name
   * @param line
   */
  void setCurrentJob(const ControllerID c, const std::string& name, const int32_t line) {
    // Your implementation goes here
    printf("setCurrentJob\n");
  }

  /**
   * Name of the default (aka master) job.  Empty if no default job designated
   * 
   * @param c
   */
  void defaultJob(std::string& _return, const ControllerID c) {
    // Your implementation goes here
    printf("defaultJob\n");
  }

  /**
   * query if job with specified name exists
   * 
   * @param c
   * @param name
   */
  bool jobExists(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("jobExists\n");
  }

  /**
   * Details for the named job (throws if non-existent job)
   * 
   * @param c
   * @param name
   */
  void jobDetails(RobotJobInfo& _return, const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("jobDetails\n");
  }

  /**
   * List of robot job names (empty if not connected)
   * 
   * @param c
   */
  void jobs(std::vector<std::string> & _return, const ControllerID c) {
    // Your implementation goes here
    printf("jobs\n");
  }

  /**
   * List of robot job names matching the name regular expression AND with the given tag
   * (empty if not connected or no matches)
   * 
   * @param c
   * @param nameRegex
   * @param tag
   */
  void jobsMatching(std::vector<std::string> & _return, const ControllerID c, const std::string& nameRegex, const std::string& tag) {
    // Your implementation goes here
    printf("jobsMatching\n");
  }

  /**
   * Duplicate an existing job with a new name for the copy
   * 
   * @param c
   * @param existingName
   * @param newName
   */
  void duplicateJob(const ControllerID c, const std::string& existingName, const std::string& newName) {
    // Your implementation goes here
    printf("duplicateJob\n");
  }

  /**
   * delete the specified job.  The default job cannot be deleted.
   * 
   * @param c
   * @param name
   */
  void deleteJob(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("deleteJob\n");
  }

  /**
   * Read source code for named job (in the programmingLanguage listed in jobDetails() )
   * 
   * @param c
   * @param name
   */
  void jobSource(std::string& _return, const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("jobSource\n");
  }

  /**
   * Replace named job with the source code provided, in given programmingLanguage (e.g. "INFORM").
   * Will thow if syntax errors in source.
   * 
   * @param c
   * @param name
   * @param programmingLanguage
   * @param sourceCode
   */
  void storeJobSource(const ControllerID c, const std::string& name, const std::string& programmingLanguage, const std::string& sourceCode) {
    // Your implementation goes here
    printf("storeJobSource\n");
  }

  /**
   * List of tools mapping index -> name.
   * Unset/defaulted tools are omitted (e.g. those with no name, 0 weight etc.)
   * Indices (map keys) may not be sequential.  Returned map may be empty.
   * 
   * @param c
   */
  void tools(std::map<ToolIndex, std::string> & _return, const ControllerID c) {
    // Your implementation goes here
    printf("tools\n");
  }

  /**
   * Query information on a specific tool, by index
   * 
   * @param c
   * @param index
   */
  void tool(Tool& _return, const ControllerID c, const ToolIndex index) {
    // Your implementation goes here
    printf("tool\n");
  }

  /**
   * Return input number of given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputNumber(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("inputNumber\n");
  }

  /**
   * Return input group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputGroupNumber(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("inputGroupNumber\n");
  }

  /**
   * Return output nunber of given output name
   * 
   * @param c
   * @param name
   */
  int32_t outputNumber(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("outputNumber\n");
  }

  /**
   * Return output group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t outputGroupNumber(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("outputGroupNumber\n");
  }

  /**
   * Return name of specified input number
   * 
   * @param c
   * @param num
   */
  void inputName(std::string& _return, const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("inputName\n");
  }

  /**
   * Return name of specified output number
   * 
   * @param c
   * @param num
   */
  void outputName(std::string& _return, const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("outputName\n");
  }

  /**
   * Set name of specified input (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setInputName(const ControllerID c, const int32_t num, const std::string& name) {
    // Your implementation goes here
    printf("setInputName\n");
  }

  /**
   * Set name of specified output (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setOutputName(const ControllerID c, const int32_t num, const std::string& name) {
    // Your implementation goes here
    printf("setOutputName\n");
  }

  /**
   * Start monitoring specified input
   * 
   * @param c
   * @param num
   */
  void monitorInput(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("monitorInput\n");
  }

  /**
   * Start monitoring all inputs in given input group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) {
    // Your implementation goes here
    printf("monitorInputGroups\n");
  }

  /**
   * Start monitoring specified output
   * 
   * @param c
   * @param num
   */
  void monitorOutput(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("monitorOutput\n");
  }

  /**
   * Start monitoring all outputs in given output group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) {
    // Your implementation goes here
    printf("monitorOutputGroups\n");
  }

  /**
   * Stop monitoring specified input
   * 
   * @param c
   * @param num
   */
  void unmonitorInput(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("unmonitorInput\n");
  }

  /**
   * Stop monitoring all inputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) {
    // Your implementation goes here
    printf("unmonitorInputGroups\n");
  }

  /**
   * Stop monitoring specified output
   * 
   * @param c
   * @param num
   */
  void unmonitorOutput(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("unmonitorOutput\n");
  }

  /**
   * Stop monitoring all outputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) {
    // Your implementation goes here
    printf("unmonitorOutputGroups\n");
  }

  /**
   * Return value of given input
   * 
   * @param c
   * @param num
   */
  bool inputValue(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("inputValue\n");
  }

  /**
   * Return values of input groups from specified group number (upto 4 contiguous groups/bytes, from least significant byte)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t inputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) {
    // Your implementation goes here
    printf("inputGroupsValue\n");
  }

  /**
   * Return the value of given output
   * 
   * @param c
   * @param num
   */
  bool outputValue(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("outputValue\n");
  }

  /**
   * Return values of output groups from specified group number (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t outputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) {
    // Your implementation goes here
    printf("outputGroupsValue\n");
  }

  /**
   * Set the value of the specified output number
   * 
   * @param c
   * @param num
   * @param value
   */
  void setOutput(const ControllerID c, const int32_t num, const bool value) {
    // Your implementation goes here
    printf("setOutput\n");
  }

  /**
   * Set the values of the outputs in the specified contigous output groups (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   * @param value
   */
  void setOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count, const int32_t value) {
    // Your implementation goes here
    printf("setOutputGroups\n");
  }

  /**
   * Return the logical IO address of the named input
   * 
   * @param c
   * @param name
   */
  int32_t inputAddress(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("inputAddress\n");
  }

  /**
   * Return the logical IO address of the given input number
   * 
   * @param c
   * @param num
   */
  int32_t inputAddressByNumber(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("inputAddressByNumber\n");
  }

  /**
   * Return the logical IO address of the named output
   * 
   * @param c
   * @param name
   */
  int32_t outputAddress(const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("outputAddress\n");
  }

  /**
   * Return the logical IO address of the given output number
   * 
   * @param c
   * @param num
   */
  int32_t outputAddressByNumber(const ControllerID c, const int32_t num) {
    // Your implementation goes here
    printf("outputAddressByNumber\n");
  }

  /**
   * Start monitoring a logical IO address.  Will generate IOValueChanged events
   * 
   * @param c
   * @param address
   */
  void monitorIOAddress(const ControllerID c, const int32_t address) {
    // Your implementation goes here
    printf("monitorIOAddress\n");
  }

  /**
   * Stop monitoring a logical IO address. (events for address may still be generated if it corresponds to a monitored input or output)
   * 
   * @param c
   * @param address
   */
  void unmonitorIOAddress(const ControllerID c, const int32_t address) {
    // Your implementation goes here
    printf("unmonitorIOAddress\n");
  }

  /**
   * Return the value of the given input by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool inputAddressValue(const ControllerID c, const int32_t address) {
    // Your implementation goes here
    printf("inputAddressValue\n");
  }

  /**
   * Return the value of the given output by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool outputAddressValue(const ControllerID c, const int32_t address) {
    // Your implementation goes here
    printf("outputAddressValue\n");
  }

  /**
   * Set the value of the given output by logical IO address
   * 
   * @param c
   * @param address
   * @param value
   */
  void setOutputAddress(const ControllerID c, const int32_t address, const bool value) {
    // Your implementation goes here
    printf("setOutputAddress\n");
  }

  /**
   * Obtain input group number (byte) of field bus status input.  e.g. busType 'ethip' yields EtherNet/IP status byte group
   * 
   * @param c
   * @param busType
   */
  int32_t fieldBusStatusInputGroup(const ControllerID c, const std::string& busType) {
    // Your implementation goes here
    printf("fieldBusStatusInputGroup\n");
  }

  /**
   * Return the list of control groups configured on the controller.
   * If only one robot is connected to the controller, this will return a single element,
   * containing the simple control group representing the robot.
   * 
   * @param c
   */
  void controlGroups(std::vector<ControlGroup> & _return, const ControllerID c) {
    // Your implementation goes here
    printf("controlGroups\n");
  }

  /**
   * Returns the index of the currently active control group.
   * 
   * @param c
   */
  int8_t currentControlGroup(const ControllerID c) {
    // Your implementation goes here
    printf("currentControlGroup\n");
  }

  /**
   * Returns the number of robots connected to the controller
   * 
   * @param c
   */
  int8_t robotCount(const ControllerID c) {
    // Your implementation goes here
    printf("robotCount\n");
  }

  /**
   * Returns the index of the currently active robot.
   * Note: index is 0-based, but in the UI the first robot is Robot 1.
   * 
   * @param c
   */
  RobotIndex currentRobot(const ControllerID c) {
    // Your implementation goes here
    printf("currentRobot\n");
  }

  /**
   * Variable value by name
   * 
   * @param c
   * @param name
   */
  void variable(Any& _return, const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("variable\n");
  }

  /**
   * Variable value by address
   * 
   * @param c
   * @param addr
   */
  void variableByAddr(Any& _return, const ControllerID c, const VariableAddress& addr) {
    // Your implementation goes here
    printf("variableByAddr\n");
  }

  /**
   * Set variable value by name
   * 
   * @param c
   * @param name
   * @param value
   */
  void setVariable(const ControllerID c, const std::string& name, const Any& value) {
    // Your implementation goes here
    printf("setVariable\n");
  }

  /**
   * Set variable by address
   * 
   * @param c
   * @param addr
   * @param value
   */
  void setVariableByAddr(const ControllerID c, const VariableAddress& addr, const Any& value) {
    // Your implementation goes here
    printf("setVariableByAddr\n");
  }

  /**
   * Lookup variable address by name and space
   * 
   * @param c
   * @param name
   * @param space
   */
  void variableAddrByNameAndSpace(VariableAddress& _return, const ControllerID c, const std::string& name, const AddressSpace::type space) {
    // Your implementation goes here
    printf("variableAddrByNameAndSpace\n");
  }

  /**
   * Lookup variable address by name (less efficient)
   * 
   * @param c
   * @param name
   */
  void variableAddrByName(VariableAddress& _return, const ControllerID c, const std::string& name) {
    // Your implementation goes here
    printf("variableAddrByName\n");
  }

  /**
   * Set name of variable by address
   * 
   * @param c
   * @param addr
   * @param name
   */
  void setVariableName(const ControllerID c, const VariableAddress& addr, const std::string& name) {
    // Your implementation goes here
    printf("setVariableName\n");
  }

  /**
   * Query information on specified zone, by index (not number)
   * 
   * @param c
   * @param index
   */
  void zone(Zone& _return, const ControllerID c, const ZoneIndex index) {
    // Your implementation goes here
    printf("zone\n");
  }

  /**
   * Creates a new Zone and returns its index.  It will have default values
   * which can be change via modifyZone()
   * 
   * @param c
   */
  ZoneIndex newZone(const ControllerID c) {
    // Your implementation goes here
    printf("newZone\n");
  }

  /**
   * Modify Zone information.  Only fields set in Zone will be updated.
   * 
   * @param c
   * @param index
   * @param z
   */
  void modifyZone(const ControllerID c, const ZoneIndex index, const Zone& z) {
    // Your implementation goes here
    printf("modifyZone\n");
  }

  /**
   * Delete a Zone
   * 
   * @param c
   * @param index
   */
  void deleteZone(const ControllerID c, const ZoneIndex index) {
    // Your implementation goes here
    printf("deleteZone\n");
  }

  /**
   * List of user frames mapping index -> name.
   * NB: Indices (map keys) may not be sequential. Returned map may be empty.
   * 
   * @param c
   */
  void userFrames(std::map<UserFrameIndex, std::string> & _return, const ControllerID c) {
    // Your implementation goes here
    printf("userFrames\n");
  }

  /**
   * Query information on specified User Frame, by index (not number)
   * 
   * @param c
   * @param index
   */
  void userFrame(CoordinateFrame& _return, const ControllerID c, const UserFrameIndex index) {
    // Your implementation goes here
    printf("userFrame\n");
  }

  /**
   * Creates a new User Frame with default values and returns its index.
   * 
   * @param c
   */
  UserFrameIndex newUserFrame(const ControllerID c) {
    // Your implementation goes here
    printf("newUserFrame\n");
  }

  /**
   * Set the specified User Frame to the provided values
   * 
   * @param c
   * @param index
   * @param f
   */
  void setUserFrame(const ControllerID c, const UserFrameIndex index, const CoordinateFrame& f) {
    // Your implementation goes here
    printf("setUserFrame\n");
  }

  /**
   * Delete a User Frame
   * 
   * @param c
   * @param index
   */
  void deleteUserFrame(const ControllerID c, const UserFrameIndex index) {
    // Your implementation goes here
    printf("deleteUserFrame\n");
  }

  /**
   * Query current controller network interface IP address.
   * controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3']
   * (NB: On YRC1000micro, 'LAN' is the external Ethernet port, corresponding to 'LAN2' on the YRC1000)
   * 
   * @param c
   * @param controllerInterface
   */
  void networkInterfaceAddress(std::string& _return, const ControllerID c, const std::string& controllerInterface) {
    // Your implementation goes here
    printf("networkInterfaceAddress\n");
  }

  /**
   * Request external network access via specified protocol and port originating
   * from the given controller interface. The controllerInferface may be left blank, in which case
   * connections will be routed from the controller according to the destination address and
   * current subnetwork of the external LAN ports).
   * Access only persists while power is maintained to the controller.
   * The protocol must be either 'tcp' or 'udp'. controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3'].
   * Returns a handle that can subsequently used to remove the access, or -1 if the access request
   * failed (may happen in case of network conflicts with other extensions).
   * Requires 'networking' permision.
   * 
   * @param c
   * @param controllerInterface
   * @param port
   * @param protocol
   */
  int32_t requestNetworkAccess(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) {
    // Your implementation goes here
    printf("requestNetworkAccess\n");
  }

  void removeNetworkAccess(const ControllerID c, const int32_t accessHandle) {
    // Your implementation goes here
    printf("removeNetworkAccess\n");
  }

  int32_t requestNetworkService(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) {
    // Your implementation goes here
    printf("requestNetworkService\n");
  }

  void removeNetworkService(const ControllerID c, const int32_t accessHandle) {
    // Your implementation goes here
    printf("removeNetworkService\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::std::shared_ptr<ControllerHandler> handler(new ControllerHandler());
  ::std::shared_ptr<TProcessor> processor(new ControllerProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

