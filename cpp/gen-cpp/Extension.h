/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Extension_H
#define Extension_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "extension_types.h"

namespace yaskawa { namespace ext { namespace api {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

/**
 * The Extension API.
 * 
 * Use this interface to initially register the extension with the main pendant
 * API Service and obtain handle IDs to the Controller and Pendant services.
 * 
 * Note in this function-level documentation, functions of the Controller Service
 * take an initial ControllerID parameter, Pendant Service functions take an initial PendantID etc.
 * However, if you are using a Yaskawa supplied client library these may be wrapped as
 * object methods and hence the initial id should be omitted.
 */
class ExtensionIf {
 public:
  virtual ~ExtensionIf() {}

  /**
   * Version of API the service implements.
   * Smart Pendant | API version
   * 2.0           | 2.0.4
   * 2.1           | 2.1.0
   */
  virtual void apiVersion(Version& _return) = 0;

  /**
   * Register extension with Smart Pendant API service.
   * Extension must exist in the extension database (i.e. through installation)
   * 
   * @param canonicalName
   * @param launchKey
   * @param version
   * @param vendor
   * @param supportedLanguages
   */
  virtual ExtensionID registerExtension(const std::string& canonicalName, const std::string& launchKey, const Version& version, const std::string& vendor, const std::set<std::string> & supportedLanguages) = 0;
  virtual void unregisterExtension(const ExtensionID id) = 0;

  /**
   * Indicate liveliness
   * API service will automatically unregister extensions that are unresponsive for some period.
   * If extension is not regularly calling events(), call ping() to indicate the extension is operational.
   * 
   * @param id
   */
  virtual void ping(const ExtensionID id) = 0;

  /**
   * Obtain ID handle for Robot Conroller API
   * 
   * @param id
   */
  virtual ControllerID controller(const ExtensionID id) = 0;

  /**
   * Obtain ID handle for Pendant UI API
   * 
   * @param id
   */
  virtual PendantID pendant(const ExtensionID id) = 0;

  /**
   * Log message to standard pendant logging facility
   * Visible to end-users upon plain-text log file export.
   * Note that Debug level logging is ignored unless in Developer access level.
   * 
   * @param id
   * @param level
   * @param message
   */
  virtual void log(const ExtensionID id, const LoggingLevel::type level, const std::string& message) = 0;

  /**
   * Subscribe to receive log message events via events()
   * 
   * @param id
   */
  virtual void subscribeLoggingEvents(const ExtensionID id) = 0;
  virtual void unsubscribeLoggingEvents(const ExtensionID id) = 0;

  /**
   * Obtain list of logging events that have occured since last call
   * NB: For development troubleshooting only, logging events
   * only available when development access enabled
   * 
   * @param id
   */
  virtual void logEvents(std::vector<LoggingEvent> & _return, const ExtensionID id) = 0;
  virtual void publicKey(std::string& _return, const ExtensionID id) = 0;
  virtual void oneTimeAuthToken(std::string& _return, const ExtensionID id, const std::string& oneTimeSalt, const std::string& publicKey) = 0;
  virtual void installPackage(std::vector<std::string> & _return, const ExtensionID id, const std::string& authToken, const std::string& packageData, const std::string& overridePasscodeEnc) = 0;
};

class ExtensionIfFactory {
 public:
  typedef ExtensionIf Handler;

  virtual ~ExtensionIfFactory() {}

  virtual ExtensionIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ExtensionIf* /* handler */) = 0;
  };

class ExtensionIfSingletonFactory : virtual public ExtensionIfFactory {
 public:
  ExtensionIfSingletonFactory(const ::std::shared_ptr<ExtensionIf>& iface) : iface_(iface) {}
  virtual ~ExtensionIfSingletonFactory() {}

  virtual ExtensionIf* getHandler(const ::apache::thrift::TConnectionInfo&) override {
    return iface_.get();
  }
  virtual void releaseHandler(ExtensionIf* /* handler */) override {}

 protected:
  ::std::shared_ptr<ExtensionIf> iface_;
};

class ExtensionNull : virtual public ExtensionIf {
 public:
  virtual ~ExtensionNull() {}
  void apiVersion(Version& /* _return */) override {
    return;
  }
  ExtensionID registerExtension(const std::string& /* canonicalName */, const std::string& /* launchKey */, const Version& /* version */, const std::string& /* vendor */, const std::set<std::string> & /* supportedLanguages */) override {
    ExtensionID _return = 0;
    return _return;
  }
  void unregisterExtension(const ExtensionID /* id */) override {
    return;
  }
  void ping(const ExtensionID /* id */) override {
    return;
  }
  ControllerID controller(const ExtensionID /* id */) override {
    ControllerID _return = 0;
    return _return;
  }
  PendantID pendant(const ExtensionID /* id */) override {
    PendantID _return = 0;
    return _return;
  }
  void log(const ExtensionID /* id */, const LoggingLevel::type /* level */, const std::string& /* message */) override {
    return;
  }
  void subscribeLoggingEvents(const ExtensionID /* id */) override {
    return;
  }
  void unsubscribeLoggingEvents(const ExtensionID /* id */) override {
    return;
  }
  void logEvents(std::vector<LoggingEvent> & /* _return */, const ExtensionID /* id */) override {
    return;
  }
  void publicKey(std::string& /* _return */, const ExtensionID /* id */) override {
    return;
  }
  void oneTimeAuthToken(std::string& /* _return */, const ExtensionID /* id */, const std::string& /* oneTimeSalt */, const std::string& /* publicKey */) override {
    return;
  }
  void installPackage(std::vector<std::string> & /* _return */, const ExtensionID /* id */, const std::string& /* authToken */, const std::string& /* packageData */, const std::string& /* overridePasscodeEnc */) override {
    return;
  }
};


class Extension_apiVersion_args {
 public:

  Extension_apiVersion_args(const Extension_apiVersion_args&) noexcept;
  Extension_apiVersion_args& operator=(const Extension_apiVersion_args&) noexcept;
  Extension_apiVersion_args() noexcept {
  }

  virtual ~Extension_apiVersion_args() noexcept;

  bool operator == (const Extension_apiVersion_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Extension_apiVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_apiVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_apiVersion_pargs {
 public:


  virtual ~Extension_apiVersion_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_apiVersion_result__isset {
  _Extension_apiVersion_result__isset() : success(false) {}
  bool success :1;
} _Extension_apiVersion_result__isset;

class Extension_apiVersion_result {
 public:

  Extension_apiVersion_result(const Extension_apiVersion_result&);
  Extension_apiVersion_result& operator=(const Extension_apiVersion_result&);
  Extension_apiVersion_result() noexcept {
  }

  virtual ~Extension_apiVersion_result() noexcept;
  Version success;

  _Extension_apiVersion_result__isset __isset;

  void __set_success(const Version& val);

  bool operator == (const Extension_apiVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Extension_apiVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_apiVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_apiVersion_presult__isset {
  _Extension_apiVersion_presult__isset() : success(false) {}
  bool success :1;
} _Extension_apiVersion_presult__isset;

class Extension_apiVersion_presult {
 public:


  virtual ~Extension_apiVersion_presult() noexcept;
  Version* success;

  _Extension_apiVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_registerExtension_args__isset {
  _Extension_registerExtension_args__isset() : canonicalName(false), launchKey(false), version(false), vendor(false), supportedLanguages(false) {}
  bool canonicalName :1;
  bool launchKey :1;
  bool version :1;
  bool vendor :1;
  bool supportedLanguages :1;
} _Extension_registerExtension_args__isset;

class Extension_registerExtension_args {
 public:

  Extension_registerExtension_args(const Extension_registerExtension_args&);
  Extension_registerExtension_args& operator=(const Extension_registerExtension_args&);
  Extension_registerExtension_args() noexcept
                                   : canonicalName(),
                                     launchKey(),
                                     vendor() {
  }

  virtual ~Extension_registerExtension_args() noexcept;
  std::string canonicalName;
  std::string launchKey;
  Version version;
  std::string vendor;
  std::set<std::string>  supportedLanguages;

  _Extension_registerExtension_args__isset __isset;

  void __set_canonicalName(const std::string& val);

  void __set_launchKey(const std::string& val);

  void __set_version(const Version& val);

  void __set_vendor(const std::string& val);

  void __set_supportedLanguages(const std::set<std::string> & val);

  bool operator == (const Extension_registerExtension_args & rhs) const
  {
    if (!(canonicalName == rhs.canonicalName))
      return false;
    if (!(launchKey == rhs.launchKey))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(vendor == rhs.vendor))
      return false;
    if (!(supportedLanguages == rhs.supportedLanguages))
      return false;
    return true;
  }
  bool operator != (const Extension_registerExtension_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_registerExtension_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_registerExtension_pargs {
 public:


  virtual ~Extension_registerExtension_pargs() noexcept;
  const std::string* canonicalName;
  const std::string* launchKey;
  const Version* version;
  const std::string* vendor;
  const std::set<std::string> * supportedLanguages;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_registerExtension_result__isset {
  _Extension_registerExtension_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_registerExtension_result__isset;

class Extension_registerExtension_result {
 public:

  Extension_registerExtension_result(const Extension_registerExtension_result&);
  Extension_registerExtension_result& operator=(const Extension_registerExtension_result&);
  Extension_registerExtension_result() noexcept
                                     : success(0) {
  }

  virtual ~Extension_registerExtension_result() noexcept;
  ExtensionID success;
  IllegalArgument e;

  _Extension_registerExtension_result__isset __isset;

  void __set_success(const ExtensionID val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Extension_registerExtension_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Extension_registerExtension_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_registerExtension_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_registerExtension_presult__isset {
  _Extension_registerExtension_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_registerExtension_presult__isset;

class Extension_registerExtension_presult {
 public:


  virtual ~Extension_registerExtension_presult() noexcept;
  ExtensionID* success;
  IllegalArgument e;

  _Extension_registerExtension_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_unregisterExtension_args__isset {
  _Extension_unregisterExtension_args__isset() : id(false) {}
  bool id :1;
} _Extension_unregisterExtension_args__isset;

class Extension_unregisterExtension_args {
 public:

  Extension_unregisterExtension_args(const Extension_unregisterExtension_args&) noexcept;
  Extension_unregisterExtension_args& operator=(const Extension_unregisterExtension_args&) noexcept;
  Extension_unregisterExtension_args() noexcept
                                     : id(0) {
  }

  virtual ~Extension_unregisterExtension_args() noexcept;
  ExtensionID id;

  _Extension_unregisterExtension_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_unregisterExtension_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_unregisterExtension_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_unregisterExtension_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_unregisterExtension_pargs {
 public:


  virtual ~Extension_unregisterExtension_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_unregisterExtension_result__isset {
  _Extension_unregisterExtension_result__isset() : e(false) {}
  bool e :1;
} _Extension_unregisterExtension_result__isset;

class Extension_unregisterExtension_result {
 public:

  Extension_unregisterExtension_result(const Extension_unregisterExtension_result&);
  Extension_unregisterExtension_result& operator=(const Extension_unregisterExtension_result&);
  Extension_unregisterExtension_result() noexcept {
  }

  virtual ~Extension_unregisterExtension_result() noexcept;
  InvalidID e;

  _Extension_unregisterExtension_result__isset __isset;

  void __set_e(const InvalidID& val);

  bool operator == (const Extension_unregisterExtension_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Extension_unregisterExtension_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_unregisterExtension_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_unregisterExtension_presult__isset {
  _Extension_unregisterExtension_presult__isset() : e(false) {}
  bool e :1;
} _Extension_unregisterExtension_presult__isset;

class Extension_unregisterExtension_presult {
 public:


  virtual ~Extension_unregisterExtension_presult() noexcept;
  InvalidID e;

  _Extension_unregisterExtension_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_ping_args__isset {
  _Extension_ping_args__isset() : id(false) {}
  bool id :1;
} _Extension_ping_args__isset;

class Extension_ping_args {
 public:

  Extension_ping_args(const Extension_ping_args&) noexcept;
  Extension_ping_args& operator=(const Extension_ping_args&) noexcept;
  Extension_ping_args() noexcept
                      : id(0) {
  }

  virtual ~Extension_ping_args() noexcept;
  ExtensionID id;

  _Extension_ping_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_ping_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_ping_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_ping_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_ping_pargs {
 public:


  virtual ~Extension_ping_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_ping_result__isset {
  _Extension_ping_result__isset() : e(false) {}
  bool e :1;
} _Extension_ping_result__isset;

class Extension_ping_result {
 public:

  Extension_ping_result(const Extension_ping_result&);
  Extension_ping_result& operator=(const Extension_ping_result&);
  Extension_ping_result() noexcept {
  }

  virtual ~Extension_ping_result() noexcept;
  InvalidID e;

  _Extension_ping_result__isset __isset;

  void __set_e(const InvalidID& val);

  bool operator == (const Extension_ping_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Extension_ping_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_ping_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_ping_presult__isset {
  _Extension_ping_presult__isset() : e(false) {}
  bool e :1;
} _Extension_ping_presult__isset;

class Extension_ping_presult {
 public:


  virtual ~Extension_ping_presult() noexcept;
  InvalidID e;

  _Extension_ping_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_controller_args__isset {
  _Extension_controller_args__isset() : id(false) {}
  bool id :1;
} _Extension_controller_args__isset;

class Extension_controller_args {
 public:

  Extension_controller_args(const Extension_controller_args&) noexcept;
  Extension_controller_args& operator=(const Extension_controller_args&) noexcept;
  Extension_controller_args() noexcept
                            : id(0) {
  }

  virtual ~Extension_controller_args() noexcept;
  ExtensionID id;

  _Extension_controller_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_controller_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_controller_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_controller_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_controller_pargs {
 public:


  virtual ~Extension_controller_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_controller_result__isset {
  _Extension_controller_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_controller_result__isset;

class Extension_controller_result {
 public:

  Extension_controller_result(const Extension_controller_result&);
  Extension_controller_result& operator=(const Extension_controller_result&);
  Extension_controller_result() noexcept
                              : success(0) {
  }

  virtual ~Extension_controller_result() noexcept;
  ControllerID success;
  InvalidID e;

  _Extension_controller_result__isset __isset;

  void __set_success(const ControllerID val);

  void __set_e(const InvalidID& val);

  bool operator == (const Extension_controller_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Extension_controller_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_controller_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_controller_presult__isset {
  _Extension_controller_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_controller_presult__isset;

class Extension_controller_presult {
 public:


  virtual ~Extension_controller_presult() noexcept;
  ControllerID* success;
  InvalidID e;

  _Extension_controller_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_pendant_args__isset {
  _Extension_pendant_args__isset() : id(false) {}
  bool id :1;
} _Extension_pendant_args__isset;

class Extension_pendant_args {
 public:

  Extension_pendant_args(const Extension_pendant_args&) noexcept;
  Extension_pendant_args& operator=(const Extension_pendant_args&) noexcept;
  Extension_pendant_args() noexcept
                         : id(0) {
  }

  virtual ~Extension_pendant_args() noexcept;
  ExtensionID id;

  _Extension_pendant_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_pendant_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_pendant_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_pendant_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_pendant_pargs {
 public:


  virtual ~Extension_pendant_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_pendant_result__isset {
  _Extension_pendant_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_pendant_result__isset;

class Extension_pendant_result {
 public:

  Extension_pendant_result(const Extension_pendant_result&);
  Extension_pendant_result& operator=(const Extension_pendant_result&);
  Extension_pendant_result() noexcept
                           : success(0) {
  }

  virtual ~Extension_pendant_result() noexcept;
  PendantID success;
  InvalidID e;

  _Extension_pendant_result__isset __isset;

  void __set_success(const PendantID val);

  void __set_e(const InvalidID& val);

  bool operator == (const Extension_pendant_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Extension_pendant_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_pendant_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_pendant_presult__isset {
  _Extension_pendant_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_pendant_presult__isset;

class Extension_pendant_presult {
 public:


  virtual ~Extension_pendant_presult() noexcept;
  PendantID* success;
  InvalidID e;

  _Extension_pendant_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_log_args__isset {
  _Extension_log_args__isset() : id(false), level(false), message(false) {}
  bool id :1;
  bool level :1;
  bool message :1;
} _Extension_log_args__isset;

class Extension_log_args {
 public:

  Extension_log_args(const Extension_log_args&);
  Extension_log_args& operator=(const Extension_log_args&);
  Extension_log_args() noexcept
                     : id(0),
                       level(static_cast<LoggingLevel::type>(0)),
                       message() {
  }

  virtual ~Extension_log_args() noexcept;
  ExtensionID id;
  /**
   * 
   * @see LoggingLevel
   */
  LoggingLevel::type level;
  std::string message;

  _Extension_log_args__isset __isset;

  void __set_id(const ExtensionID val);

  void __set_level(const LoggingLevel::type val);

  void __set_message(const std::string& val);

  bool operator == (const Extension_log_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(level == rhs.level))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Extension_log_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_log_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_log_pargs {
 public:


  virtual ~Extension_log_pargs() noexcept;
  const ExtensionID* id;
  /**
   * 
   * @see LoggingLevel
   */
  const LoggingLevel::type* level;
  const std::string* message;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_subscribeLoggingEvents_args__isset {
  _Extension_subscribeLoggingEvents_args__isset() : id(false) {}
  bool id :1;
} _Extension_subscribeLoggingEvents_args__isset;

class Extension_subscribeLoggingEvents_args {
 public:

  Extension_subscribeLoggingEvents_args(const Extension_subscribeLoggingEvents_args&) noexcept;
  Extension_subscribeLoggingEvents_args& operator=(const Extension_subscribeLoggingEvents_args&) noexcept;
  Extension_subscribeLoggingEvents_args() noexcept
                                        : id(0) {
  }

  virtual ~Extension_subscribeLoggingEvents_args() noexcept;
  ExtensionID id;

  _Extension_subscribeLoggingEvents_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_subscribeLoggingEvents_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_subscribeLoggingEvents_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_subscribeLoggingEvents_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_subscribeLoggingEvents_pargs {
 public:


  virtual ~Extension_subscribeLoggingEvents_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_subscribeLoggingEvents_result {
 public:

  Extension_subscribeLoggingEvents_result(const Extension_subscribeLoggingEvents_result&) noexcept;
  Extension_subscribeLoggingEvents_result& operator=(const Extension_subscribeLoggingEvents_result&) noexcept;
  Extension_subscribeLoggingEvents_result() noexcept {
  }

  virtual ~Extension_subscribeLoggingEvents_result() noexcept;

  bool operator == (const Extension_subscribeLoggingEvents_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Extension_subscribeLoggingEvents_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_subscribeLoggingEvents_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_subscribeLoggingEvents_presult {
 public:


  virtual ~Extension_subscribeLoggingEvents_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_unsubscribeLoggingEvents_args__isset {
  _Extension_unsubscribeLoggingEvents_args__isset() : id(false) {}
  bool id :1;
} _Extension_unsubscribeLoggingEvents_args__isset;

class Extension_unsubscribeLoggingEvents_args {
 public:

  Extension_unsubscribeLoggingEvents_args(const Extension_unsubscribeLoggingEvents_args&) noexcept;
  Extension_unsubscribeLoggingEvents_args& operator=(const Extension_unsubscribeLoggingEvents_args&) noexcept;
  Extension_unsubscribeLoggingEvents_args() noexcept
                                          : id(0) {
  }

  virtual ~Extension_unsubscribeLoggingEvents_args() noexcept;
  ExtensionID id;

  _Extension_unsubscribeLoggingEvents_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_unsubscribeLoggingEvents_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_unsubscribeLoggingEvents_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_unsubscribeLoggingEvents_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_unsubscribeLoggingEvents_pargs {
 public:


  virtual ~Extension_unsubscribeLoggingEvents_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_unsubscribeLoggingEvents_result {
 public:

  Extension_unsubscribeLoggingEvents_result(const Extension_unsubscribeLoggingEvents_result&) noexcept;
  Extension_unsubscribeLoggingEvents_result& operator=(const Extension_unsubscribeLoggingEvents_result&) noexcept;
  Extension_unsubscribeLoggingEvents_result() noexcept {
  }

  virtual ~Extension_unsubscribeLoggingEvents_result() noexcept;

  bool operator == (const Extension_unsubscribeLoggingEvents_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Extension_unsubscribeLoggingEvents_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_unsubscribeLoggingEvents_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_unsubscribeLoggingEvents_presult {
 public:


  virtual ~Extension_unsubscribeLoggingEvents_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_logEvents_args__isset {
  _Extension_logEvents_args__isset() : id(false) {}
  bool id :1;
} _Extension_logEvents_args__isset;

class Extension_logEvents_args {
 public:

  Extension_logEvents_args(const Extension_logEvents_args&) noexcept;
  Extension_logEvents_args& operator=(const Extension_logEvents_args&) noexcept;
  Extension_logEvents_args() noexcept
                           : id(0) {
  }

  virtual ~Extension_logEvents_args() noexcept;
  ExtensionID id;

  _Extension_logEvents_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_logEvents_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_logEvents_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_logEvents_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_logEvents_pargs {
 public:


  virtual ~Extension_logEvents_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_logEvents_result__isset {
  _Extension_logEvents_result__isset() : success(false) {}
  bool success :1;
} _Extension_logEvents_result__isset;

class Extension_logEvents_result {
 public:

  Extension_logEvents_result(const Extension_logEvents_result&);
  Extension_logEvents_result& operator=(const Extension_logEvents_result&);
  Extension_logEvents_result() noexcept {
  }

  virtual ~Extension_logEvents_result() noexcept;
  std::vector<LoggingEvent>  success;

  _Extension_logEvents_result__isset __isset;

  void __set_success(const std::vector<LoggingEvent> & val);

  bool operator == (const Extension_logEvents_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Extension_logEvents_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_logEvents_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_logEvents_presult__isset {
  _Extension_logEvents_presult__isset() : success(false) {}
  bool success :1;
} _Extension_logEvents_presult__isset;

class Extension_logEvents_presult {
 public:


  virtual ~Extension_logEvents_presult() noexcept;
  std::vector<LoggingEvent> * success;

  _Extension_logEvents_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_publicKey_args__isset {
  _Extension_publicKey_args__isset() : id(false) {}
  bool id :1;
} _Extension_publicKey_args__isset;

class Extension_publicKey_args {
 public:

  Extension_publicKey_args(const Extension_publicKey_args&) noexcept;
  Extension_publicKey_args& operator=(const Extension_publicKey_args&) noexcept;
  Extension_publicKey_args() noexcept
                           : id(0) {
  }

  virtual ~Extension_publicKey_args() noexcept;
  ExtensionID id;

  _Extension_publicKey_args__isset __isset;

  void __set_id(const ExtensionID val);

  bool operator == (const Extension_publicKey_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Extension_publicKey_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_publicKey_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_publicKey_pargs {
 public:


  virtual ~Extension_publicKey_pargs() noexcept;
  const ExtensionID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_publicKey_result__isset {
  _Extension_publicKey_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_publicKey_result__isset;

class Extension_publicKey_result {
 public:

  Extension_publicKey_result(const Extension_publicKey_result&);
  Extension_publicKey_result& operator=(const Extension_publicKey_result&);
  Extension_publicKey_result() noexcept
                             : success() {
  }

  virtual ~Extension_publicKey_result() noexcept;
  std::string success;
  InvalidID e;

  _Extension_publicKey_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const InvalidID& val);

  bool operator == (const Extension_publicKey_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Extension_publicKey_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_publicKey_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_publicKey_presult__isset {
  _Extension_publicKey_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_publicKey_presult__isset;

class Extension_publicKey_presult {
 public:


  virtual ~Extension_publicKey_presult() noexcept;
  std::string* success;
  InvalidID e;

  _Extension_publicKey_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_oneTimeAuthToken_args__isset {
  _Extension_oneTimeAuthToken_args__isset() : id(false), oneTimeSalt(false), publicKey(false) {}
  bool id :1;
  bool oneTimeSalt :1;
  bool publicKey :1;
} _Extension_oneTimeAuthToken_args__isset;

class Extension_oneTimeAuthToken_args {
 public:

  Extension_oneTimeAuthToken_args(const Extension_oneTimeAuthToken_args&);
  Extension_oneTimeAuthToken_args& operator=(const Extension_oneTimeAuthToken_args&);
  Extension_oneTimeAuthToken_args() noexcept
                                  : id(0),
                                    oneTimeSalt(),
                                    publicKey() {
  }

  virtual ~Extension_oneTimeAuthToken_args() noexcept;
  ExtensionID id;
  std::string oneTimeSalt;
  std::string publicKey;

  _Extension_oneTimeAuthToken_args__isset __isset;

  void __set_id(const ExtensionID val);

  void __set_oneTimeSalt(const std::string& val);

  void __set_publicKey(const std::string& val);

  bool operator == (const Extension_oneTimeAuthToken_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(oneTimeSalt == rhs.oneTimeSalt))
      return false;
    if (!(publicKey == rhs.publicKey))
      return false;
    return true;
  }
  bool operator != (const Extension_oneTimeAuthToken_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_oneTimeAuthToken_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_oneTimeAuthToken_pargs {
 public:


  virtual ~Extension_oneTimeAuthToken_pargs() noexcept;
  const ExtensionID* id;
  const std::string* oneTimeSalt;
  const std::string* publicKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_oneTimeAuthToken_result__isset {
  _Extension_oneTimeAuthToken_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_oneTimeAuthToken_result__isset;

class Extension_oneTimeAuthToken_result {
 public:

  Extension_oneTimeAuthToken_result(const Extension_oneTimeAuthToken_result&);
  Extension_oneTimeAuthToken_result& operator=(const Extension_oneTimeAuthToken_result&);
  Extension_oneTimeAuthToken_result() noexcept
                                    : success() {
  }

  virtual ~Extension_oneTimeAuthToken_result() noexcept;
  std::string success;
  InvalidID e;

  _Extension_oneTimeAuthToken_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const InvalidID& val);

  bool operator == (const Extension_oneTimeAuthToken_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Extension_oneTimeAuthToken_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_oneTimeAuthToken_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_oneTimeAuthToken_presult__isset {
  _Extension_oneTimeAuthToken_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Extension_oneTimeAuthToken_presult__isset;

class Extension_oneTimeAuthToken_presult {
 public:


  virtual ~Extension_oneTimeAuthToken_presult() noexcept;
  std::string* success;
  InvalidID e;

  _Extension_oneTimeAuthToken_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Extension_installPackage_args__isset {
  _Extension_installPackage_args__isset() : id(false), authToken(false), packageData(false), overridePasscodeEnc(false) {}
  bool id :1;
  bool authToken :1;
  bool packageData :1;
  bool overridePasscodeEnc :1;
} _Extension_installPackage_args__isset;

class Extension_installPackage_args {
 public:

  Extension_installPackage_args(const Extension_installPackage_args&);
  Extension_installPackage_args& operator=(const Extension_installPackage_args&);
  Extension_installPackage_args() noexcept
                                : id(0),
                                  authToken(),
                                  packageData(),
                                  overridePasscodeEnc() {
  }

  virtual ~Extension_installPackage_args() noexcept;
  ExtensionID id;
  std::string authToken;
  std::string packageData;
  std::string overridePasscodeEnc;

  _Extension_installPackage_args__isset __isset;

  void __set_id(const ExtensionID val);

  void __set_authToken(const std::string& val);

  void __set_packageData(const std::string& val);

  void __set_overridePasscodeEnc(const std::string& val);

  bool operator == (const Extension_installPackage_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(authToken == rhs.authToken))
      return false;
    if (!(packageData == rhs.packageData))
      return false;
    if (!(overridePasscodeEnc == rhs.overridePasscodeEnc))
      return false;
    return true;
  }
  bool operator != (const Extension_installPackage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_installPackage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Extension_installPackage_pargs {
 public:


  virtual ~Extension_installPackage_pargs() noexcept;
  const ExtensionID* id;
  const std::string* authToken;
  const std::string* packageData;
  const std::string* overridePasscodeEnc;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_installPackage_result__isset {
  _Extension_installPackage_result__isset() : success(false) {}
  bool success :1;
} _Extension_installPackage_result__isset;

class Extension_installPackage_result {
 public:

  Extension_installPackage_result(const Extension_installPackage_result&);
  Extension_installPackage_result& operator=(const Extension_installPackage_result&);
  Extension_installPackage_result() noexcept {
  }

  virtual ~Extension_installPackage_result() noexcept;
  std::vector<std::string>  success;

  _Extension_installPackage_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  bool operator == (const Extension_installPackage_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Extension_installPackage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Extension_installPackage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Extension_installPackage_presult__isset {
  _Extension_installPackage_presult__isset() : success(false) {}
  bool success :1;
} _Extension_installPackage_presult__isset;

class Extension_installPackage_presult {
 public:


  virtual ~Extension_installPackage_presult() noexcept;
  std::vector<std::string> * success;

  _Extension_installPackage_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ExtensionClient : virtual public ExtensionIf {
 public:
  ExtensionClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ExtensionClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Version of API the service implements.
   * Smart Pendant | API version
   * 2.0           | 2.0.4
   * 2.1           | 2.1.0
   */
  void apiVersion(Version& _return) override;
  void send_apiVersion();
  void recv_apiVersion(Version& _return);
  /**
   * Register extension with Smart Pendant API service.
   * Extension must exist in the extension database (i.e. through installation)
   * 
   * @param canonicalName
   * @param launchKey
   * @param version
   * @param vendor
   * @param supportedLanguages
   */
  ExtensionID registerExtension(const std::string& canonicalName, const std::string& launchKey, const Version& version, const std::string& vendor, const std::set<std::string> & supportedLanguages) override;
  void send_registerExtension(const std::string& canonicalName, const std::string& launchKey, const Version& version, const std::string& vendor, const std::set<std::string> & supportedLanguages);
  ExtensionID recv_registerExtension();
  void unregisterExtension(const ExtensionID id) override;
  void send_unregisterExtension(const ExtensionID id);
  void recv_unregisterExtension();
  /**
   * Indicate liveliness
   * API service will automatically unregister extensions that are unresponsive for some period.
   * If extension is not regularly calling events(), call ping() to indicate the extension is operational.
   * 
   * @param id
   */
  void ping(const ExtensionID id) override;
  void send_ping(const ExtensionID id);
  void recv_ping();
  /**
   * Obtain ID handle for Robot Conroller API
   * 
   * @param id
   */
  ControllerID controller(const ExtensionID id) override;
  void send_controller(const ExtensionID id);
  ControllerID recv_controller();
  /**
   * Obtain ID handle for Pendant UI API
   * 
   * @param id
   */
  PendantID pendant(const ExtensionID id) override;
  void send_pendant(const ExtensionID id);
  PendantID recv_pendant();
  /**
   * Log message to standard pendant logging facility
   * Visible to end-users upon plain-text log file export.
   * Note that Debug level logging is ignored unless in Developer access level.
   * 
   * @param id
   * @param level
   * @param message
   */
  void log(const ExtensionID id, const LoggingLevel::type level, const std::string& message) override;
  void send_log(const ExtensionID id, const LoggingLevel::type level, const std::string& message);
  /**
   * Subscribe to receive log message events via events()
   * 
   * @param id
   */
  void subscribeLoggingEvents(const ExtensionID id) override;
  void send_subscribeLoggingEvents(const ExtensionID id);
  void recv_subscribeLoggingEvents();
  void unsubscribeLoggingEvents(const ExtensionID id) override;
  void send_unsubscribeLoggingEvents(const ExtensionID id);
  void recv_unsubscribeLoggingEvents();
  /**
   * Obtain list of logging events that have occured since last call
   * NB: For development troubleshooting only, logging events
   * only available when development access enabled
   * 
   * @param id
   */
  void logEvents(std::vector<LoggingEvent> & _return, const ExtensionID id) override;
  void send_logEvents(const ExtensionID id);
  void recv_logEvents(std::vector<LoggingEvent> & _return);
  void publicKey(std::string& _return, const ExtensionID id) override;
  void send_publicKey(const ExtensionID id);
  void recv_publicKey(std::string& _return);
  void oneTimeAuthToken(std::string& _return, const ExtensionID id, const std::string& oneTimeSalt, const std::string& publicKey) override;
  void send_oneTimeAuthToken(const ExtensionID id, const std::string& oneTimeSalt, const std::string& publicKey);
  void recv_oneTimeAuthToken(std::string& _return);
  void installPackage(std::vector<std::string> & _return, const ExtensionID id, const std::string& authToken, const std::string& packageData, const std::string& overridePasscodeEnc) override;
  void send_installPackage(const ExtensionID id, const std::string& authToken, const std::string& packageData, const std::string& overridePasscodeEnc);
  void recv_installPackage(std::vector<std::string> & _return);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ExtensionProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<ExtensionIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) override;
 private:
  typedef  void (ExtensionProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_apiVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerExtension(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unregisterExtension(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ping(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_controller(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pendant(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_log(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_subscribeLoggingEvents(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unsubscribeLoggingEvents(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_logEvents(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_publicKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_oneTimeAuthToken(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_installPackage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ExtensionProcessor(::std::shared_ptr<ExtensionIf> iface) :
    iface_(iface) {
    processMap_["apiVersion"] = &ExtensionProcessor::process_apiVersion;
    processMap_["registerExtension"] = &ExtensionProcessor::process_registerExtension;
    processMap_["unregisterExtension"] = &ExtensionProcessor::process_unregisterExtension;
    processMap_["ping"] = &ExtensionProcessor::process_ping;
    processMap_["controller"] = &ExtensionProcessor::process_controller;
    processMap_["pendant"] = &ExtensionProcessor::process_pendant;
    processMap_["log"] = &ExtensionProcessor::process_log;
    processMap_["subscribeLoggingEvents"] = &ExtensionProcessor::process_subscribeLoggingEvents;
    processMap_["unsubscribeLoggingEvents"] = &ExtensionProcessor::process_unsubscribeLoggingEvents;
    processMap_["logEvents"] = &ExtensionProcessor::process_logEvents;
    processMap_["publicKey"] = &ExtensionProcessor::process_publicKey;
    processMap_["oneTimeAuthToken"] = &ExtensionProcessor::process_oneTimeAuthToken;
    processMap_["installPackage"] = &ExtensionProcessor::process_installPackage;
  }

  virtual ~ExtensionProcessor() {}
};

class ExtensionProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ExtensionProcessorFactory(const ::std::shared_ptr< ExtensionIfFactory >& handlerFactory) noexcept :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) override;

 protected:
  ::std::shared_ptr< ExtensionIfFactory > handlerFactory_;
};

class ExtensionMultiface : virtual public ExtensionIf {
 public:
  ExtensionMultiface(std::vector<std::shared_ptr<ExtensionIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ExtensionMultiface() {}
 protected:
  std::vector<std::shared_ptr<ExtensionIf> > ifaces_;
  ExtensionMultiface() {}
  void add(::std::shared_ptr<ExtensionIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  /**
   * Version of API the service implements.
   * Smart Pendant | API version
   * 2.0           | 2.0.4
   * 2.1           | 2.1.0
   */
  void apiVersion(Version& _return) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->apiVersion(_return);
    }
    ifaces_[i]->apiVersion(_return);
    return;
  }

  /**
   * Register extension with Smart Pendant API service.
   * Extension must exist in the extension database (i.e. through installation)
   * 
   * @param canonicalName
   * @param launchKey
   * @param version
   * @param vendor
   * @param supportedLanguages
   */
  ExtensionID registerExtension(const std::string& canonicalName, const std::string& launchKey, const Version& version, const std::string& vendor, const std::set<std::string> & supportedLanguages) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerExtension(canonicalName, launchKey, version, vendor, supportedLanguages);
    }
    return ifaces_[i]->registerExtension(canonicalName, launchKey, version, vendor, supportedLanguages);
  }

  void unregisterExtension(const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unregisterExtension(id);
    }
    ifaces_[i]->unregisterExtension(id);
  }

  /**
   * Indicate liveliness
   * API service will automatically unregister extensions that are unresponsive for some period.
   * If extension is not regularly calling events(), call ping() to indicate the extension is operational.
   * 
   * @param id
   */
  void ping(const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ping(id);
    }
    ifaces_[i]->ping(id);
  }

  /**
   * Obtain ID handle for Robot Conroller API
   * 
   * @param id
   */
  ControllerID controller(const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->controller(id);
    }
    return ifaces_[i]->controller(id);
  }

  /**
   * Obtain ID handle for Pendant UI API
   * 
   * @param id
   */
  PendantID pendant(const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pendant(id);
    }
    return ifaces_[i]->pendant(id);
  }

  /**
   * Log message to standard pendant logging facility
   * Visible to end-users upon plain-text log file export.
   * Note that Debug level logging is ignored unless in Developer access level.
   * 
   * @param id
   * @param level
   * @param message
   */
  void log(const ExtensionID id, const LoggingLevel::type level, const std::string& message) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->log(id, level, message);
    }
    ifaces_[i]->log(id, level, message);
  }

  /**
   * Subscribe to receive log message events via events()
   * 
   * @param id
   */
  void subscribeLoggingEvents(const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->subscribeLoggingEvents(id);
    }
    ifaces_[i]->subscribeLoggingEvents(id);
  }

  void unsubscribeLoggingEvents(const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unsubscribeLoggingEvents(id);
    }
    ifaces_[i]->unsubscribeLoggingEvents(id);
  }

  /**
   * Obtain list of logging events that have occured since last call
   * NB: For development troubleshooting only, logging events
   * only available when development access enabled
   * 
   * @param id
   */
  void logEvents(std::vector<LoggingEvent> & _return, const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->logEvents(_return, id);
    }
    ifaces_[i]->logEvents(_return, id);
    return;
  }

  void publicKey(std::string& _return, const ExtensionID id) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->publicKey(_return, id);
    }
    ifaces_[i]->publicKey(_return, id);
    return;
  }

  void oneTimeAuthToken(std::string& _return, const ExtensionID id, const std::string& oneTimeSalt, const std::string& publicKey) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->oneTimeAuthToken(_return, id, oneTimeSalt, publicKey);
    }
    ifaces_[i]->oneTimeAuthToken(_return, id, oneTimeSalt, publicKey);
    return;
  }

  void installPackage(std::vector<std::string> & _return, const ExtensionID id, const std::string& authToken, const std::string& packageData, const std::string& overridePasscodeEnc) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->installPackage(_return, id, authToken, packageData, overridePasscodeEnc);
    }
    ifaces_[i]->installPackage(_return, id, authToken, packageData, overridePasscodeEnc);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ExtensionConcurrentClient : virtual public ExtensionIf {
 public:
  ExtensionConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  ExtensionConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Version of API the service implements.
   * Smart Pendant | API version
   * 2.0           | 2.0.4
   * 2.1           | 2.1.0
   */
  void apiVersion(Version& _return) override;
  int32_t send_apiVersion();
  void recv_apiVersion(Version& _return, const int32_t seqid);
  /**
   * Register extension with Smart Pendant API service.
   * Extension must exist in the extension database (i.e. through installation)
   * 
   * @param canonicalName
   * @param launchKey
   * @param version
   * @param vendor
   * @param supportedLanguages
   */
  ExtensionID registerExtension(const std::string& canonicalName, const std::string& launchKey, const Version& version, const std::string& vendor, const std::set<std::string> & supportedLanguages) override;
  int32_t send_registerExtension(const std::string& canonicalName, const std::string& launchKey, const Version& version, const std::string& vendor, const std::set<std::string> & supportedLanguages);
  ExtensionID recv_registerExtension(const int32_t seqid);
  void unregisterExtension(const ExtensionID id) override;
  int32_t send_unregisterExtension(const ExtensionID id);
  void recv_unregisterExtension(const int32_t seqid);
  /**
   * Indicate liveliness
   * API service will automatically unregister extensions that are unresponsive for some period.
   * If extension is not regularly calling events(), call ping() to indicate the extension is operational.
   * 
   * @param id
   */
  void ping(const ExtensionID id) override;
  int32_t send_ping(const ExtensionID id);
  void recv_ping(const int32_t seqid);
  /**
   * Obtain ID handle for Robot Conroller API
   * 
   * @param id
   */
  ControllerID controller(const ExtensionID id) override;
  int32_t send_controller(const ExtensionID id);
  ControllerID recv_controller(const int32_t seqid);
  /**
   * Obtain ID handle for Pendant UI API
   * 
   * @param id
   */
  PendantID pendant(const ExtensionID id) override;
  int32_t send_pendant(const ExtensionID id);
  PendantID recv_pendant(const int32_t seqid);
  /**
   * Log message to standard pendant logging facility
   * Visible to end-users upon plain-text log file export.
   * Note that Debug level logging is ignored unless in Developer access level.
   * 
   * @param id
   * @param level
   * @param message
   */
  void log(const ExtensionID id, const LoggingLevel::type level, const std::string& message) override;
  void send_log(const ExtensionID id, const LoggingLevel::type level, const std::string& message);
  /**
   * Subscribe to receive log message events via events()
   * 
   * @param id
   */
  void subscribeLoggingEvents(const ExtensionID id) override;
  int32_t send_subscribeLoggingEvents(const ExtensionID id);
  void recv_subscribeLoggingEvents(const int32_t seqid);
  void unsubscribeLoggingEvents(const ExtensionID id) override;
  int32_t send_unsubscribeLoggingEvents(const ExtensionID id);
  void recv_unsubscribeLoggingEvents(const int32_t seqid);
  /**
   * Obtain list of logging events that have occured since last call
   * NB: For development troubleshooting only, logging events
   * only available when development access enabled
   * 
   * @param id
   */
  void logEvents(std::vector<LoggingEvent> & _return, const ExtensionID id) override;
  int32_t send_logEvents(const ExtensionID id);
  void recv_logEvents(std::vector<LoggingEvent> & _return, const int32_t seqid);
  void publicKey(std::string& _return, const ExtensionID id) override;
  int32_t send_publicKey(const ExtensionID id);
  void recv_publicKey(std::string& _return, const int32_t seqid);
  void oneTimeAuthToken(std::string& _return, const ExtensionID id, const std::string& oneTimeSalt, const std::string& publicKey) override;
  int32_t send_oneTimeAuthToken(const ExtensionID id, const std::string& oneTimeSalt, const std::string& publicKey);
  void recv_oneTimeAuthToken(std::string& _return, const int32_t seqid);
  void installPackage(std::vector<std::string> & _return, const ExtensionID id, const std::string& authToken, const std::string& packageData, const std::string& overridePasscodeEnc) override;
  int32_t send_installPackage(const ExtensionID id, const std::string& authToken, const std::string& packageData, const std::string& overridePasscodeEnc);
  void recv_installPackage(std::vector<std::string> & _return, const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}}} // namespace

#endif
