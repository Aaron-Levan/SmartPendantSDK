/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Controller_H
#define Controller_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "extension_types.h"

namespace yaskawa { namespace ext { namespace api {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

/**
 * Interface to Robot Controllers
 * 
 * In general, a pendant may operate in connected or disconnected states.  When connected to a Robot Controller
 * it may be monitoring or not have exclusive control (i.e. not be the single-point-of-control).
 * 
 * However, typically, once an extension is running, the pendant is connected to the controller and
 * is the single-point-of-control.
 */
class ControllerIf {
 public:
  virtual ~ControllerIf() {}

  /**
   * Request specified permissions.
   * 
   * @param c
   * @param permissions
   */
  virtual bool requestPermissions(const ControllerID c, const std::set<std::string> & permissions) = 0;

  /**
   * Check permisions obtained.
   * 
   * @param c
   * @param permission
   */
  virtual bool havePermission(const ControllerID c, const std::string& permission) = 0;

  /**
   * Relinquish permissions (no effect if not held).
   * 
   * @param c
   * @param permissions
   */
  virtual void relinquishPermissions(const ControllerID c, const std::set<std::string> & permissions) = 0;

  /**
   * Connect to the specified Robot Controller (by IP adress or hostname if DNS available)
   * Typically, the pendant will already be connected to a controller when extensions are started,
   * so calling connect() is not required.
   * 
   * @param c
   * @param hostName
   */
  virtual void connect(const ControllerID c, const std::string& hostName) = 0;

  /**
   * Disconnect from the connected controller.  This leaves the pendant in the 'disconnected' state.
   * When disconnected, many functions are unavailable or will return default values.
   * 
   * @param c
   */
  virtual void disconnect(const ControllerID c) = 0;

  /**
   * Subscribe to the specified events, if not already.
   * Note: If using a Yaskawa supplied client library with event consumer callback support,
   *       registering an event consumer callback will automatically subscribe to the appropriate event.
   * 
   * @param c
   * @param types
   */
  virtual void subscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) = 0;

  /**
   * Unsubscribe from the specified events.
   * If called directly, this may causes event consumers for the events not to be called.
   * 
   * @param c
   * @param types
   */
  virtual void unsubscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) = 0;

  /**
   * Poll the API Service for pending events.
   * Note: If using a Yaskawa supplied client library, this does not need to be called explicitly.
   * 
   * @param c
   */
  virtual void events(std::vector<ControllerEvent> & _return, const ControllerID c) = 0;

  /**
   * Returns true if the pendant is connected to a robot controller
   * 
   * @param c
   */
  virtual bool connected(const ControllerID c) = 0;

  /**
   * Returns the hostname or IP address of the robot controller to which the pendant is connected, if any
   * 
   * @param c
   */
  virtual void connectedHostName(std::string& _return, const ControllerID c) = 0;

  /**
   * The software version string of the robot controller system software.
   * 
   * @param c
   */
  virtual void softwareVersion(std::string& _return, const ControllerID c) = 0;

  /**
   * Returns true if the pendant is only monitoring the robot controller to which it is connected.  This
   * implies that no functions that modify the controller and/or robot state will succeed.
   * 
   * @param c
   */
  virtual bool monitoring(const ControllerID c) = 0;

  /**
   * Returns true if this pendant is the single-point-of-control for the connected Robot Controller.
   * If not, most functions that modify the controller and/or robot state will fail.
   * 
   * @param c
   */
  virtual bool haveExclusiveControl(const ControllerID c) = 0;

  /**
   * Current operation mode of the controller
   * Automatic (aka Play) - running jobs
   * Manual (aka Teach) - for editing jobs, teaching points, jogging, setup etc.
   * 
   * @param c
   */
  virtual OperationMode::type operationMode(const ControllerID c) = 0;

  /**
   * Are the servo drives engaged?
   * On - yes, robot(s) are being actively controlled
   * Off - no.  Typically brakes are engaged (unless brake-release engaged)
   * Ready - ready to engage servos.  Typically requires operator to use servo enable switch.
   * 
   * @param c
   */
  virtual ServoState::type servoState(const ControllerID c) = 0;

  /**
   * Indicates if a job us running or stopped.
   * Run - jobs are running (robot may be moving)
   * Held - jobs were running but have been held/paused.
   * Idle - no jobs are running
   * 
   * @param c
   */
  virtual PlaybackState::type playbackState(const ControllerID c) = 0;

  /**
   * Run the current robot job from the current line.  Requires Servos engaged & Automatic/Play operation and 'jobcontrol' permission.
   * 
   * @param c
   */
  virtual void run(const ControllerID c) = 0;

  /**
   * Pause running job (servoes will remain engaged. 'jobcontrol' permission required.
   * 
   * @param c
   */
  virtual void pause(const ControllerID c) = 0;

  /**
   * Resume running job from paused state. 'jobcontrol' permission required.
   * 
   * @param c
   */
  virtual void resume(const ControllerID c) = 0;

  /**
   * Stop runnng job (will stop motion and disengage servos). 'jobcontrol' permission required.
   * 
   * @param c
   */
  virtual void stop(const ControllerID c) = 0;

  /**
   * Name of the current job (e.g. job being run or edited)
   * Empty if none.
   * 
   * @param c
   */
  virtual void currentJob(std::string& _return, const ControllerID c) = 0;

  /**
   * Set the current job. 'jobcontrol' permission required. Pass line=1 for start of job, line=0 for default/no-change.
   * 
   * @param c
   * @param name
   * @param line
   */
  virtual void setCurrentJob(const ControllerID c, const std::string& name, const int32_t line) = 0;

  /**
   * Name of the default (aka master) job.  Empty if no default job designated
   * 
   * @param c
   */
  virtual void defaultJob(std::string& _return, const ControllerID c) = 0;

  /**
   * query if job with specified name exists
   * 
   * @param c
   * @param name
   */
  virtual bool jobExists(const ControllerID c, const std::string& name) = 0;

  /**
   * Details for the named job (throws if non-existent job)
   * 
   * @param c
   * @param name
   */
  virtual void jobDetails(RobotJobInfo& _return, const ControllerID c, const std::string& name) = 0;

  /**
   * List of robot job names (empty if not connected)
   * 
   * @param c
   */
  virtual void jobs(std::vector<std::string> & _return, const ControllerID c) = 0;

  /**
   * List of robot job names matching the name regular expression AND with the given tag
   * (empty if not connected or no matches)
   * 
   * @param c
   * @param nameRegex
   * @param tag
   */
  virtual void jobsMatching(std::vector<std::string> & _return, const ControllerID c, const std::string& nameRegex, const std::string& tag) = 0;

  /**
   * Duplicate an existing job with a new name for the copy
   * 
   * @param c
   * @param existingName
   * @param newName
   */
  virtual void duplicateJob(const ControllerID c, const std::string& existingName, const std::string& newName) = 0;

  /**
   * delete the specified job.  The default job cannot be deleted.
   * 
   * @param c
   * @param name
   */
  virtual void deleteJob(const ControllerID c, const std::string& name) = 0;

  /**
   * Read source code for named job (in the programmingLanguage listed in jobDetails() )
   * 
   * @param c
   * @param name
   */
  virtual void jobSource(std::string& _return, const ControllerID c, const std::string& name) = 0;

  /**
   * Replace named job with the source code provided, in given programmingLanguage (e.g. "INFORM").
   * Will thow if syntax errors in source.
   * 
   * @param c
   * @param name
   * @param programmingLanguage
   * @param sourceCode
   */
  virtual void storeJobSource(const ControllerID c, const std::string& name, const std::string& programmingLanguage, const std::string& sourceCode) = 0;

  /**
   * List of tools mapping index -> name.
   * Unset/defaulted tools are omitted (e.g. those with no name, 0 weight etc.)
   * Indices (map keys) may not be sequential.  Returned map may be empty.
   * 
   * @param c
   */
  virtual void tools(std::map<ToolIndex, std::string> & _return, const ControllerID c) = 0;

  /**
   * Query information on a specific tool, by index
   * 
   * @param c
   * @param index
   */
  virtual void tool(Tool& _return, const ControllerID c, const ToolIndex index) = 0;

  /**
   * Return input number of given input name
   * 
   * @param c
   * @param name
   */
  virtual int32_t inputNumber(const ControllerID c, const std::string& name) = 0;

  /**
   * Return input group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  virtual int32_t inputGroupNumber(const ControllerID c, const std::string& name) = 0;

  /**
   * Return output nunber of given output name
   * 
   * @param c
   * @param name
   */
  virtual int32_t outputNumber(const ControllerID c, const std::string& name) = 0;

  /**
   * Return output group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  virtual int32_t outputGroupNumber(const ControllerID c, const std::string& name) = 0;

  /**
   * Return name of specified input number
   * 
   * @param c
   * @param num
   */
  virtual void inputName(std::string& _return, const ControllerID c, const int32_t num) = 0;

  /**
   * Return name of specified output number
   * 
   * @param c
   * @param num
   */
  virtual void outputName(std::string& _return, const ControllerID c, const int32_t num) = 0;

  /**
   * Set name of specified input (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  virtual void setInputName(const ControllerID c, const int32_t num, const std::string& name) = 0;

  /**
   * Set name of specified output (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  virtual void setOutputName(const ControllerID c, const int32_t num, const std::string& name) = 0;

  /**
   * Start monitoring specified input
   * 
   * @param c
   * @param num
   */
  virtual void monitorInput(const ControllerID c, const int32_t num) = 0;

  /**
   * Start monitoring all inputs in given input group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  virtual void monitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) = 0;

  /**
   * Start monitoring specified output
   * 
   * @param c
   * @param num
   */
  virtual void monitorOutput(const ControllerID c, const int32_t num) = 0;

  /**
   * Start monitoring all outputs in given output group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  virtual void monitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) = 0;

  /**
   * Stop monitoring specified input
   * 
   * @param c
   * @param num
   */
  virtual void unmonitorInput(const ControllerID c, const int32_t num) = 0;

  /**
   * Stop monitoring all inputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  virtual void unmonitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) = 0;

  /**
   * Stop monitoring specified output
   * 
   * @param c
   * @param num
   */
  virtual void unmonitorOutput(const ControllerID c, const int32_t num) = 0;

  /**
   * Stop monitoring all outputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  virtual void unmonitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) = 0;

  /**
   * Return value of given input
   * 
   * @param c
   * @param num
   */
  virtual bool inputValue(const ControllerID c, const int32_t num) = 0;

  /**
   * Return values of input groups from specified group number (upto 4 contiguous groups/bytes, from least significant byte)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  virtual int32_t inputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) = 0;

  /**
   * Return the value of given output
   * 
   * @param c
   * @param num
   */
  virtual bool outputValue(const ControllerID c, const int32_t num) = 0;

  /**
   * Return values of output groups from specified group number (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  virtual int32_t outputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) = 0;

  /**
   * Set the value of the specified output number
   * 
   * @param c
   * @param num
   * @param value
   */
  virtual void setOutput(const ControllerID c, const int32_t num, const bool value) = 0;

  /**
   * Set the values of the outputs in the specified contigous output groups (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   * @param value
   */
  virtual void setOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count, const int32_t value) = 0;

  /**
   * Return the logical IO address of the named input
   * 
   * @param c
   * @param name
   */
  virtual int32_t inputAddress(const ControllerID c, const std::string& name) = 0;

  /**
   * Return the logical IO address of the given input number
   * 
   * @param c
   * @param num
   */
  virtual int32_t inputAddressByNumber(const ControllerID c, const int32_t num) = 0;

  /**
   * Return the logical IO address of the named output
   * 
   * @param c
   * @param name
   */
  virtual int32_t outputAddress(const ControllerID c, const std::string& name) = 0;

  /**
   * Return the logical IO address of the given output number
   * 
   * @param c
   * @param num
   */
  virtual int32_t outputAddressByNumber(const ControllerID c, const int32_t num) = 0;

  /**
   * Start monitoring a logical IO address.  Will generate IOValueChanged events
   * 
   * @param c
   * @param address
   */
  virtual void monitorIOAddress(const ControllerID c, const int32_t address) = 0;

  /**
   * Stop monitoring a logical IO address. (events for address may still be generated if it corresponds to a monitored input or output)
   * 
   * @param c
   * @param address
   */
  virtual void unmonitorIOAddress(const ControllerID c, const int32_t address) = 0;

  /**
   * Return the value of the given input by logcial IO address
   * 
   * @param c
   * @param address
   */
  virtual bool inputAddressValue(const ControllerID c, const int32_t address) = 0;

  /**
   * Return the value of the given output by logcial IO address
   * 
   * @param c
   * @param address
   */
  virtual bool outputAddressValue(const ControllerID c, const int32_t address) = 0;

  /**
   * Set the value of the given output by logical IO address
   * 
   * @param c
   * @param address
   * @param value
   */
  virtual void setOutputAddress(const ControllerID c, const int32_t address, const bool value) = 0;

  /**
   * Obtain input group number (byte) of field bus status input.  e.g. busType 'ethip' yields EtherNet/IP status byte group
   * 
   * @param c
   * @param busType
   */
  virtual int32_t fieldBusStatusInputGroup(const ControllerID c, const std::string& busType) = 0;

  /**
   * Return the list of control groups configured on the controller.
   * If only one robot is connected to the controller, this will return a single element,
   * containing the simple control group representing the robot.
   * 
   * @param c
   */
  virtual void controlGroups(std::vector<ControlGroup> & _return, const ControllerID c) = 0;

  /**
   * Returns the index of the currently active control group.
   * 
   * @param c
   */
  virtual int8_t currentControlGroup(const ControllerID c) = 0;

  /**
   * Returns the number of robots connected to the controller
   * 
   * @param c
   */
  virtual int8_t robotCount(const ControllerID c) = 0;

  /**
   * Returns the index of the currently active robot.
   * Note: index is 0-based, but in the UI the first robot is Robot 1.
   * 
   * @param c
   */
  virtual RobotIndex currentRobot(const ControllerID c) = 0;

  /**
   * Variable value by name
   * 
   * @param c
   * @param name
   */
  virtual void variable(Any& _return, const ControllerID c, const std::string& name) = 0;

  /**
   * Variable value by address
   * 
   * @param c
   * @param addr
   */
  virtual void variableByAddr(Any& _return, const ControllerID c, const VariableAddress& addr) = 0;

  /**
   * Set variable value by name
   * 
   * @param c
   * @param name
   * @param value
   */
  virtual void setVariable(const ControllerID c, const std::string& name, const Any& value) = 0;

  /**
   * Set variable by address
   * 
   * @param c
   * @param addr
   * @param value
   */
  virtual void setVariableByAddr(const ControllerID c, const VariableAddress& addr, const Any& value) = 0;

  /**
   * Lookup variable address by name and space
   * 
   * @param c
   * @param name
   * @param space
   */
  virtual void variableAddrByNameAndSpace(VariableAddress& _return, const ControllerID c, const std::string& name, const AddressSpace::type space) = 0;

  /**
   * Lookup variable address by name (less efficient)
   * 
   * @param c
   * @param name
   */
  virtual void variableAddrByName(VariableAddress& _return, const ControllerID c, const std::string& name) = 0;

  /**
   * Set name of variable by address
   * 
   * @param c
   * @param addr
   * @param name
   */
  virtual void setVariableName(const ControllerID c, const VariableAddress& addr, const std::string& name) = 0;

  /**
   * Query information on specified zone, by index (not number)
   * 
   * @param c
   * @param index
   */
  virtual void zone(Zone& _return, const ControllerID c, const ZoneIndex index) = 0;

  /**
   * Creates a new Zone and returns its index.  It will have default values
   * which can be change via modifyZone()
   * 
   * @param c
   */
  virtual ZoneIndex newZone(const ControllerID c) = 0;

  /**
   * Modify Zone information.  Only fields set in Zone will be updated.
   * 
   * @param c
   * @param index
   * @param z
   */
  virtual void modifyZone(const ControllerID c, const ZoneIndex index, const Zone& z) = 0;

  /**
   * Delete a Zone
   * 
   * @param c
   * @param index
   */
  virtual void deleteZone(const ControllerID c, const ZoneIndex index) = 0;

  /**
   * List of user frames mapping index -> name.
   * NB: Indices (map keys) may not be sequential. Returned map may be empty.
   * 
   * @param c
   */
  virtual void userFrames(std::map<UserFrameIndex, std::string> & _return, const ControllerID c) = 0;

  /**
   * Query information on specified User Frame, by index (not number)
   * 
   * @param c
   * @param index
   */
  virtual void userFrame(CoordinateFrame& _return, const ControllerID c, const UserFrameIndex index) = 0;

  /**
   * Creates a new User Frame with default values and returns its index.
   * 
   * @param c
   */
  virtual UserFrameIndex newUserFrame(const ControllerID c) = 0;

  /**
   * Set the specified User Frame to the provided values
   * 
   * @param c
   * @param index
   * @param f
   */
  virtual void setUserFrame(const ControllerID c, const UserFrameIndex index, const CoordinateFrame& f) = 0;

  /**
   * Delete a User Frame
   * 
   * @param c
   * @param index
   */
  virtual void deleteUserFrame(const ControllerID c, const UserFrameIndex index) = 0;

  /**
   * Query current controller network interface IP address.
   * controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3']
   * (NB: On YRC1000micro, 'LAN' is the external Ethernet port, corresponding to 'LAN2' on the YRC1000)
   * 
   * @param c
   * @param controllerInterface
   */
  virtual void networkInterfaceAddress(std::string& _return, const ControllerID c, const std::string& controllerInterface) = 0;

  /**
   * Request external network access via specified protocol and port originating
   * from the given controller interface. The controllerInferface may be left blank, in which case
   * connections will be routed from the controller according to the destination address and
   * current subnetwork of the external LAN ports).
   * Access only persists while power is maintained to the controller.
   * The protocol must be either 'tcp' or 'udp'. controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3'].
   * Returns a handle that can subsequently used to remove the access, or -1 if the access request
   * failed (may happen in case of network conflicts with other extensions).
   * Requires 'networking' permision.
   * 
   * @param c
   * @param controllerInterface
   * @param port
   * @param protocol
   */
  virtual int32_t requestNetworkAccess(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) = 0;
  virtual void removeNetworkAccess(const ControllerID c, const int32_t accessHandle) = 0;
  virtual int32_t requestNetworkService(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) = 0;
  virtual void removeNetworkService(const ControllerID c, const int32_t accessHandle) = 0;
};

class ControllerIfFactory {
 public:
  typedef ControllerIf Handler;

  virtual ~ControllerIfFactory() {}

  virtual ControllerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ControllerIf* /* handler */) = 0;
  };

class ControllerIfSingletonFactory : virtual public ControllerIfFactory {
 public:
  ControllerIfSingletonFactory(const ::std::shared_ptr<ControllerIf>& iface) : iface_(iface) {}
  virtual ~ControllerIfSingletonFactory() {}

  virtual ControllerIf* getHandler(const ::apache::thrift::TConnectionInfo&) override {
    return iface_.get();
  }
  virtual void releaseHandler(ControllerIf* /* handler */) override {}

 protected:
  ::std::shared_ptr<ControllerIf> iface_;
};

class ControllerNull : virtual public ControllerIf {
 public:
  virtual ~ControllerNull() {}
  bool requestPermissions(const ControllerID /* c */, const std::set<std::string> & /* permissions */) override {
    bool _return = false;
    return _return;
  }
  bool havePermission(const ControllerID /* c */, const std::string& /* permission */) override {
    bool _return = false;
    return _return;
  }
  void relinquishPermissions(const ControllerID /* c */, const std::set<std::string> & /* permissions */) override {
    return;
  }
  void connect(const ControllerID /* c */, const std::string& /* hostName */) override {
    return;
  }
  void disconnect(const ControllerID /* c */) override {
    return;
  }
  void subscribeEventTypes(const ControllerID /* c */, const std::set<ControllerEventType::type> & /* types */) override {
    return;
  }
  void unsubscribeEventTypes(const ControllerID /* c */, const std::set<ControllerEventType::type> & /* types */) override {
    return;
  }
  void events(std::vector<ControllerEvent> & /* _return */, const ControllerID /* c */) override {
    return;
  }
  bool connected(const ControllerID /* c */) override {
    bool _return = false;
    return _return;
  }
  void connectedHostName(std::string& /* _return */, const ControllerID /* c */) override {
    return;
  }
  void softwareVersion(std::string& /* _return */, const ControllerID /* c */) override {
    return;
  }
  bool monitoring(const ControllerID /* c */) override {
    bool _return = false;
    return _return;
  }
  bool haveExclusiveControl(const ControllerID /* c */) override {
    bool _return = false;
    return _return;
  }
  OperationMode::type operationMode(const ControllerID /* c */) override {
    OperationMode::type _return = static_cast<OperationMode::type>(0);
    return _return;
  }
  ServoState::type servoState(const ControllerID /* c */) override {
    ServoState::type _return = static_cast<ServoState::type>(0);
    return _return;
  }
  PlaybackState::type playbackState(const ControllerID /* c */) override {
    PlaybackState::type _return = static_cast<PlaybackState::type>(0);
    return _return;
  }
  void run(const ControllerID /* c */) override {
    return;
  }
  void pause(const ControllerID /* c */) override {
    return;
  }
  void resume(const ControllerID /* c */) override {
    return;
  }
  void stop(const ControllerID /* c */) override {
    return;
  }
  void currentJob(std::string& /* _return */, const ControllerID /* c */) override {
    return;
  }
  void setCurrentJob(const ControllerID /* c */, const std::string& /* name */, const int32_t /* line */) override {
    return;
  }
  void defaultJob(std::string& /* _return */, const ControllerID /* c */) override {
    return;
  }
  bool jobExists(const ControllerID /* c */, const std::string& /* name */) override {
    bool _return = false;
    return _return;
  }
  void jobDetails(RobotJobInfo& /* _return */, const ControllerID /* c */, const std::string& /* name */) override {
    return;
  }
  void jobs(std::vector<std::string> & /* _return */, const ControllerID /* c */) override {
    return;
  }
  void jobsMatching(std::vector<std::string> & /* _return */, const ControllerID /* c */, const std::string& /* nameRegex */, const std::string& /* tag */) override {
    return;
  }
  void duplicateJob(const ControllerID /* c */, const std::string& /* existingName */, const std::string& /* newName */) override {
    return;
  }
  void deleteJob(const ControllerID /* c */, const std::string& /* name */) override {
    return;
  }
  void jobSource(std::string& /* _return */, const ControllerID /* c */, const std::string& /* name */) override {
    return;
  }
  void storeJobSource(const ControllerID /* c */, const std::string& /* name */, const std::string& /* programmingLanguage */, const std::string& /* sourceCode */) override {
    return;
  }
  void tools(std::map<ToolIndex, std::string> & /* _return */, const ControllerID /* c */) override {
    return;
  }
  void tool(Tool& /* _return */, const ControllerID /* c */, const ToolIndex /* index */) override {
    return;
  }
  int32_t inputNumber(const ControllerID /* c */, const std::string& /* name */) override {
    int32_t _return = 0;
    return _return;
  }
  int32_t inputGroupNumber(const ControllerID /* c */, const std::string& /* name */) override {
    int32_t _return = 0;
    return _return;
  }
  int32_t outputNumber(const ControllerID /* c */, const std::string& /* name */) override {
    int32_t _return = 0;
    return _return;
  }
  int32_t outputGroupNumber(const ControllerID /* c */, const std::string& /* name */) override {
    int32_t _return = 0;
    return _return;
  }
  void inputName(std::string& /* _return */, const ControllerID /* c */, const int32_t /* num */) override {
    return;
  }
  void outputName(std::string& /* _return */, const ControllerID /* c */, const int32_t /* num */) override {
    return;
  }
  void setInputName(const ControllerID /* c */, const int32_t /* num */, const std::string& /* name */) override {
    return;
  }
  void setOutputName(const ControllerID /* c */, const int32_t /* num */, const std::string& /* name */) override {
    return;
  }
  void monitorInput(const ControllerID /* c */, const int32_t /* num */) override {
    return;
  }
  void monitorInputGroups(const ControllerID /* c */, const int32_t /* groupNum */, const int32_t /* count */) override {
    return;
  }
  void monitorOutput(const ControllerID /* c */, const int32_t /* num */) override {
    return;
  }
  void monitorOutputGroups(const ControllerID /* c */, const int32_t /* groupNum */, const int32_t /* count */) override {
    return;
  }
  void unmonitorInput(const ControllerID /* c */, const int32_t /* num */) override {
    return;
  }
  void unmonitorInputGroups(const ControllerID /* c */, const int32_t /* groupNum */, const int32_t /* count */) override {
    return;
  }
  void unmonitorOutput(const ControllerID /* c */, const int32_t /* num */) override {
    return;
  }
  void unmonitorOutputGroups(const ControllerID /* c */, const int32_t /* groupNum */, const int32_t /* count */) override {
    return;
  }
  bool inputValue(const ControllerID /* c */, const int32_t /* num */) override {
    bool _return = false;
    return _return;
  }
  int32_t inputGroupsValue(const ControllerID /* c */, const int32_t /* groupNum */, const int32_t /* count */) override {
    int32_t _return = 0;
    return _return;
  }
  bool outputValue(const ControllerID /* c */, const int32_t /* num */) override {
    bool _return = false;
    return _return;
  }
  int32_t outputGroupsValue(const ControllerID /* c */, const int32_t /* groupNum */, const int32_t /* count */) override {
    int32_t _return = 0;
    return _return;
  }
  void setOutput(const ControllerID /* c */, const int32_t /* num */, const bool /* value */) override {
    return;
  }
  void setOutputGroups(const ControllerID /* c */, const int32_t /* groupNum */, const int32_t /* count */, const int32_t /* value */) override {
    return;
  }
  int32_t inputAddress(const ControllerID /* c */, const std::string& /* name */) override {
    int32_t _return = 0;
    return _return;
  }
  int32_t inputAddressByNumber(const ControllerID /* c */, const int32_t /* num */) override {
    int32_t _return = 0;
    return _return;
  }
  int32_t outputAddress(const ControllerID /* c */, const std::string& /* name */) override {
    int32_t _return = 0;
    return _return;
  }
  int32_t outputAddressByNumber(const ControllerID /* c */, const int32_t /* num */) override {
    int32_t _return = 0;
    return _return;
  }
  void monitorIOAddress(const ControllerID /* c */, const int32_t /* address */) override {
    return;
  }
  void unmonitorIOAddress(const ControllerID /* c */, const int32_t /* address */) override {
    return;
  }
  bool inputAddressValue(const ControllerID /* c */, const int32_t /* address */) override {
    bool _return = false;
    return _return;
  }
  bool outputAddressValue(const ControllerID /* c */, const int32_t /* address */) override {
    bool _return = false;
    return _return;
  }
  void setOutputAddress(const ControllerID /* c */, const int32_t /* address */, const bool /* value */) override {
    return;
  }
  int32_t fieldBusStatusInputGroup(const ControllerID /* c */, const std::string& /* busType */) override {
    int32_t _return = 0;
    return _return;
  }
  void controlGroups(std::vector<ControlGroup> & /* _return */, const ControllerID /* c */) override {
    return;
  }
  int8_t currentControlGroup(const ControllerID /* c */) override {
    int8_t _return = 0;
    return _return;
  }
  int8_t robotCount(const ControllerID /* c */) override {
    int8_t _return = 0;
    return _return;
  }
  RobotIndex currentRobot(const ControllerID /* c */) override {
    RobotIndex _return = 0;
    return _return;
  }
  void variable(Any& /* _return */, const ControllerID /* c */, const std::string& /* name */) override {
    return;
  }
  void variableByAddr(Any& /* _return */, const ControllerID /* c */, const VariableAddress& /* addr */) override {
    return;
  }
  void setVariable(const ControllerID /* c */, const std::string& /* name */, const Any& /* value */) override {
    return;
  }
  void setVariableByAddr(const ControllerID /* c */, const VariableAddress& /* addr */, const Any& /* value */) override {
    return;
  }
  void variableAddrByNameAndSpace(VariableAddress& /* _return */, const ControllerID /* c */, const std::string& /* name */, const AddressSpace::type /* space */) override {
    return;
  }
  void variableAddrByName(VariableAddress& /* _return */, const ControllerID /* c */, const std::string& /* name */) override {
    return;
  }
  void setVariableName(const ControllerID /* c */, const VariableAddress& /* addr */, const std::string& /* name */) override {
    return;
  }
  void zone(Zone& /* _return */, const ControllerID /* c */, const ZoneIndex /* index */) override {
    return;
  }
  ZoneIndex newZone(const ControllerID /* c */) override {
    ZoneIndex _return = 0;
    return _return;
  }
  void modifyZone(const ControllerID /* c */, const ZoneIndex /* index */, const Zone& /* z */) override {
    return;
  }
  void deleteZone(const ControllerID /* c */, const ZoneIndex /* index */) override {
    return;
  }
  void userFrames(std::map<UserFrameIndex, std::string> & /* _return */, const ControllerID /* c */) override {
    return;
  }
  void userFrame(CoordinateFrame& /* _return */, const ControllerID /* c */, const UserFrameIndex /* index */) override {
    return;
  }
  UserFrameIndex newUserFrame(const ControllerID /* c */) override {
    UserFrameIndex _return = 0;
    return _return;
  }
  void setUserFrame(const ControllerID /* c */, const UserFrameIndex /* index */, const CoordinateFrame& /* f */) override {
    return;
  }
  void deleteUserFrame(const ControllerID /* c */, const UserFrameIndex /* index */) override {
    return;
  }
  void networkInterfaceAddress(std::string& /* _return */, const ControllerID /* c */, const std::string& /* controllerInterface */) override {
    return;
  }
  int32_t requestNetworkAccess(const ControllerID /* c */, const std::string& /* controllerInterface */, const int32_t /* port */, const std::string& /* protocol */) override {
    int32_t _return = 0;
    return _return;
  }
  void removeNetworkAccess(const ControllerID /* c */, const int32_t /* accessHandle */) override {
    return;
  }
  int32_t requestNetworkService(const ControllerID /* c */, const std::string& /* controllerInterface */, const int32_t /* port */, const std::string& /* protocol */) override {
    int32_t _return = 0;
    return _return;
  }
  void removeNetworkService(const ControllerID /* c */, const int32_t /* accessHandle */) override {
    return;
  }
};

typedef struct _Controller_requestPermissions_args__isset {
  _Controller_requestPermissions_args__isset() : c(false), permissions(false) {}
  bool c :1;
  bool permissions :1;
} _Controller_requestPermissions_args__isset;

class Controller_requestPermissions_args {
 public:

  Controller_requestPermissions_args(const Controller_requestPermissions_args&);
  Controller_requestPermissions_args& operator=(const Controller_requestPermissions_args&);
  Controller_requestPermissions_args() noexcept
                                     : c(0) {
  }

  virtual ~Controller_requestPermissions_args() noexcept;
  ControllerID c;
  std::set<std::string>  permissions;

  _Controller_requestPermissions_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_permissions(const std::set<std::string> & val);

  bool operator == (const Controller_requestPermissions_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(permissions == rhs.permissions))
      return false;
    return true;
  }
  bool operator != (const Controller_requestPermissions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_requestPermissions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_requestPermissions_pargs {
 public:


  virtual ~Controller_requestPermissions_pargs() noexcept;
  const ControllerID* c;
  const std::set<std::string> * permissions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_requestPermissions_result__isset {
  _Controller_requestPermissions_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_requestPermissions_result__isset;

class Controller_requestPermissions_result {
 public:

  Controller_requestPermissions_result(const Controller_requestPermissions_result&);
  Controller_requestPermissions_result& operator=(const Controller_requestPermissions_result&);
  Controller_requestPermissions_result() noexcept
                                       : success(0) {
  }

  virtual ~Controller_requestPermissions_result() noexcept;
  bool success;
  IllegalArgument e;

  _Controller_requestPermissions_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_requestPermissions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_requestPermissions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_requestPermissions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_requestPermissions_presult__isset {
  _Controller_requestPermissions_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_requestPermissions_presult__isset;

class Controller_requestPermissions_presult {
 public:


  virtual ~Controller_requestPermissions_presult() noexcept;
  bool* success;
  IllegalArgument e;

  _Controller_requestPermissions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_havePermission_args__isset {
  _Controller_havePermission_args__isset() : c(false), permission(false) {}
  bool c :1;
  bool permission :1;
} _Controller_havePermission_args__isset;

class Controller_havePermission_args {
 public:

  Controller_havePermission_args(const Controller_havePermission_args&);
  Controller_havePermission_args& operator=(const Controller_havePermission_args&);
  Controller_havePermission_args() noexcept
                                 : c(0),
                                   permission() {
  }

  virtual ~Controller_havePermission_args() noexcept;
  ControllerID c;
  std::string permission;

  _Controller_havePermission_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_permission(const std::string& val);

  bool operator == (const Controller_havePermission_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(permission == rhs.permission))
      return false;
    return true;
  }
  bool operator != (const Controller_havePermission_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_havePermission_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_havePermission_pargs {
 public:


  virtual ~Controller_havePermission_pargs() noexcept;
  const ControllerID* c;
  const std::string* permission;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_havePermission_result__isset {
  _Controller_havePermission_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_havePermission_result__isset;

class Controller_havePermission_result {
 public:

  Controller_havePermission_result(const Controller_havePermission_result&);
  Controller_havePermission_result& operator=(const Controller_havePermission_result&);
  Controller_havePermission_result() noexcept
                                   : success(0) {
  }

  virtual ~Controller_havePermission_result() noexcept;
  bool success;
  IllegalArgument e;

  _Controller_havePermission_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_havePermission_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_havePermission_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_havePermission_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_havePermission_presult__isset {
  _Controller_havePermission_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_havePermission_presult__isset;

class Controller_havePermission_presult {
 public:


  virtual ~Controller_havePermission_presult() noexcept;
  bool* success;
  IllegalArgument e;

  _Controller_havePermission_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_relinquishPermissions_args__isset {
  _Controller_relinquishPermissions_args__isset() : c(false), permissions(false) {}
  bool c :1;
  bool permissions :1;
} _Controller_relinquishPermissions_args__isset;

class Controller_relinquishPermissions_args {
 public:

  Controller_relinquishPermissions_args(const Controller_relinquishPermissions_args&);
  Controller_relinquishPermissions_args& operator=(const Controller_relinquishPermissions_args&);
  Controller_relinquishPermissions_args() noexcept
                                        : c(0) {
  }

  virtual ~Controller_relinquishPermissions_args() noexcept;
  ControllerID c;
  std::set<std::string>  permissions;

  _Controller_relinquishPermissions_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_permissions(const std::set<std::string> & val);

  bool operator == (const Controller_relinquishPermissions_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(permissions == rhs.permissions))
      return false;
    return true;
  }
  bool operator != (const Controller_relinquishPermissions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_relinquishPermissions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_relinquishPermissions_pargs {
 public:


  virtual ~Controller_relinquishPermissions_pargs() noexcept;
  const ControllerID* c;
  const std::set<std::string> * permissions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_relinquishPermissions_result {
 public:

  Controller_relinquishPermissions_result(const Controller_relinquishPermissions_result&) noexcept;
  Controller_relinquishPermissions_result& operator=(const Controller_relinquishPermissions_result&) noexcept;
  Controller_relinquishPermissions_result() noexcept {
  }

  virtual ~Controller_relinquishPermissions_result() noexcept;

  bool operator == (const Controller_relinquishPermissions_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_relinquishPermissions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_relinquishPermissions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_relinquishPermissions_presult {
 public:


  virtual ~Controller_relinquishPermissions_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_connect_args__isset {
  _Controller_connect_args__isset() : c(false), hostName(false) {}
  bool c :1;
  bool hostName :1;
} _Controller_connect_args__isset;

class Controller_connect_args {
 public:

  Controller_connect_args(const Controller_connect_args&);
  Controller_connect_args& operator=(const Controller_connect_args&);
  Controller_connect_args() noexcept
                          : c(0),
                            hostName() {
  }

  virtual ~Controller_connect_args() noexcept;
  ControllerID c;
  std::string hostName;

  _Controller_connect_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_hostName(const std::string& val);

  bool operator == (const Controller_connect_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(hostName == rhs.hostName))
      return false;
    return true;
  }
  bool operator != (const Controller_connect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_connect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_connect_pargs {
 public:


  virtual ~Controller_connect_pargs() noexcept;
  const ControllerID* c;
  const std::string* hostName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_connect_result {
 public:

  Controller_connect_result(const Controller_connect_result&) noexcept;
  Controller_connect_result& operator=(const Controller_connect_result&) noexcept;
  Controller_connect_result() noexcept {
  }

  virtual ~Controller_connect_result() noexcept;

  bool operator == (const Controller_connect_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_connect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_connect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_connect_presult {
 public:


  virtual ~Controller_connect_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_disconnect_args__isset {
  _Controller_disconnect_args__isset() : c(false) {}
  bool c :1;
} _Controller_disconnect_args__isset;

class Controller_disconnect_args {
 public:

  Controller_disconnect_args(const Controller_disconnect_args&) noexcept;
  Controller_disconnect_args& operator=(const Controller_disconnect_args&) noexcept;
  Controller_disconnect_args() noexcept
                             : c(0) {
  }

  virtual ~Controller_disconnect_args() noexcept;
  ControllerID c;

  _Controller_disconnect_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_disconnect_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_disconnect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_disconnect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_disconnect_pargs {
 public:


  virtual ~Controller_disconnect_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_disconnect_result {
 public:

  Controller_disconnect_result(const Controller_disconnect_result&) noexcept;
  Controller_disconnect_result& operator=(const Controller_disconnect_result&) noexcept;
  Controller_disconnect_result() noexcept {
  }

  virtual ~Controller_disconnect_result() noexcept;

  bool operator == (const Controller_disconnect_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_disconnect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_disconnect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_disconnect_presult {
 public:


  virtual ~Controller_disconnect_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_subscribeEventTypes_args__isset {
  _Controller_subscribeEventTypes_args__isset() : c(false), types(false) {}
  bool c :1;
  bool types :1;
} _Controller_subscribeEventTypes_args__isset;

class Controller_subscribeEventTypes_args {
 public:

  Controller_subscribeEventTypes_args(const Controller_subscribeEventTypes_args&);
  Controller_subscribeEventTypes_args& operator=(const Controller_subscribeEventTypes_args&);
  Controller_subscribeEventTypes_args() noexcept
                                      : c(0) {
  }

  virtual ~Controller_subscribeEventTypes_args() noexcept;
  ControllerID c;
  std::set<ControllerEventType::type>  types;

  _Controller_subscribeEventTypes_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_types(const std::set<ControllerEventType::type> & val);

  bool operator == (const Controller_subscribeEventTypes_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const Controller_subscribeEventTypes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_subscribeEventTypes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_subscribeEventTypes_pargs {
 public:


  virtual ~Controller_subscribeEventTypes_pargs() noexcept;
  const ControllerID* c;
  const std::set<ControllerEventType::type> * types;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_subscribeEventTypes_result {
 public:

  Controller_subscribeEventTypes_result(const Controller_subscribeEventTypes_result&) noexcept;
  Controller_subscribeEventTypes_result& operator=(const Controller_subscribeEventTypes_result&) noexcept;
  Controller_subscribeEventTypes_result() noexcept {
  }

  virtual ~Controller_subscribeEventTypes_result() noexcept;

  bool operator == (const Controller_subscribeEventTypes_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_subscribeEventTypes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_subscribeEventTypes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_subscribeEventTypes_presult {
 public:


  virtual ~Controller_subscribeEventTypes_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_unsubscribeEventTypes_args__isset {
  _Controller_unsubscribeEventTypes_args__isset() : c(false), types(false) {}
  bool c :1;
  bool types :1;
} _Controller_unsubscribeEventTypes_args__isset;

class Controller_unsubscribeEventTypes_args {
 public:

  Controller_unsubscribeEventTypes_args(const Controller_unsubscribeEventTypes_args&);
  Controller_unsubscribeEventTypes_args& operator=(const Controller_unsubscribeEventTypes_args&);
  Controller_unsubscribeEventTypes_args() noexcept
                                        : c(0) {
  }

  virtual ~Controller_unsubscribeEventTypes_args() noexcept;
  ControllerID c;
  std::set<ControllerEventType::type>  types;

  _Controller_unsubscribeEventTypes_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_types(const std::set<ControllerEventType::type> & val);

  bool operator == (const Controller_unsubscribeEventTypes_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const Controller_unsubscribeEventTypes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unsubscribeEventTypes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unsubscribeEventTypes_pargs {
 public:


  virtual ~Controller_unsubscribeEventTypes_pargs() noexcept;
  const ControllerID* c;
  const std::set<ControllerEventType::type> * types;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unsubscribeEventTypes_result {
 public:

  Controller_unsubscribeEventTypes_result(const Controller_unsubscribeEventTypes_result&) noexcept;
  Controller_unsubscribeEventTypes_result& operator=(const Controller_unsubscribeEventTypes_result&) noexcept;
  Controller_unsubscribeEventTypes_result() noexcept {
  }

  virtual ~Controller_unsubscribeEventTypes_result() noexcept;

  bool operator == (const Controller_unsubscribeEventTypes_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_unsubscribeEventTypes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unsubscribeEventTypes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unsubscribeEventTypes_presult {
 public:


  virtual ~Controller_unsubscribeEventTypes_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_events_args__isset {
  _Controller_events_args__isset() : c(false) {}
  bool c :1;
} _Controller_events_args__isset;

class Controller_events_args {
 public:

  Controller_events_args(const Controller_events_args&) noexcept;
  Controller_events_args& operator=(const Controller_events_args&) noexcept;
  Controller_events_args() noexcept
                         : c(0) {
  }

  virtual ~Controller_events_args() noexcept;
  ControllerID c;

  _Controller_events_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_events_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_events_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_events_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_events_pargs {
 public:


  virtual ~Controller_events_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_events_result__isset {
  _Controller_events_result__isset() : success(false) {}
  bool success :1;
} _Controller_events_result__isset;

class Controller_events_result {
 public:

  Controller_events_result(const Controller_events_result&);
  Controller_events_result& operator=(const Controller_events_result&);
  Controller_events_result() noexcept {
  }

  virtual ~Controller_events_result() noexcept;
  std::vector<ControllerEvent>  success;

  _Controller_events_result__isset __isset;

  void __set_success(const std::vector<ControllerEvent> & val);

  bool operator == (const Controller_events_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_events_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_events_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_events_presult__isset {
  _Controller_events_presult__isset() : success(false) {}
  bool success :1;
} _Controller_events_presult__isset;

class Controller_events_presult {
 public:


  virtual ~Controller_events_presult() noexcept;
  std::vector<ControllerEvent> * success;

  _Controller_events_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_connected_args__isset {
  _Controller_connected_args__isset() : c(false) {}
  bool c :1;
} _Controller_connected_args__isset;

class Controller_connected_args {
 public:

  Controller_connected_args(const Controller_connected_args&) noexcept;
  Controller_connected_args& operator=(const Controller_connected_args&) noexcept;
  Controller_connected_args() noexcept
                            : c(0) {
  }

  virtual ~Controller_connected_args() noexcept;
  ControllerID c;

  _Controller_connected_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_connected_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_connected_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_connected_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_connected_pargs {
 public:


  virtual ~Controller_connected_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_connected_result__isset {
  _Controller_connected_result__isset() : success(false) {}
  bool success :1;
} _Controller_connected_result__isset;

class Controller_connected_result {
 public:

  Controller_connected_result(const Controller_connected_result&) noexcept;
  Controller_connected_result& operator=(const Controller_connected_result&) noexcept;
  Controller_connected_result() noexcept
                              : success(0) {
  }

  virtual ~Controller_connected_result() noexcept;
  bool success;

  _Controller_connected_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Controller_connected_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_connected_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_connected_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_connected_presult__isset {
  _Controller_connected_presult__isset() : success(false) {}
  bool success :1;
} _Controller_connected_presult__isset;

class Controller_connected_presult {
 public:


  virtual ~Controller_connected_presult() noexcept;
  bool* success;

  _Controller_connected_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_connectedHostName_args__isset {
  _Controller_connectedHostName_args__isset() : c(false) {}
  bool c :1;
} _Controller_connectedHostName_args__isset;

class Controller_connectedHostName_args {
 public:

  Controller_connectedHostName_args(const Controller_connectedHostName_args&) noexcept;
  Controller_connectedHostName_args& operator=(const Controller_connectedHostName_args&) noexcept;
  Controller_connectedHostName_args() noexcept
                                    : c(0) {
  }

  virtual ~Controller_connectedHostName_args() noexcept;
  ControllerID c;

  _Controller_connectedHostName_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_connectedHostName_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_connectedHostName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_connectedHostName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_connectedHostName_pargs {
 public:


  virtual ~Controller_connectedHostName_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_connectedHostName_result__isset {
  _Controller_connectedHostName_result__isset() : success(false) {}
  bool success :1;
} _Controller_connectedHostName_result__isset;

class Controller_connectedHostName_result {
 public:

  Controller_connectedHostName_result(const Controller_connectedHostName_result&);
  Controller_connectedHostName_result& operator=(const Controller_connectedHostName_result&);
  Controller_connectedHostName_result() noexcept
                                      : success() {
  }

  virtual ~Controller_connectedHostName_result() noexcept;
  std::string success;

  _Controller_connectedHostName_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Controller_connectedHostName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_connectedHostName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_connectedHostName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_connectedHostName_presult__isset {
  _Controller_connectedHostName_presult__isset() : success(false) {}
  bool success :1;
} _Controller_connectedHostName_presult__isset;

class Controller_connectedHostName_presult {
 public:


  virtual ~Controller_connectedHostName_presult() noexcept;
  std::string* success;

  _Controller_connectedHostName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_softwareVersion_args__isset {
  _Controller_softwareVersion_args__isset() : c(false) {}
  bool c :1;
} _Controller_softwareVersion_args__isset;

class Controller_softwareVersion_args {
 public:

  Controller_softwareVersion_args(const Controller_softwareVersion_args&) noexcept;
  Controller_softwareVersion_args& operator=(const Controller_softwareVersion_args&) noexcept;
  Controller_softwareVersion_args() noexcept
                                  : c(0) {
  }

  virtual ~Controller_softwareVersion_args() noexcept;
  ControllerID c;

  _Controller_softwareVersion_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_softwareVersion_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_softwareVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_softwareVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_softwareVersion_pargs {
 public:


  virtual ~Controller_softwareVersion_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_softwareVersion_result__isset {
  _Controller_softwareVersion_result__isset() : success(false) {}
  bool success :1;
} _Controller_softwareVersion_result__isset;

class Controller_softwareVersion_result {
 public:

  Controller_softwareVersion_result(const Controller_softwareVersion_result&);
  Controller_softwareVersion_result& operator=(const Controller_softwareVersion_result&);
  Controller_softwareVersion_result() noexcept
                                    : success() {
  }

  virtual ~Controller_softwareVersion_result() noexcept;
  std::string success;

  _Controller_softwareVersion_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Controller_softwareVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_softwareVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_softwareVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_softwareVersion_presult__isset {
  _Controller_softwareVersion_presult__isset() : success(false) {}
  bool success :1;
} _Controller_softwareVersion_presult__isset;

class Controller_softwareVersion_presult {
 public:


  virtual ~Controller_softwareVersion_presult() noexcept;
  std::string* success;

  _Controller_softwareVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_monitoring_args__isset {
  _Controller_monitoring_args__isset() : c(false) {}
  bool c :1;
} _Controller_monitoring_args__isset;

class Controller_monitoring_args {
 public:

  Controller_monitoring_args(const Controller_monitoring_args&) noexcept;
  Controller_monitoring_args& operator=(const Controller_monitoring_args&) noexcept;
  Controller_monitoring_args() noexcept
                             : c(0) {
  }

  virtual ~Controller_monitoring_args() noexcept;
  ControllerID c;

  _Controller_monitoring_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_monitoring_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_monitoring_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitoring_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_monitoring_pargs {
 public:


  virtual ~Controller_monitoring_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitoring_result__isset {
  _Controller_monitoring_result__isset() : success(false) {}
  bool success :1;
} _Controller_monitoring_result__isset;

class Controller_monitoring_result {
 public:

  Controller_monitoring_result(const Controller_monitoring_result&) noexcept;
  Controller_monitoring_result& operator=(const Controller_monitoring_result&) noexcept;
  Controller_monitoring_result() noexcept
                               : success(0) {
  }

  virtual ~Controller_monitoring_result() noexcept;
  bool success;

  _Controller_monitoring_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Controller_monitoring_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_monitoring_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitoring_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitoring_presult__isset {
  _Controller_monitoring_presult__isset() : success(false) {}
  bool success :1;
} _Controller_monitoring_presult__isset;

class Controller_monitoring_presult {
 public:


  virtual ~Controller_monitoring_presult() noexcept;
  bool* success;

  _Controller_monitoring_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_haveExclusiveControl_args__isset {
  _Controller_haveExclusiveControl_args__isset() : c(false) {}
  bool c :1;
} _Controller_haveExclusiveControl_args__isset;

class Controller_haveExclusiveControl_args {
 public:

  Controller_haveExclusiveControl_args(const Controller_haveExclusiveControl_args&) noexcept;
  Controller_haveExclusiveControl_args& operator=(const Controller_haveExclusiveControl_args&) noexcept;
  Controller_haveExclusiveControl_args() noexcept
                                       : c(0) {
  }

  virtual ~Controller_haveExclusiveControl_args() noexcept;
  ControllerID c;

  _Controller_haveExclusiveControl_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_haveExclusiveControl_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_haveExclusiveControl_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_haveExclusiveControl_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_haveExclusiveControl_pargs {
 public:


  virtual ~Controller_haveExclusiveControl_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_haveExclusiveControl_result__isset {
  _Controller_haveExclusiveControl_result__isset() : success(false) {}
  bool success :1;
} _Controller_haveExclusiveControl_result__isset;

class Controller_haveExclusiveControl_result {
 public:

  Controller_haveExclusiveControl_result(const Controller_haveExclusiveControl_result&) noexcept;
  Controller_haveExclusiveControl_result& operator=(const Controller_haveExclusiveControl_result&) noexcept;
  Controller_haveExclusiveControl_result() noexcept
                                         : success(0) {
  }

  virtual ~Controller_haveExclusiveControl_result() noexcept;
  bool success;

  _Controller_haveExclusiveControl_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Controller_haveExclusiveControl_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_haveExclusiveControl_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_haveExclusiveControl_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_haveExclusiveControl_presult__isset {
  _Controller_haveExclusiveControl_presult__isset() : success(false) {}
  bool success :1;
} _Controller_haveExclusiveControl_presult__isset;

class Controller_haveExclusiveControl_presult {
 public:


  virtual ~Controller_haveExclusiveControl_presult() noexcept;
  bool* success;

  _Controller_haveExclusiveControl_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_operationMode_args__isset {
  _Controller_operationMode_args__isset() : c(false) {}
  bool c :1;
} _Controller_operationMode_args__isset;

class Controller_operationMode_args {
 public:

  Controller_operationMode_args(const Controller_operationMode_args&) noexcept;
  Controller_operationMode_args& operator=(const Controller_operationMode_args&) noexcept;
  Controller_operationMode_args() noexcept
                                : c(0) {
  }

  virtual ~Controller_operationMode_args() noexcept;
  ControllerID c;

  _Controller_operationMode_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_operationMode_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_operationMode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_operationMode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_operationMode_pargs {
 public:


  virtual ~Controller_operationMode_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_operationMode_result__isset {
  _Controller_operationMode_result__isset() : success(false) {}
  bool success :1;
} _Controller_operationMode_result__isset;

class Controller_operationMode_result {
 public:

  Controller_operationMode_result(const Controller_operationMode_result&) noexcept;
  Controller_operationMode_result& operator=(const Controller_operationMode_result&) noexcept;
  Controller_operationMode_result() noexcept
                                  : success(static_cast<OperationMode::type>(0)) {
  }

  virtual ~Controller_operationMode_result() noexcept;
  /**
   * 
   * @see OperationMode
   */
  OperationMode::type success;

  _Controller_operationMode_result__isset __isset;

  void __set_success(const OperationMode::type val);

  bool operator == (const Controller_operationMode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_operationMode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_operationMode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_operationMode_presult__isset {
  _Controller_operationMode_presult__isset() : success(false) {}
  bool success :1;
} _Controller_operationMode_presult__isset;

class Controller_operationMode_presult {
 public:


  virtual ~Controller_operationMode_presult() noexcept;
  /**
   * 
   * @see OperationMode
   */
  OperationMode::type* success;

  _Controller_operationMode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_servoState_args__isset {
  _Controller_servoState_args__isset() : c(false) {}
  bool c :1;
} _Controller_servoState_args__isset;

class Controller_servoState_args {
 public:

  Controller_servoState_args(const Controller_servoState_args&) noexcept;
  Controller_servoState_args& operator=(const Controller_servoState_args&) noexcept;
  Controller_servoState_args() noexcept
                             : c(0) {
  }

  virtual ~Controller_servoState_args() noexcept;
  ControllerID c;

  _Controller_servoState_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_servoState_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_servoState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_servoState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_servoState_pargs {
 public:


  virtual ~Controller_servoState_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_servoState_result__isset {
  _Controller_servoState_result__isset() : success(false) {}
  bool success :1;
} _Controller_servoState_result__isset;

class Controller_servoState_result {
 public:

  Controller_servoState_result(const Controller_servoState_result&) noexcept;
  Controller_servoState_result& operator=(const Controller_servoState_result&) noexcept;
  Controller_servoState_result() noexcept
                               : success(static_cast<ServoState::type>(0)) {
  }

  virtual ~Controller_servoState_result() noexcept;
  /**
   * 
   * @see ServoState
   */
  ServoState::type success;

  _Controller_servoState_result__isset __isset;

  void __set_success(const ServoState::type val);

  bool operator == (const Controller_servoState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_servoState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_servoState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_servoState_presult__isset {
  _Controller_servoState_presult__isset() : success(false) {}
  bool success :1;
} _Controller_servoState_presult__isset;

class Controller_servoState_presult {
 public:


  virtual ~Controller_servoState_presult() noexcept;
  /**
   * 
   * @see ServoState
   */
  ServoState::type* success;

  _Controller_servoState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_playbackState_args__isset {
  _Controller_playbackState_args__isset() : c(false) {}
  bool c :1;
} _Controller_playbackState_args__isset;

class Controller_playbackState_args {
 public:

  Controller_playbackState_args(const Controller_playbackState_args&) noexcept;
  Controller_playbackState_args& operator=(const Controller_playbackState_args&) noexcept;
  Controller_playbackState_args() noexcept
                                : c(0) {
  }

  virtual ~Controller_playbackState_args() noexcept;
  ControllerID c;

  _Controller_playbackState_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_playbackState_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_playbackState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_playbackState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_playbackState_pargs {
 public:


  virtual ~Controller_playbackState_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_playbackState_result__isset {
  _Controller_playbackState_result__isset() : success(false) {}
  bool success :1;
} _Controller_playbackState_result__isset;

class Controller_playbackState_result {
 public:

  Controller_playbackState_result(const Controller_playbackState_result&) noexcept;
  Controller_playbackState_result& operator=(const Controller_playbackState_result&) noexcept;
  Controller_playbackState_result() noexcept
                                  : success(static_cast<PlaybackState::type>(0)) {
  }

  virtual ~Controller_playbackState_result() noexcept;
  /**
   * 
   * @see PlaybackState
   */
  PlaybackState::type success;

  _Controller_playbackState_result__isset __isset;

  void __set_success(const PlaybackState::type val);

  bool operator == (const Controller_playbackState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_playbackState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_playbackState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_playbackState_presult__isset {
  _Controller_playbackState_presult__isset() : success(false) {}
  bool success :1;
} _Controller_playbackState_presult__isset;

class Controller_playbackState_presult {
 public:


  virtual ~Controller_playbackState_presult() noexcept;
  /**
   * 
   * @see PlaybackState
   */
  PlaybackState::type* success;

  _Controller_playbackState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_run_args__isset {
  _Controller_run_args__isset() : c(false) {}
  bool c :1;
} _Controller_run_args__isset;

class Controller_run_args {
 public:

  Controller_run_args(const Controller_run_args&) noexcept;
  Controller_run_args& operator=(const Controller_run_args&) noexcept;
  Controller_run_args() noexcept
                      : c(0) {
  }

  virtual ~Controller_run_args() noexcept;
  ControllerID c;

  _Controller_run_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_run_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_run_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_run_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_run_pargs {
 public:


  virtual ~Controller_run_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_run_result {
 public:

  Controller_run_result(const Controller_run_result&) noexcept;
  Controller_run_result& operator=(const Controller_run_result&) noexcept;
  Controller_run_result() noexcept {
  }

  virtual ~Controller_run_result() noexcept;

  bool operator == (const Controller_run_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_run_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_run_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_run_presult {
 public:


  virtual ~Controller_run_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_pause_args__isset {
  _Controller_pause_args__isset() : c(false) {}
  bool c :1;
} _Controller_pause_args__isset;

class Controller_pause_args {
 public:

  Controller_pause_args(const Controller_pause_args&) noexcept;
  Controller_pause_args& operator=(const Controller_pause_args&) noexcept;
  Controller_pause_args() noexcept
                        : c(0) {
  }

  virtual ~Controller_pause_args() noexcept;
  ControllerID c;

  _Controller_pause_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_pause_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_pause_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_pause_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_pause_pargs {
 public:


  virtual ~Controller_pause_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_pause_result {
 public:

  Controller_pause_result(const Controller_pause_result&) noexcept;
  Controller_pause_result& operator=(const Controller_pause_result&) noexcept;
  Controller_pause_result() noexcept {
  }

  virtual ~Controller_pause_result() noexcept;

  bool operator == (const Controller_pause_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_pause_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_pause_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_pause_presult {
 public:


  virtual ~Controller_pause_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_resume_args__isset {
  _Controller_resume_args__isset() : c(false) {}
  bool c :1;
} _Controller_resume_args__isset;

class Controller_resume_args {
 public:

  Controller_resume_args(const Controller_resume_args&) noexcept;
  Controller_resume_args& operator=(const Controller_resume_args&) noexcept;
  Controller_resume_args() noexcept
                         : c(0) {
  }

  virtual ~Controller_resume_args() noexcept;
  ControllerID c;

  _Controller_resume_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_resume_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_resume_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_resume_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_resume_pargs {
 public:


  virtual ~Controller_resume_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_resume_result {
 public:

  Controller_resume_result(const Controller_resume_result&) noexcept;
  Controller_resume_result& operator=(const Controller_resume_result&) noexcept;
  Controller_resume_result() noexcept {
  }

  virtual ~Controller_resume_result() noexcept;

  bool operator == (const Controller_resume_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_resume_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_resume_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_resume_presult {
 public:


  virtual ~Controller_resume_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_stop_args__isset {
  _Controller_stop_args__isset() : c(false) {}
  bool c :1;
} _Controller_stop_args__isset;

class Controller_stop_args {
 public:

  Controller_stop_args(const Controller_stop_args&) noexcept;
  Controller_stop_args& operator=(const Controller_stop_args&) noexcept;
  Controller_stop_args() noexcept
                       : c(0) {
  }

  virtual ~Controller_stop_args() noexcept;
  ControllerID c;

  _Controller_stop_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_stop_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_stop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_stop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_stop_pargs {
 public:


  virtual ~Controller_stop_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_stop_result {
 public:

  Controller_stop_result(const Controller_stop_result&) noexcept;
  Controller_stop_result& operator=(const Controller_stop_result&) noexcept;
  Controller_stop_result() noexcept {
  }

  virtual ~Controller_stop_result() noexcept;

  bool operator == (const Controller_stop_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_stop_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_stop_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_stop_presult {
 public:


  virtual ~Controller_stop_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_currentJob_args__isset {
  _Controller_currentJob_args__isset() : c(false) {}
  bool c :1;
} _Controller_currentJob_args__isset;

class Controller_currentJob_args {
 public:

  Controller_currentJob_args(const Controller_currentJob_args&) noexcept;
  Controller_currentJob_args& operator=(const Controller_currentJob_args&) noexcept;
  Controller_currentJob_args() noexcept
                             : c(0) {
  }

  virtual ~Controller_currentJob_args() noexcept;
  ControllerID c;

  _Controller_currentJob_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_currentJob_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_currentJob_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_currentJob_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_currentJob_pargs {
 public:


  virtual ~Controller_currentJob_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_currentJob_result__isset {
  _Controller_currentJob_result__isset() : success(false) {}
  bool success :1;
} _Controller_currentJob_result__isset;

class Controller_currentJob_result {
 public:

  Controller_currentJob_result(const Controller_currentJob_result&);
  Controller_currentJob_result& operator=(const Controller_currentJob_result&);
  Controller_currentJob_result() noexcept
                               : success() {
  }

  virtual ~Controller_currentJob_result() noexcept;
  std::string success;

  _Controller_currentJob_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Controller_currentJob_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_currentJob_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_currentJob_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_currentJob_presult__isset {
  _Controller_currentJob_presult__isset() : success(false) {}
  bool success :1;
} _Controller_currentJob_presult__isset;

class Controller_currentJob_presult {
 public:


  virtual ~Controller_currentJob_presult() noexcept;
  std::string* success;

  _Controller_currentJob_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setCurrentJob_args__isset {
  _Controller_setCurrentJob_args__isset() : c(false), name(false), line(false) {}
  bool c :1;
  bool name :1;
  bool line :1;
} _Controller_setCurrentJob_args__isset;

class Controller_setCurrentJob_args {
 public:

  Controller_setCurrentJob_args(const Controller_setCurrentJob_args&);
  Controller_setCurrentJob_args& operator=(const Controller_setCurrentJob_args&);
  Controller_setCurrentJob_args() noexcept
                                : c(0),
                                  name(),
                                  line(0) {
  }

  virtual ~Controller_setCurrentJob_args() noexcept;
  ControllerID c;
  std::string name;
  int32_t line;

  _Controller_setCurrentJob_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  void __set_line(const int32_t val);

  bool operator == (const Controller_setCurrentJob_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(line == rhs.line))
      return false;
    return true;
  }
  bool operator != (const Controller_setCurrentJob_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setCurrentJob_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setCurrentJob_pargs {
 public:


  virtual ~Controller_setCurrentJob_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;
  const int32_t* line;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setCurrentJob_result__isset {
  _Controller_setCurrentJob_result__isset() : e(false) {}
  bool e :1;
} _Controller_setCurrentJob_result__isset;

class Controller_setCurrentJob_result {
 public:

  Controller_setCurrentJob_result(const Controller_setCurrentJob_result&);
  Controller_setCurrentJob_result& operator=(const Controller_setCurrentJob_result&);
  Controller_setCurrentJob_result() noexcept {
  }

  virtual ~Controller_setCurrentJob_result() noexcept;
  IllegalArgument e;

  _Controller_setCurrentJob_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_setCurrentJob_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_setCurrentJob_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setCurrentJob_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setCurrentJob_presult__isset {
  _Controller_setCurrentJob_presult__isset() : e(false) {}
  bool e :1;
} _Controller_setCurrentJob_presult__isset;

class Controller_setCurrentJob_presult {
 public:


  virtual ~Controller_setCurrentJob_presult() noexcept;
  IllegalArgument e;

  _Controller_setCurrentJob_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_defaultJob_args__isset {
  _Controller_defaultJob_args__isset() : c(false) {}
  bool c :1;
} _Controller_defaultJob_args__isset;

class Controller_defaultJob_args {
 public:

  Controller_defaultJob_args(const Controller_defaultJob_args&) noexcept;
  Controller_defaultJob_args& operator=(const Controller_defaultJob_args&) noexcept;
  Controller_defaultJob_args() noexcept
                             : c(0) {
  }

  virtual ~Controller_defaultJob_args() noexcept;
  ControllerID c;

  _Controller_defaultJob_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_defaultJob_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_defaultJob_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_defaultJob_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_defaultJob_pargs {
 public:


  virtual ~Controller_defaultJob_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_defaultJob_result__isset {
  _Controller_defaultJob_result__isset() : success(false) {}
  bool success :1;
} _Controller_defaultJob_result__isset;

class Controller_defaultJob_result {
 public:

  Controller_defaultJob_result(const Controller_defaultJob_result&);
  Controller_defaultJob_result& operator=(const Controller_defaultJob_result&);
  Controller_defaultJob_result() noexcept
                               : success() {
  }

  virtual ~Controller_defaultJob_result() noexcept;
  std::string success;

  _Controller_defaultJob_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Controller_defaultJob_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_defaultJob_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_defaultJob_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_defaultJob_presult__isset {
  _Controller_defaultJob_presult__isset() : success(false) {}
  bool success :1;
} _Controller_defaultJob_presult__isset;

class Controller_defaultJob_presult {
 public:


  virtual ~Controller_defaultJob_presult() noexcept;
  std::string* success;

  _Controller_defaultJob_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_jobExists_args__isset {
  _Controller_jobExists_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_jobExists_args__isset;

class Controller_jobExists_args {
 public:

  Controller_jobExists_args(const Controller_jobExists_args&);
  Controller_jobExists_args& operator=(const Controller_jobExists_args&);
  Controller_jobExists_args() noexcept
                            : c(0),
                              name() {
  }

  virtual ~Controller_jobExists_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_jobExists_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_jobExists_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_jobExists_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobExists_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_jobExists_pargs {
 public:


  virtual ~Controller_jobExists_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobExists_result__isset {
  _Controller_jobExists_result__isset() : success(false) {}
  bool success :1;
} _Controller_jobExists_result__isset;

class Controller_jobExists_result {
 public:

  Controller_jobExists_result(const Controller_jobExists_result&) noexcept;
  Controller_jobExists_result& operator=(const Controller_jobExists_result&) noexcept;
  Controller_jobExists_result() noexcept
                              : success(0) {
  }

  virtual ~Controller_jobExists_result() noexcept;
  bool success;

  _Controller_jobExists_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Controller_jobExists_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_jobExists_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobExists_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobExists_presult__isset {
  _Controller_jobExists_presult__isset() : success(false) {}
  bool success :1;
} _Controller_jobExists_presult__isset;

class Controller_jobExists_presult {
 public:


  virtual ~Controller_jobExists_presult() noexcept;
  bool* success;

  _Controller_jobExists_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_jobDetails_args__isset {
  _Controller_jobDetails_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_jobDetails_args__isset;

class Controller_jobDetails_args {
 public:

  Controller_jobDetails_args(const Controller_jobDetails_args&);
  Controller_jobDetails_args& operator=(const Controller_jobDetails_args&);
  Controller_jobDetails_args() noexcept
                             : c(0),
                               name() {
  }

  virtual ~Controller_jobDetails_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_jobDetails_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_jobDetails_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_jobDetails_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobDetails_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_jobDetails_pargs {
 public:


  virtual ~Controller_jobDetails_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobDetails_result__isset {
  _Controller_jobDetails_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_jobDetails_result__isset;

class Controller_jobDetails_result {
 public:

  Controller_jobDetails_result(const Controller_jobDetails_result&);
  Controller_jobDetails_result& operator=(const Controller_jobDetails_result&);
  Controller_jobDetails_result() noexcept {
  }

  virtual ~Controller_jobDetails_result() noexcept;
  RobotJobInfo success;
  IllegalArgument e;

  _Controller_jobDetails_result__isset __isset;

  void __set_success(const RobotJobInfo& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_jobDetails_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_jobDetails_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobDetails_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobDetails_presult__isset {
  _Controller_jobDetails_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_jobDetails_presult__isset;

class Controller_jobDetails_presult {
 public:


  virtual ~Controller_jobDetails_presult() noexcept;
  RobotJobInfo* success;
  IllegalArgument e;

  _Controller_jobDetails_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_jobs_args__isset {
  _Controller_jobs_args__isset() : c(false) {}
  bool c :1;
} _Controller_jobs_args__isset;

class Controller_jobs_args {
 public:

  Controller_jobs_args(const Controller_jobs_args&) noexcept;
  Controller_jobs_args& operator=(const Controller_jobs_args&) noexcept;
  Controller_jobs_args() noexcept
                       : c(0) {
  }

  virtual ~Controller_jobs_args() noexcept;
  ControllerID c;

  _Controller_jobs_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_jobs_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_jobs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_jobs_pargs {
 public:


  virtual ~Controller_jobs_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobs_result__isset {
  _Controller_jobs_result__isset() : success(false) {}
  bool success :1;
} _Controller_jobs_result__isset;

class Controller_jobs_result {
 public:

  Controller_jobs_result(const Controller_jobs_result&);
  Controller_jobs_result& operator=(const Controller_jobs_result&);
  Controller_jobs_result() noexcept {
  }

  virtual ~Controller_jobs_result() noexcept;
  std::vector<std::string>  success;

  _Controller_jobs_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  bool operator == (const Controller_jobs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_jobs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobs_presult__isset {
  _Controller_jobs_presult__isset() : success(false) {}
  bool success :1;
} _Controller_jobs_presult__isset;

class Controller_jobs_presult {
 public:


  virtual ~Controller_jobs_presult() noexcept;
  std::vector<std::string> * success;

  _Controller_jobs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_jobsMatching_args__isset {
  _Controller_jobsMatching_args__isset() : c(false), nameRegex(false), tag(false) {}
  bool c :1;
  bool nameRegex :1;
  bool tag :1;
} _Controller_jobsMatching_args__isset;

class Controller_jobsMatching_args {
 public:

  Controller_jobsMatching_args(const Controller_jobsMatching_args&);
  Controller_jobsMatching_args& operator=(const Controller_jobsMatching_args&);
  Controller_jobsMatching_args() noexcept
                               : c(0),
                                 nameRegex(),
                                 tag() {
  }

  virtual ~Controller_jobsMatching_args() noexcept;
  ControllerID c;
  std::string nameRegex;
  std::string tag;

  _Controller_jobsMatching_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_nameRegex(const std::string& val);

  void __set_tag(const std::string& val);

  bool operator == (const Controller_jobsMatching_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(nameRegex == rhs.nameRegex))
      return false;
    if (!(tag == rhs.tag))
      return false;
    return true;
  }
  bool operator != (const Controller_jobsMatching_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobsMatching_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_jobsMatching_pargs {
 public:


  virtual ~Controller_jobsMatching_pargs() noexcept;
  const ControllerID* c;
  const std::string* nameRegex;
  const std::string* tag;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobsMatching_result__isset {
  _Controller_jobsMatching_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_jobsMatching_result__isset;

class Controller_jobsMatching_result {
 public:

  Controller_jobsMatching_result(const Controller_jobsMatching_result&);
  Controller_jobsMatching_result& operator=(const Controller_jobsMatching_result&);
  Controller_jobsMatching_result() noexcept {
  }

  virtual ~Controller_jobsMatching_result() noexcept;
  std::vector<std::string>  success;
  IllegalArgument e;

  _Controller_jobsMatching_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_jobsMatching_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_jobsMatching_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobsMatching_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobsMatching_presult__isset {
  _Controller_jobsMatching_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_jobsMatching_presult__isset;

class Controller_jobsMatching_presult {
 public:


  virtual ~Controller_jobsMatching_presult() noexcept;
  std::vector<std::string> * success;
  IllegalArgument e;

  _Controller_jobsMatching_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_duplicateJob_args__isset {
  _Controller_duplicateJob_args__isset() : c(false), existingName(false), newName(false) {}
  bool c :1;
  bool existingName :1;
  bool newName :1;
} _Controller_duplicateJob_args__isset;

class Controller_duplicateJob_args {
 public:

  Controller_duplicateJob_args(const Controller_duplicateJob_args&);
  Controller_duplicateJob_args& operator=(const Controller_duplicateJob_args&);
  Controller_duplicateJob_args() noexcept
                               : c(0),
                                 existingName(),
                                 newName() {
  }

  virtual ~Controller_duplicateJob_args() noexcept;
  ControllerID c;
  std::string existingName;
  std::string newName;

  _Controller_duplicateJob_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_existingName(const std::string& val);

  void __set_newName(const std::string& val);

  bool operator == (const Controller_duplicateJob_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(existingName == rhs.existingName))
      return false;
    if (!(newName == rhs.newName))
      return false;
    return true;
  }
  bool operator != (const Controller_duplicateJob_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_duplicateJob_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_duplicateJob_pargs {
 public:


  virtual ~Controller_duplicateJob_pargs() noexcept;
  const ControllerID* c;
  const std::string* existingName;
  const std::string* newName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_duplicateJob_result__isset {
  _Controller_duplicateJob_result__isset() : e(false) {}
  bool e :1;
} _Controller_duplicateJob_result__isset;

class Controller_duplicateJob_result {
 public:

  Controller_duplicateJob_result(const Controller_duplicateJob_result&);
  Controller_duplicateJob_result& operator=(const Controller_duplicateJob_result&);
  Controller_duplicateJob_result() noexcept {
  }

  virtual ~Controller_duplicateJob_result() noexcept;
  IllegalArgument e;

  _Controller_duplicateJob_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_duplicateJob_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_duplicateJob_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_duplicateJob_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_duplicateJob_presult__isset {
  _Controller_duplicateJob_presult__isset() : e(false) {}
  bool e :1;
} _Controller_duplicateJob_presult__isset;

class Controller_duplicateJob_presult {
 public:


  virtual ~Controller_duplicateJob_presult() noexcept;
  IllegalArgument e;

  _Controller_duplicateJob_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_deleteJob_args__isset {
  _Controller_deleteJob_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_deleteJob_args__isset;

class Controller_deleteJob_args {
 public:

  Controller_deleteJob_args(const Controller_deleteJob_args&);
  Controller_deleteJob_args& operator=(const Controller_deleteJob_args&);
  Controller_deleteJob_args() noexcept
                            : c(0),
                              name() {
  }

  virtual ~Controller_deleteJob_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_deleteJob_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_deleteJob_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_deleteJob_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_deleteJob_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_deleteJob_pargs {
 public:


  virtual ~Controller_deleteJob_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_deleteJob_result__isset {
  _Controller_deleteJob_result__isset() : e(false) {}
  bool e :1;
} _Controller_deleteJob_result__isset;

class Controller_deleteJob_result {
 public:

  Controller_deleteJob_result(const Controller_deleteJob_result&);
  Controller_deleteJob_result& operator=(const Controller_deleteJob_result&);
  Controller_deleteJob_result() noexcept {
  }

  virtual ~Controller_deleteJob_result() noexcept;
  IllegalArgument e;

  _Controller_deleteJob_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_deleteJob_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_deleteJob_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_deleteJob_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_deleteJob_presult__isset {
  _Controller_deleteJob_presult__isset() : e(false) {}
  bool e :1;
} _Controller_deleteJob_presult__isset;

class Controller_deleteJob_presult {
 public:


  virtual ~Controller_deleteJob_presult() noexcept;
  IllegalArgument e;

  _Controller_deleteJob_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_jobSource_args__isset {
  _Controller_jobSource_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_jobSource_args__isset;

class Controller_jobSource_args {
 public:

  Controller_jobSource_args(const Controller_jobSource_args&);
  Controller_jobSource_args& operator=(const Controller_jobSource_args&);
  Controller_jobSource_args() noexcept
                            : c(0),
                              name() {
  }

  virtual ~Controller_jobSource_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_jobSource_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_jobSource_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_jobSource_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobSource_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_jobSource_pargs {
 public:


  virtual ~Controller_jobSource_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobSource_result__isset {
  _Controller_jobSource_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_jobSource_result__isset;

class Controller_jobSource_result {
 public:

  Controller_jobSource_result(const Controller_jobSource_result&);
  Controller_jobSource_result& operator=(const Controller_jobSource_result&);
  Controller_jobSource_result() noexcept
                              : success() {
  }

  virtual ~Controller_jobSource_result() noexcept;
  std::string success;
  IllegalArgument e;

  _Controller_jobSource_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_jobSource_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_jobSource_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_jobSource_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_jobSource_presult__isset {
  _Controller_jobSource_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_jobSource_presult__isset;

class Controller_jobSource_presult {
 public:


  virtual ~Controller_jobSource_presult() noexcept;
  std::string* success;
  IllegalArgument e;

  _Controller_jobSource_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_storeJobSource_args__isset {
  _Controller_storeJobSource_args__isset() : c(false), name(false), programmingLanguage(false), sourceCode(false) {}
  bool c :1;
  bool name :1;
  bool programmingLanguage :1;
  bool sourceCode :1;
} _Controller_storeJobSource_args__isset;

class Controller_storeJobSource_args {
 public:

  Controller_storeJobSource_args(const Controller_storeJobSource_args&);
  Controller_storeJobSource_args& operator=(const Controller_storeJobSource_args&);
  Controller_storeJobSource_args() noexcept
                                 : c(0),
                                   name(),
                                   programmingLanguage(),
                                   sourceCode() {
  }

  virtual ~Controller_storeJobSource_args() noexcept;
  ControllerID c;
  std::string name;
  std::string programmingLanguage;
  std::string sourceCode;

  _Controller_storeJobSource_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  void __set_programmingLanguage(const std::string& val);

  void __set_sourceCode(const std::string& val);

  bool operator == (const Controller_storeJobSource_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(programmingLanguage == rhs.programmingLanguage))
      return false;
    if (!(sourceCode == rhs.sourceCode))
      return false;
    return true;
  }
  bool operator != (const Controller_storeJobSource_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_storeJobSource_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_storeJobSource_pargs {
 public:


  virtual ~Controller_storeJobSource_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;
  const std::string* programmingLanguage;
  const std::string* sourceCode;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_storeJobSource_result__isset {
  _Controller_storeJobSource_result__isset() : e(false) {}
  bool e :1;
} _Controller_storeJobSource_result__isset;

class Controller_storeJobSource_result {
 public:

  Controller_storeJobSource_result(const Controller_storeJobSource_result&);
  Controller_storeJobSource_result& operator=(const Controller_storeJobSource_result&);
  Controller_storeJobSource_result() noexcept {
  }

  virtual ~Controller_storeJobSource_result() noexcept;
  IllegalArgument e;

  _Controller_storeJobSource_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_storeJobSource_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_storeJobSource_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_storeJobSource_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_storeJobSource_presult__isset {
  _Controller_storeJobSource_presult__isset() : e(false) {}
  bool e :1;
} _Controller_storeJobSource_presult__isset;

class Controller_storeJobSource_presult {
 public:


  virtual ~Controller_storeJobSource_presult() noexcept;
  IllegalArgument e;

  _Controller_storeJobSource_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_tools_args__isset {
  _Controller_tools_args__isset() : c(false) {}
  bool c :1;
} _Controller_tools_args__isset;

class Controller_tools_args {
 public:

  Controller_tools_args(const Controller_tools_args&) noexcept;
  Controller_tools_args& operator=(const Controller_tools_args&) noexcept;
  Controller_tools_args() noexcept
                        : c(0) {
  }

  virtual ~Controller_tools_args() noexcept;
  ControllerID c;

  _Controller_tools_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_tools_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_tools_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_tools_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_tools_pargs {
 public:


  virtual ~Controller_tools_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_tools_result__isset {
  _Controller_tools_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_tools_result__isset;

class Controller_tools_result {
 public:

  Controller_tools_result(const Controller_tools_result&);
  Controller_tools_result& operator=(const Controller_tools_result&);
  Controller_tools_result() noexcept {
  }

  virtual ~Controller_tools_result() noexcept;
  std::map<ToolIndex, std::string>  success;
  IllegalArgument e;

  _Controller_tools_result__isset __isset;

  void __set_success(const std::map<ToolIndex, std::string> & val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_tools_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_tools_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_tools_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_tools_presult__isset {
  _Controller_tools_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_tools_presult__isset;

class Controller_tools_presult {
 public:


  virtual ~Controller_tools_presult() noexcept;
  std::map<ToolIndex, std::string> * success;
  IllegalArgument e;

  _Controller_tools_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_tool_args__isset {
  _Controller_tool_args__isset() : c(false), index(false) {}
  bool c :1;
  bool index :1;
} _Controller_tool_args__isset;

class Controller_tool_args {
 public:

  Controller_tool_args(const Controller_tool_args&) noexcept;
  Controller_tool_args& operator=(const Controller_tool_args&) noexcept;
  Controller_tool_args() noexcept
                       : c(0),
                         index(0) {
  }

  virtual ~Controller_tool_args() noexcept;
  ControllerID c;
  ToolIndex index;

  _Controller_tool_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_index(const ToolIndex val);

  bool operator == (const Controller_tool_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const Controller_tool_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_tool_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_tool_pargs {
 public:


  virtual ~Controller_tool_pargs() noexcept;
  const ControllerID* c;
  const ToolIndex* index;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_tool_result__isset {
  _Controller_tool_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_tool_result__isset;

class Controller_tool_result {
 public:

  Controller_tool_result(const Controller_tool_result&);
  Controller_tool_result& operator=(const Controller_tool_result&);
  Controller_tool_result() noexcept {
  }

  virtual ~Controller_tool_result() noexcept;
  Tool success;
  IllegalArgument e;

  _Controller_tool_result__isset __isset;

  void __set_success(const Tool& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_tool_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_tool_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_tool_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_tool_presult__isset {
  _Controller_tool_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_tool_presult__isset;

class Controller_tool_presult {
 public:


  virtual ~Controller_tool_presult() noexcept;
  Tool* success;
  IllegalArgument e;

  _Controller_tool_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_inputNumber_args__isset {
  _Controller_inputNumber_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_inputNumber_args__isset;

class Controller_inputNumber_args {
 public:

  Controller_inputNumber_args(const Controller_inputNumber_args&);
  Controller_inputNumber_args& operator=(const Controller_inputNumber_args&);
  Controller_inputNumber_args() noexcept
                              : c(0),
                                name() {
  }

  virtual ~Controller_inputNumber_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_inputNumber_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_inputNumber_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_inputNumber_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputNumber_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputNumber_pargs {
 public:


  virtual ~Controller_inputNumber_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputNumber_result__isset {
  _Controller_inputNumber_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputNumber_result__isset;

class Controller_inputNumber_result {
 public:

  Controller_inputNumber_result(const Controller_inputNumber_result&);
  Controller_inputNumber_result& operator=(const Controller_inputNumber_result&);
  Controller_inputNumber_result() noexcept
                                : success(0) {
  }

  virtual ~Controller_inputNumber_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_inputNumber_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputNumber_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputNumber_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputNumber_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputNumber_presult__isset {
  _Controller_inputNumber_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputNumber_presult__isset;

class Controller_inputNumber_presult {
 public:


  virtual ~Controller_inputNumber_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_inputNumber_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_inputGroupNumber_args__isset {
  _Controller_inputGroupNumber_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_inputGroupNumber_args__isset;

class Controller_inputGroupNumber_args {
 public:

  Controller_inputGroupNumber_args(const Controller_inputGroupNumber_args&);
  Controller_inputGroupNumber_args& operator=(const Controller_inputGroupNumber_args&);
  Controller_inputGroupNumber_args() noexcept
                                   : c(0),
                                     name() {
  }

  virtual ~Controller_inputGroupNumber_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_inputGroupNumber_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_inputGroupNumber_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_inputGroupNumber_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputGroupNumber_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputGroupNumber_pargs {
 public:


  virtual ~Controller_inputGroupNumber_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputGroupNumber_result__isset {
  _Controller_inputGroupNumber_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputGroupNumber_result__isset;

class Controller_inputGroupNumber_result {
 public:

  Controller_inputGroupNumber_result(const Controller_inputGroupNumber_result&);
  Controller_inputGroupNumber_result& operator=(const Controller_inputGroupNumber_result&);
  Controller_inputGroupNumber_result() noexcept
                                     : success(0) {
  }

  virtual ~Controller_inputGroupNumber_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_inputGroupNumber_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputGroupNumber_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputGroupNumber_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputGroupNumber_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputGroupNumber_presult__isset {
  _Controller_inputGroupNumber_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputGroupNumber_presult__isset;

class Controller_inputGroupNumber_presult {
 public:


  virtual ~Controller_inputGroupNumber_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_inputGroupNumber_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputNumber_args__isset {
  _Controller_outputNumber_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_outputNumber_args__isset;

class Controller_outputNumber_args {
 public:

  Controller_outputNumber_args(const Controller_outputNumber_args&);
  Controller_outputNumber_args& operator=(const Controller_outputNumber_args&);
  Controller_outputNumber_args() noexcept
                               : c(0),
                                 name() {
  }

  virtual ~Controller_outputNumber_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_outputNumber_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_outputNumber_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_outputNumber_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputNumber_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputNumber_pargs {
 public:


  virtual ~Controller_outputNumber_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputNumber_result__isset {
  _Controller_outputNumber_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputNumber_result__isset;

class Controller_outputNumber_result {
 public:

  Controller_outputNumber_result(const Controller_outputNumber_result&);
  Controller_outputNumber_result& operator=(const Controller_outputNumber_result&);
  Controller_outputNumber_result() noexcept
                                 : success(0) {
  }

  virtual ~Controller_outputNumber_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_outputNumber_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputNumber_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputNumber_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputNumber_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputNumber_presult__isset {
  _Controller_outputNumber_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputNumber_presult__isset;

class Controller_outputNumber_presult {
 public:


  virtual ~Controller_outputNumber_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_outputNumber_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputGroupNumber_args__isset {
  _Controller_outputGroupNumber_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_outputGroupNumber_args__isset;

class Controller_outputGroupNumber_args {
 public:

  Controller_outputGroupNumber_args(const Controller_outputGroupNumber_args&);
  Controller_outputGroupNumber_args& operator=(const Controller_outputGroupNumber_args&);
  Controller_outputGroupNumber_args() noexcept
                                    : c(0),
                                      name() {
  }

  virtual ~Controller_outputGroupNumber_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_outputGroupNumber_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_outputGroupNumber_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_outputGroupNumber_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputGroupNumber_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputGroupNumber_pargs {
 public:


  virtual ~Controller_outputGroupNumber_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputGroupNumber_result__isset {
  _Controller_outputGroupNumber_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputGroupNumber_result__isset;

class Controller_outputGroupNumber_result {
 public:

  Controller_outputGroupNumber_result(const Controller_outputGroupNumber_result&);
  Controller_outputGroupNumber_result& operator=(const Controller_outputGroupNumber_result&);
  Controller_outputGroupNumber_result() noexcept
                                      : success(0) {
  }

  virtual ~Controller_outputGroupNumber_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_outputGroupNumber_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputGroupNumber_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputGroupNumber_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputGroupNumber_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputGroupNumber_presult__isset {
  _Controller_outputGroupNumber_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputGroupNumber_presult__isset;

class Controller_outputGroupNumber_presult {
 public:


  virtual ~Controller_outputGroupNumber_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_outputGroupNumber_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_inputName_args__isset {
  _Controller_inputName_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_inputName_args__isset;

class Controller_inputName_args {
 public:

  Controller_inputName_args(const Controller_inputName_args&) noexcept;
  Controller_inputName_args& operator=(const Controller_inputName_args&) noexcept;
  Controller_inputName_args() noexcept
                            : c(0),
                              num(0) {
  }

  virtual ~Controller_inputName_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_inputName_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_inputName_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_inputName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputName_pargs {
 public:


  virtual ~Controller_inputName_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputName_result__isset {
  _Controller_inputName_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputName_result__isset;

class Controller_inputName_result {
 public:

  Controller_inputName_result(const Controller_inputName_result&);
  Controller_inputName_result& operator=(const Controller_inputName_result&);
  Controller_inputName_result() noexcept
                              : success() {
  }

  virtual ~Controller_inputName_result() noexcept;
  std::string success;
  IllegalArgument e;

  _Controller_inputName_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputName_presult__isset {
  _Controller_inputName_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputName_presult__isset;

class Controller_inputName_presult {
 public:


  virtual ~Controller_inputName_presult() noexcept;
  std::string* success;
  IllegalArgument e;

  _Controller_inputName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputName_args__isset {
  _Controller_outputName_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_outputName_args__isset;

class Controller_outputName_args {
 public:

  Controller_outputName_args(const Controller_outputName_args&) noexcept;
  Controller_outputName_args& operator=(const Controller_outputName_args&) noexcept;
  Controller_outputName_args() noexcept
                             : c(0),
                               num(0) {
  }

  virtual ~Controller_outputName_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_outputName_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_outputName_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_outputName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputName_pargs {
 public:


  virtual ~Controller_outputName_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputName_result__isset {
  _Controller_outputName_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputName_result__isset;

class Controller_outputName_result {
 public:

  Controller_outputName_result(const Controller_outputName_result&);
  Controller_outputName_result& operator=(const Controller_outputName_result&);
  Controller_outputName_result() noexcept
                               : success() {
  }

  virtual ~Controller_outputName_result() noexcept;
  std::string success;
  IllegalArgument e;

  _Controller_outputName_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputName_presult__isset {
  _Controller_outputName_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputName_presult__isset;

class Controller_outputName_presult {
 public:


  virtual ~Controller_outputName_presult() noexcept;
  std::string* success;
  IllegalArgument e;

  _Controller_outputName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setInputName_args__isset {
  _Controller_setInputName_args__isset() : c(false), num(false), name(false) {}
  bool c :1;
  bool num :1;
  bool name :1;
} _Controller_setInputName_args__isset;

class Controller_setInputName_args {
 public:

  Controller_setInputName_args(const Controller_setInputName_args&);
  Controller_setInputName_args& operator=(const Controller_setInputName_args&);
  Controller_setInputName_args() noexcept
                               : c(0),
                                 num(0),
                                 name() {
  }

  virtual ~Controller_setInputName_args() noexcept;
  ControllerID c;
  int32_t num;
  std::string name;

  _Controller_setInputName_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_setInputName_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_setInputName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setInputName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setInputName_pargs {
 public:


  virtual ~Controller_setInputName_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setOutputName_args__isset {
  _Controller_setOutputName_args__isset() : c(false), num(false), name(false) {}
  bool c :1;
  bool num :1;
  bool name :1;
} _Controller_setOutputName_args__isset;

class Controller_setOutputName_args {
 public:

  Controller_setOutputName_args(const Controller_setOutputName_args&);
  Controller_setOutputName_args& operator=(const Controller_setOutputName_args&);
  Controller_setOutputName_args() noexcept
                                : c(0),
                                  num(0),
                                  name() {
  }

  virtual ~Controller_setOutputName_args() noexcept;
  ControllerID c;
  int32_t num;
  std::string name;

  _Controller_setOutputName_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_setOutputName_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_setOutputName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setOutputName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setOutputName_pargs {
 public:


  virtual ~Controller_setOutputName_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorInput_args__isset {
  _Controller_monitorInput_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_monitorInput_args__isset;

class Controller_monitorInput_args {
 public:

  Controller_monitorInput_args(const Controller_monitorInput_args&) noexcept;
  Controller_monitorInput_args& operator=(const Controller_monitorInput_args&) noexcept;
  Controller_monitorInput_args() noexcept
                               : c(0),
                                 num(0) {
  }

  virtual ~Controller_monitorInput_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_monitorInput_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_monitorInput_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorInput_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorInput_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_monitorInput_pargs {
 public:


  virtual ~Controller_monitorInput_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorInput_result__isset {
  _Controller_monitorInput_result__isset() : e(false) {}
  bool e :1;
} _Controller_monitorInput_result__isset;

class Controller_monitorInput_result {
 public:

  Controller_monitorInput_result(const Controller_monitorInput_result&);
  Controller_monitorInput_result& operator=(const Controller_monitorInput_result&);
  Controller_monitorInput_result() noexcept {
  }

  virtual ~Controller_monitorInput_result() noexcept;
  IllegalArgument e;

  _Controller_monitorInput_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_monitorInput_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorInput_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorInput_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorInput_presult__isset {
  _Controller_monitorInput_presult__isset() : e(false) {}
  bool e :1;
} _Controller_monitorInput_presult__isset;

class Controller_monitorInput_presult {
 public:


  virtual ~Controller_monitorInput_presult() noexcept;
  IllegalArgument e;

  _Controller_monitorInput_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_monitorInputGroups_args__isset {
  _Controller_monitorInputGroups_args__isset() : c(false), groupNum(false), count(false) {}
  bool c :1;
  bool groupNum :1;
  bool count :1;
} _Controller_monitorInputGroups_args__isset;

class Controller_monitorInputGroups_args {
 public:

  Controller_monitorInputGroups_args(const Controller_monitorInputGroups_args&) noexcept;
  Controller_monitorInputGroups_args& operator=(const Controller_monitorInputGroups_args&) noexcept;
  Controller_monitorInputGroups_args() noexcept
                                     : c(0),
                                       groupNum(0),
                                       count(0) {
  }

  virtual ~Controller_monitorInputGroups_args() noexcept;
  ControllerID c;
  int32_t groupNum;
  int32_t count;

  _Controller_monitorInputGroups_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_groupNum(const int32_t val);

  void __set_count(const int32_t val);

  bool operator == (const Controller_monitorInputGroups_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(groupNum == rhs.groupNum))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorInputGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorInputGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_monitorInputGroups_pargs {
 public:


  virtual ~Controller_monitorInputGroups_pargs() noexcept;
  const ControllerID* c;
  const int32_t* groupNum;
  const int32_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorInputGroups_result__isset {
  _Controller_monitorInputGroups_result__isset() : e(false) {}
  bool e :1;
} _Controller_monitorInputGroups_result__isset;

class Controller_monitorInputGroups_result {
 public:

  Controller_monitorInputGroups_result(const Controller_monitorInputGroups_result&);
  Controller_monitorInputGroups_result& operator=(const Controller_monitorInputGroups_result&);
  Controller_monitorInputGroups_result() noexcept {
  }

  virtual ~Controller_monitorInputGroups_result() noexcept;
  IllegalArgument e;

  _Controller_monitorInputGroups_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_monitorInputGroups_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorInputGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorInputGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorInputGroups_presult__isset {
  _Controller_monitorInputGroups_presult__isset() : e(false) {}
  bool e :1;
} _Controller_monitorInputGroups_presult__isset;

class Controller_monitorInputGroups_presult {
 public:


  virtual ~Controller_monitorInputGroups_presult() noexcept;
  IllegalArgument e;

  _Controller_monitorInputGroups_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_monitorOutput_args__isset {
  _Controller_monitorOutput_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_monitorOutput_args__isset;

class Controller_monitorOutput_args {
 public:

  Controller_monitorOutput_args(const Controller_monitorOutput_args&) noexcept;
  Controller_monitorOutput_args& operator=(const Controller_monitorOutput_args&) noexcept;
  Controller_monitorOutput_args() noexcept
                                : c(0),
                                  num(0) {
  }

  virtual ~Controller_monitorOutput_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_monitorOutput_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_monitorOutput_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorOutput_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorOutput_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_monitorOutput_pargs {
 public:


  virtual ~Controller_monitorOutput_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorOutput_result__isset {
  _Controller_monitorOutput_result__isset() : e(false) {}
  bool e :1;
} _Controller_monitorOutput_result__isset;

class Controller_monitorOutput_result {
 public:

  Controller_monitorOutput_result(const Controller_monitorOutput_result&);
  Controller_monitorOutput_result& operator=(const Controller_monitorOutput_result&);
  Controller_monitorOutput_result() noexcept {
  }

  virtual ~Controller_monitorOutput_result() noexcept;
  IllegalArgument e;

  _Controller_monitorOutput_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_monitorOutput_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorOutput_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorOutput_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorOutput_presult__isset {
  _Controller_monitorOutput_presult__isset() : e(false) {}
  bool e :1;
} _Controller_monitorOutput_presult__isset;

class Controller_monitorOutput_presult {
 public:


  virtual ~Controller_monitorOutput_presult() noexcept;
  IllegalArgument e;

  _Controller_monitorOutput_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_monitorOutputGroups_args__isset {
  _Controller_monitorOutputGroups_args__isset() : c(false), groupNum(false), count(false) {}
  bool c :1;
  bool groupNum :1;
  bool count :1;
} _Controller_monitorOutputGroups_args__isset;

class Controller_monitorOutputGroups_args {
 public:

  Controller_monitorOutputGroups_args(const Controller_monitorOutputGroups_args&) noexcept;
  Controller_monitorOutputGroups_args& operator=(const Controller_monitorOutputGroups_args&) noexcept;
  Controller_monitorOutputGroups_args() noexcept
                                      : c(0),
                                        groupNum(0),
                                        count(0) {
  }

  virtual ~Controller_monitorOutputGroups_args() noexcept;
  ControllerID c;
  int32_t groupNum;
  int32_t count;

  _Controller_monitorOutputGroups_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_groupNum(const int32_t val);

  void __set_count(const int32_t val);

  bool operator == (const Controller_monitorOutputGroups_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(groupNum == rhs.groupNum))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorOutputGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorOutputGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_monitorOutputGroups_pargs {
 public:


  virtual ~Controller_monitorOutputGroups_pargs() noexcept;
  const ControllerID* c;
  const int32_t* groupNum;
  const int32_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorOutputGroups_result__isset {
  _Controller_monitorOutputGroups_result__isset() : e(false) {}
  bool e :1;
} _Controller_monitorOutputGroups_result__isset;

class Controller_monitorOutputGroups_result {
 public:

  Controller_monitorOutputGroups_result(const Controller_monitorOutputGroups_result&);
  Controller_monitorOutputGroups_result& operator=(const Controller_monitorOutputGroups_result&);
  Controller_monitorOutputGroups_result() noexcept {
  }

  virtual ~Controller_monitorOutputGroups_result() noexcept;
  IllegalArgument e;

  _Controller_monitorOutputGroups_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_monitorOutputGroups_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorOutputGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorOutputGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorOutputGroups_presult__isset {
  _Controller_monitorOutputGroups_presult__isset() : e(false) {}
  bool e :1;
} _Controller_monitorOutputGroups_presult__isset;

class Controller_monitorOutputGroups_presult {
 public:


  virtual ~Controller_monitorOutputGroups_presult() noexcept;
  IllegalArgument e;

  _Controller_monitorOutputGroups_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_unmonitorInput_args__isset {
  _Controller_unmonitorInput_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_unmonitorInput_args__isset;

class Controller_unmonitorInput_args {
 public:

  Controller_unmonitorInput_args(const Controller_unmonitorInput_args&) noexcept;
  Controller_unmonitorInput_args& operator=(const Controller_unmonitorInput_args&) noexcept;
  Controller_unmonitorInput_args() noexcept
                                 : c(0),
                                   num(0) {
  }

  virtual ~Controller_unmonitorInput_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_unmonitorInput_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_unmonitorInput_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_unmonitorInput_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorInput_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorInput_pargs {
 public:


  virtual ~Controller_unmonitorInput_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorInput_result {
 public:

  Controller_unmonitorInput_result(const Controller_unmonitorInput_result&) noexcept;
  Controller_unmonitorInput_result& operator=(const Controller_unmonitorInput_result&) noexcept;
  Controller_unmonitorInput_result() noexcept {
  }

  virtual ~Controller_unmonitorInput_result() noexcept;

  bool operator == (const Controller_unmonitorInput_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_unmonitorInput_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorInput_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorInput_presult {
 public:


  virtual ~Controller_unmonitorInput_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_unmonitorInputGroups_args__isset {
  _Controller_unmonitorInputGroups_args__isset() : c(false), groupNum(false), count(false) {}
  bool c :1;
  bool groupNum :1;
  bool count :1;
} _Controller_unmonitorInputGroups_args__isset;

class Controller_unmonitorInputGroups_args {
 public:

  Controller_unmonitorInputGroups_args(const Controller_unmonitorInputGroups_args&) noexcept;
  Controller_unmonitorInputGroups_args& operator=(const Controller_unmonitorInputGroups_args&) noexcept;
  Controller_unmonitorInputGroups_args() noexcept
                                       : c(0),
                                         groupNum(0),
                                         count(0) {
  }

  virtual ~Controller_unmonitorInputGroups_args() noexcept;
  ControllerID c;
  int32_t groupNum;
  int32_t count;

  _Controller_unmonitorInputGroups_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_groupNum(const int32_t val);

  void __set_count(const int32_t val);

  bool operator == (const Controller_unmonitorInputGroups_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(groupNum == rhs.groupNum))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const Controller_unmonitorInputGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorInputGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorInputGroups_pargs {
 public:


  virtual ~Controller_unmonitorInputGroups_pargs() noexcept;
  const ControllerID* c;
  const int32_t* groupNum;
  const int32_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorInputGroups_result {
 public:

  Controller_unmonitorInputGroups_result(const Controller_unmonitorInputGroups_result&) noexcept;
  Controller_unmonitorInputGroups_result& operator=(const Controller_unmonitorInputGroups_result&) noexcept;
  Controller_unmonitorInputGroups_result() noexcept {
  }

  virtual ~Controller_unmonitorInputGroups_result() noexcept;

  bool operator == (const Controller_unmonitorInputGroups_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_unmonitorInputGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorInputGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorInputGroups_presult {
 public:


  virtual ~Controller_unmonitorInputGroups_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_unmonitorOutput_args__isset {
  _Controller_unmonitorOutput_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_unmonitorOutput_args__isset;

class Controller_unmonitorOutput_args {
 public:

  Controller_unmonitorOutput_args(const Controller_unmonitorOutput_args&) noexcept;
  Controller_unmonitorOutput_args& operator=(const Controller_unmonitorOutput_args&) noexcept;
  Controller_unmonitorOutput_args() noexcept
                                  : c(0),
                                    num(0) {
  }

  virtual ~Controller_unmonitorOutput_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_unmonitorOutput_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_unmonitorOutput_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_unmonitorOutput_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorOutput_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorOutput_pargs {
 public:


  virtual ~Controller_unmonitorOutput_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorOutput_result {
 public:

  Controller_unmonitorOutput_result(const Controller_unmonitorOutput_result&) noexcept;
  Controller_unmonitorOutput_result& operator=(const Controller_unmonitorOutput_result&) noexcept;
  Controller_unmonitorOutput_result() noexcept {
  }

  virtual ~Controller_unmonitorOutput_result() noexcept;

  bool operator == (const Controller_unmonitorOutput_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_unmonitorOutput_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorOutput_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorOutput_presult {
 public:


  virtual ~Controller_unmonitorOutput_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_unmonitorOutputGroups_args__isset {
  _Controller_unmonitorOutputGroups_args__isset() : c(false), groupNum(false), count(false) {}
  bool c :1;
  bool groupNum :1;
  bool count :1;
} _Controller_unmonitorOutputGroups_args__isset;

class Controller_unmonitorOutputGroups_args {
 public:

  Controller_unmonitorOutputGroups_args(const Controller_unmonitorOutputGroups_args&) noexcept;
  Controller_unmonitorOutputGroups_args& operator=(const Controller_unmonitorOutputGroups_args&) noexcept;
  Controller_unmonitorOutputGroups_args() noexcept
                                        : c(0),
                                          groupNum(0),
                                          count(0) {
  }

  virtual ~Controller_unmonitorOutputGroups_args() noexcept;
  ControllerID c;
  int32_t groupNum;
  int32_t count;

  _Controller_unmonitorOutputGroups_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_groupNum(const int32_t val);

  void __set_count(const int32_t val);

  bool operator == (const Controller_unmonitorOutputGroups_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(groupNum == rhs.groupNum))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const Controller_unmonitorOutputGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorOutputGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorOutputGroups_pargs {
 public:


  virtual ~Controller_unmonitorOutputGroups_pargs() noexcept;
  const ControllerID* c;
  const int32_t* groupNum;
  const int32_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorOutputGroups_result {
 public:

  Controller_unmonitorOutputGroups_result(const Controller_unmonitorOutputGroups_result&) noexcept;
  Controller_unmonitorOutputGroups_result& operator=(const Controller_unmonitorOutputGroups_result&) noexcept;
  Controller_unmonitorOutputGroups_result() noexcept {
  }

  virtual ~Controller_unmonitorOutputGroups_result() noexcept;

  bool operator == (const Controller_unmonitorOutputGroups_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_unmonitorOutputGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorOutputGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorOutputGroups_presult {
 public:


  virtual ~Controller_unmonitorOutputGroups_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_inputValue_args__isset {
  _Controller_inputValue_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_inputValue_args__isset;

class Controller_inputValue_args {
 public:

  Controller_inputValue_args(const Controller_inputValue_args&) noexcept;
  Controller_inputValue_args& operator=(const Controller_inputValue_args&) noexcept;
  Controller_inputValue_args() noexcept
                             : c(0),
                               num(0) {
  }

  virtual ~Controller_inputValue_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_inputValue_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_inputValue_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_inputValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputValue_pargs {
 public:


  virtual ~Controller_inputValue_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputValue_result__isset {
  _Controller_inputValue_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputValue_result__isset;

class Controller_inputValue_result {
 public:

  Controller_inputValue_result(const Controller_inputValue_result&);
  Controller_inputValue_result& operator=(const Controller_inputValue_result&);
  Controller_inputValue_result() noexcept
                               : success(0) {
  }

  virtual ~Controller_inputValue_result() noexcept;
  bool success;
  IllegalArgument e;

  _Controller_inputValue_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputValue_presult__isset {
  _Controller_inputValue_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputValue_presult__isset;

class Controller_inputValue_presult {
 public:


  virtual ~Controller_inputValue_presult() noexcept;
  bool* success;
  IllegalArgument e;

  _Controller_inputValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_inputGroupsValue_args__isset {
  _Controller_inputGroupsValue_args__isset() : c(false), groupNum(false), count(false) {}
  bool c :1;
  bool groupNum :1;
  bool count :1;
} _Controller_inputGroupsValue_args__isset;

class Controller_inputGroupsValue_args {
 public:

  Controller_inputGroupsValue_args(const Controller_inputGroupsValue_args&) noexcept;
  Controller_inputGroupsValue_args& operator=(const Controller_inputGroupsValue_args&) noexcept;
  Controller_inputGroupsValue_args() noexcept
                                   : c(0),
                                     groupNum(0),
                                     count(0) {
  }

  virtual ~Controller_inputGroupsValue_args() noexcept;
  ControllerID c;
  int32_t groupNum;
  int32_t count;

  _Controller_inputGroupsValue_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_groupNum(const int32_t val);

  void __set_count(const int32_t val);

  bool operator == (const Controller_inputGroupsValue_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(groupNum == rhs.groupNum))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const Controller_inputGroupsValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputGroupsValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputGroupsValue_pargs {
 public:


  virtual ~Controller_inputGroupsValue_pargs() noexcept;
  const ControllerID* c;
  const int32_t* groupNum;
  const int32_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputGroupsValue_result__isset {
  _Controller_inputGroupsValue_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputGroupsValue_result__isset;

class Controller_inputGroupsValue_result {
 public:

  Controller_inputGroupsValue_result(const Controller_inputGroupsValue_result&);
  Controller_inputGroupsValue_result& operator=(const Controller_inputGroupsValue_result&);
  Controller_inputGroupsValue_result() noexcept
                                     : success(0) {
  }

  virtual ~Controller_inputGroupsValue_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_inputGroupsValue_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputGroupsValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputGroupsValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputGroupsValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputGroupsValue_presult__isset {
  _Controller_inputGroupsValue_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputGroupsValue_presult__isset;

class Controller_inputGroupsValue_presult {
 public:


  virtual ~Controller_inputGroupsValue_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_inputGroupsValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputValue_args__isset {
  _Controller_outputValue_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_outputValue_args__isset;

class Controller_outputValue_args {
 public:

  Controller_outputValue_args(const Controller_outputValue_args&) noexcept;
  Controller_outputValue_args& operator=(const Controller_outputValue_args&) noexcept;
  Controller_outputValue_args() noexcept
                              : c(0),
                                num(0) {
  }

  virtual ~Controller_outputValue_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_outputValue_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_outputValue_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_outputValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputValue_pargs {
 public:


  virtual ~Controller_outputValue_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputValue_result__isset {
  _Controller_outputValue_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputValue_result__isset;

class Controller_outputValue_result {
 public:

  Controller_outputValue_result(const Controller_outputValue_result&);
  Controller_outputValue_result& operator=(const Controller_outputValue_result&);
  Controller_outputValue_result() noexcept
                                : success(0) {
  }

  virtual ~Controller_outputValue_result() noexcept;
  bool success;
  IllegalArgument e;

  _Controller_outputValue_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputValue_presult__isset {
  _Controller_outputValue_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputValue_presult__isset;

class Controller_outputValue_presult {
 public:


  virtual ~Controller_outputValue_presult() noexcept;
  bool* success;
  IllegalArgument e;

  _Controller_outputValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputGroupsValue_args__isset {
  _Controller_outputGroupsValue_args__isset() : c(false), groupNum(false), count(false) {}
  bool c :1;
  bool groupNum :1;
  bool count :1;
} _Controller_outputGroupsValue_args__isset;

class Controller_outputGroupsValue_args {
 public:

  Controller_outputGroupsValue_args(const Controller_outputGroupsValue_args&) noexcept;
  Controller_outputGroupsValue_args& operator=(const Controller_outputGroupsValue_args&) noexcept;
  Controller_outputGroupsValue_args() noexcept
                                    : c(0),
                                      groupNum(0),
                                      count(0) {
  }

  virtual ~Controller_outputGroupsValue_args() noexcept;
  ControllerID c;
  int32_t groupNum;
  int32_t count;

  _Controller_outputGroupsValue_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_groupNum(const int32_t val);

  void __set_count(const int32_t val);

  bool operator == (const Controller_outputGroupsValue_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(groupNum == rhs.groupNum))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const Controller_outputGroupsValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputGroupsValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputGroupsValue_pargs {
 public:


  virtual ~Controller_outputGroupsValue_pargs() noexcept;
  const ControllerID* c;
  const int32_t* groupNum;
  const int32_t* count;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputGroupsValue_result__isset {
  _Controller_outputGroupsValue_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputGroupsValue_result__isset;

class Controller_outputGroupsValue_result {
 public:

  Controller_outputGroupsValue_result(const Controller_outputGroupsValue_result&);
  Controller_outputGroupsValue_result& operator=(const Controller_outputGroupsValue_result&);
  Controller_outputGroupsValue_result() noexcept
                                      : success(0) {
  }

  virtual ~Controller_outputGroupsValue_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_outputGroupsValue_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputGroupsValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputGroupsValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputGroupsValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputGroupsValue_presult__isset {
  _Controller_outputGroupsValue_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputGroupsValue_presult__isset;

class Controller_outputGroupsValue_presult {
 public:


  virtual ~Controller_outputGroupsValue_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_outputGroupsValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setOutput_args__isset {
  _Controller_setOutput_args__isset() : c(false), num(false), value(false) {}
  bool c :1;
  bool num :1;
  bool value :1;
} _Controller_setOutput_args__isset;

class Controller_setOutput_args {
 public:

  Controller_setOutput_args(const Controller_setOutput_args&) noexcept;
  Controller_setOutput_args& operator=(const Controller_setOutput_args&) noexcept;
  Controller_setOutput_args() noexcept
                            : c(0),
                              num(0),
                              value(0) {
  }

  virtual ~Controller_setOutput_args() noexcept;
  ControllerID c;
  int32_t num;
  bool value;

  _Controller_setOutput_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  void __set_value(const bool val);

  bool operator == (const Controller_setOutput_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Controller_setOutput_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setOutput_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setOutput_pargs {
 public:


  virtual ~Controller_setOutput_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;
  const bool* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setOutputGroups_args__isset {
  _Controller_setOutputGroups_args__isset() : c(false), groupNum(false), count(false), value(false) {}
  bool c :1;
  bool groupNum :1;
  bool count :1;
  bool value :1;
} _Controller_setOutputGroups_args__isset;

class Controller_setOutputGroups_args {
 public:

  Controller_setOutputGroups_args(const Controller_setOutputGroups_args&) noexcept;
  Controller_setOutputGroups_args& operator=(const Controller_setOutputGroups_args&) noexcept;
  Controller_setOutputGroups_args() noexcept
                                  : c(0),
                                    groupNum(0),
                                    count(0),
                                    value(0) {
  }

  virtual ~Controller_setOutputGroups_args() noexcept;
  ControllerID c;
  int32_t groupNum;
  int32_t count;
  int32_t value;

  _Controller_setOutputGroups_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_groupNum(const int32_t val);

  void __set_count(const int32_t val);

  void __set_value(const int32_t val);

  bool operator == (const Controller_setOutputGroups_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(groupNum == rhs.groupNum))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Controller_setOutputGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setOutputGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setOutputGroups_pargs {
 public:


  virtual ~Controller_setOutputGroups_pargs() noexcept;
  const ControllerID* c;
  const int32_t* groupNum;
  const int32_t* count;
  const int32_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputAddress_args__isset {
  _Controller_inputAddress_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_inputAddress_args__isset;

class Controller_inputAddress_args {
 public:

  Controller_inputAddress_args(const Controller_inputAddress_args&);
  Controller_inputAddress_args& operator=(const Controller_inputAddress_args&);
  Controller_inputAddress_args() noexcept
                               : c(0),
                                 name() {
  }

  virtual ~Controller_inputAddress_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_inputAddress_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_inputAddress_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_inputAddress_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputAddress_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputAddress_pargs {
 public:


  virtual ~Controller_inputAddress_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputAddress_result__isset {
  _Controller_inputAddress_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputAddress_result__isset;

class Controller_inputAddress_result {
 public:

  Controller_inputAddress_result(const Controller_inputAddress_result&);
  Controller_inputAddress_result& operator=(const Controller_inputAddress_result&);
  Controller_inputAddress_result() noexcept
                                 : success(0) {
  }

  virtual ~Controller_inputAddress_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_inputAddress_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputAddress_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputAddress_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputAddress_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputAddress_presult__isset {
  _Controller_inputAddress_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputAddress_presult__isset;

class Controller_inputAddress_presult {
 public:


  virtual ~Controller_inputAddress_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_inputAddress_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_inputAddressByNumber_args__isset {
  _Controller_inputAddressByNumber_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_inputAddressByNumber_args__isset;

class Controller_inputAddressByNumber_args {
 public:

  Controller_inputAddressByNumber_args(const Controller_inputAddressByNumber_args&) noexcept;
  Controller_inputAddressByNumber_args& operator=(const Controller_inputAddressByNumber_args&) noexcept;
  Controller_inputAddressByNumber_args() noexcept
                                       : c(0),
                                         num(0) {
  }

  virtual ~Controller_inputAddressByNumber_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_inputAddressByNumber_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_inputAddressByNumber_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_inputAddressByNumber_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputAddressByNumber_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputAddressByNumber_pargs {
 public:


  virtual ~Controller_inputAddressByNumber_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputAddressByNumber_result__isset {
  _Controller_inputAddressByNumber_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputAddressByNumber_result__isset;

class Controller_inputAddressByNumber_result {
 public:

  Controller_inputAddressByNumber_result(const Controller_inputAddressByNumber_result&);
  Controller_inputAddressByNumber_result& operator=(const Controller_inputAddressByNumber_result&);
  Controller_inputAddressByNumber_result() noexcept
                                         : success(0) {
  }

  virtual ~Controller_inputAddressByNumber_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_inputAddressByNumber_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputAddressByNumber_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputAddressByNumber_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputAddressByNumber_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputAddressByNumber_presult__isset {
  _Controller_inputAddressByNumber_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputAddressByNumber_presult__isset;

class Controller_inputAddressByNumber_presult {
 public:


  virtual ~Controller_inputAddressByNumber_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_inputAddressByNumber_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputAddress_args__isset {
  _Controller_outputAddress_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_outputAddress_args__isset;

class Controller_outputAddress_args {
 public:

  Controller_outputAddress_args(const Controller_outputAddress_args&);
  Controller_outputAddress_args& operator=(const Controller_outputAddress_args&);
  Controller_outputAddress_args() noexcept
                                : c(0),
                                  name() {
  }

  virtual ~Controller_outputAddress_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_outputAddress_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_outputAddress_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_outputAddress_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputAddress_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputAddress_pargs {
 public:


  virtual ~Controller_outputAddress_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputAddress_result__isset {
  _Controller_outputAddress_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputAddress_result__isset;

class Controller_outputAddress_result {
 public:

  Controller_outputAddress_result(const Controller_outputAddress_result&);
  Controller_outputAddress_result& operator=(const Controller_outputAddress_result&);
  Controller_outputAddress_result() noexcept
                                  : success(0) {
  }

  virtual ~Controller_outputAddress_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_outputAddress_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputAddress_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputAddress_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputAddress_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputAddress_presult__isset {
  _Controller_outputAddress_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputAddress_presult__isset;

class Controller_outputAddress_presult {
 public:


  virtual ~Controller_outputAddress_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_outputAddress_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputAddressByNumber_args__isset {
  _Controller_outputAddressByNumber_args__isset() : c(false), num(false) {}
  bool c :1;
  bool num :1;
} _Controller_outputAddressByNumber_args__isset;

class Controller_outputAddressByNumber_args {
 public:

  Controller_outputAddressByNumber_args(const Controller_outputAddressByNumber_args&) noexcept;
  Controller_outputAddressByNumber_args& operator=(const Controller_outputAddressByNumber_args&) noexcept;
  Controller_outputAddressByNumber_args() noexcept
                                        : c(0),
                                          num(0) {
  }

  virtual ~Controller_outputAddressByNumber_args() noexcept;
  ControllerID c;
  int32_t num;

  _Controller_outputAddressByNumber_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_num(const int32_t val);

  bool operator == (const Controller_outputAddressByNumber_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(num == rhs.num))
      return false;
    return true;
  }
  bool operator != (const Controller_outputAddressByNumber_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputAddressByNumber_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputAddressByNumber_pargs {
 public:


  virtual ~Controller_outputAddressByNumber_pargs() noexcept;
  const ControllerID* c;
  const int32_t* num;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputAddressByNumber_result__isset {
  _Controller_outputAddressByNumber_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputAddressByNumber_result__isset;

class Controller_outputAddressByNumber_result {
 public:

  Controller_outputAddressByNumber_result(const Controller_outputAddressByNumber_result&);
  Controller_outputAddressByNumber_result& operator=(const Controller_outputAddressByNumber_result&);
  Controller_outputAddressByNumber_result() noexcept
                                          : success(0) {
  }

  virtual ~Controller_outputAddressByNumber_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_outputAddressByNumber_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputAddressByNumber_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputAddressByNumber_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputAddressByNumber_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputAddressByNumber_presult__isset {
  _Controller_outputAddressByNumber_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputAddressByNumber_presult__isset;

class Controller_outputAddressByNumber_presult {
 public:


  virtual ~Controller_outputAddressByNumber_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_outputAddressByNumber_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_monitorIOAddress_args__isset {
  _Controller_monitorIOAddress_args__isset() : c(false), address(false) {}
  bool c :1;
  bool address :1;
} _Controller_monitorIOAddress_args__isset;

class Controller_monitorIOAddress_args {
 public:

  Controller_monitorIOAddress_args(const Controller_monitorIOAddress_args&) noexcept;
  Controller_monitorIOAddress_args& operator=(const Controller_monitorIOAddress_args&) noexcept;
  Controller_monitorIOAddress_args() noexcept
                                   : c(0),
                                     address(0) {
  }

  virtual ~Controller_monitorIOAddress_args() noexcept;
  ControllerID c;
  int32_t address;

  _Controller_monitorIOAddress_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_address(const int32_t val);

  bool operator == (const Controller_monitorIOAddress_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorIOAddress_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorIOAddress_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_monitorIOAddress_pargs {
 public:


  virtual ~Controller_monitorIOAddress_pargs() noexcept;
  const ControllerID* c;
  const int32_t* address;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorIOAddress_result__isset {
  _Controller_monitorIOAddress_result__isset() : e(false) {}
  bool e :1;
} _Controller_monitorIOAddress_result__isset;

class Controller_monitorIOAddress_result {
 public:

  Controller_monitorIOAddress_result(const Controller_monitorIOAddress_result&);
  Controller_monitorIOAddress_result& operator=(const Controller_monitorIOAddress_result&);
  Controller_monitorIOAddress_result() noexcept {
  }

  virtual ~Controller_monitorIOAddress_result() noexcept;
  IllegalArgument e;

  _Controller_monitorIOAddress_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_monitorIOAddress_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_monitorIOAddress_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_monitorIOAddress_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_monitorIOAddress_presult__isset {
  _Controller_monitorIOAddress_presult__isset() : e(false) {}
  bool e :1;
} _Controller_monitorIOAddress_presult__isset;

class Controller_monitorIOAddress_presult {
 public:


  virtual ~Controller_monitorIOAddress_presult() noexcept;
  IllegalArgument e;

  _Controller_monitorIOAddress_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_unmonitorIOAddress_args__isset {
  _Controller_unmonitorIOAddress_args__isset() : c(false), address(false) {}
  bool c :1;
  bool address :1;
} _Controller_unmonitorIOAddress_args__isset;

class Controller_unmonitorIOAddress_args {
 public:

  Controller_unmonitorIOAddress_args(const Controller_unmonitorIOAddress_args&) noexcept;
  Controller_unmonitorIOAddress_args& operator=(const Controller_unmonitorIOAddress_args&) noexcept;
  Controller_unmonitorIOAddress_args() noexcept
                                     : c(0),
                                       address(0) {
  }

  virtual ~Controller_unmonitorIOAddress_args() noexcept;
  ControllerID c;
  int32_t address;

  _Controller_unmonitorIOAddress_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_address(const int32_t val);

  bool operator == (const Controller_unmonitorIOAddress_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const Controller_unmonitorIOAddress_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorIOAddress_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorIOAddress_pargs {
 public:


  virtual ~Controller_unmonitorIOAddress_pargs() noexcept;
  const ControllerID* c;
  const int32_t* address;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorIOAddress_result {
 public:

  Controller_unmonitorIOAddress_result(const Controller_unmonitorIOAddress_result&) noexcept;
  Controller_unmonitorIOAddress_result& operator=(const Controller_unmonitorIOAddress_result&) noexcept;
  Controller_unmonitorIOAddress_result() noexcept {
  }

  virtual ~Controller_unmonitorIOAddress_result() noexcept;

  bool operator == (const Controller_unmonitorIOAddress_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Controller_unmonitorIOAddress_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_unmonitorIOAddress_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_unmonitorIOAddress_presult {
 public:


  virtual ~Controller_unmonitorIOAddress_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_inputAddressValue_args__isset {
  _Controller_inputAddressValue_args__isset() : c(false), address(false) {}
  bool c :1;
  bool address :1;
} _Controller_inputAddressValue_args__isset;

class Controller_inputAddressValue_args {
 public:

  Controller_inputAddressValue_args(const Controller_inputAddressValue_args&) noexcept;
  Controller_inputAddressValue_args& operator=(const Controller_inputAddressValue_args&) noexcept;
  Controller_inputAddressValue_args() noexcept
                                    : c(0),
                                      address(0) {
  }

  virtual ~Controller_inputAddressValue_args() noexcept;
  ControllerID c;
  int32_t address;

  _Controller_inputAddressValue_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_address(const int32_t val);

  bool operator == (const Controller_inputAddressValue_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const Controller_inputAddressValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputAddressValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_inputAddressValue_pargs {
 public:


  virtual ~Controller_inputAddressValue_pargs() noexcept;
  const ControllerID* c;
  const int32_t* address;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputAddressValue_result__isset {
  _Controller_inputAddressValue_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputAddressValue_result__isset;

class Controller_inputAddressValue_result {
 public:

  Controller_inputAddressValue_result(const Controller_inputAddressValue_result&);
  Controller_inputAddressValue_result& operator=(const Controller_inputAddressValue_result&);
  Controller_inputAddressValue_result() noexcept
                                      : success(0) {
  }

  virtual ~Controller_inputAddressValue_result() noexcept;
  bool success;
  IllegalArgument e;

  _Controller_inputAddressValue_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_inputAddressValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_inputAddressValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_inputAddressValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_inputAddressValue_presult__isset {
  _Controller_inputAddressValue_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_inputAddressValue_presult__isset;

class Controller_inputAddressValue_presult {
 public:


  virtual ~Controller_inputAddressValue_presult() noexcept;
  bool* success;
  IllegalArgument e;

  _Controller_inputAddressValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_outputAddressValue_args__isset {
  _Controller_outputAddressValue_args__isset() : c(false), address(false) {}
  bool c :1;
  bool address :1;
} _Controller_outputAddressValue_args__isset;

class Controller_outputAddressValue_args {
 public:

  Controller_outputAddressValue_args(const Controller_outputAddressValue_args&) noexcept;
  Controller_outputAddressValue_args& operator=(const Controller_outputAddressValue_args&) noexcept;
  Controller_outputAddressValue_args() noexcept
                                     : c(0),
                                       address(0) {
  }

  virtual ~Controller_outputAddressValue_args() noexcept;
  ControllerID c;
  int32_t address;

  _Controller_outputAddressValue_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_address(const int32_t val);

  bool operator == (const Controller_outputAddressValue_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const Controller_outputAddressValue_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputAddressValue_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_outputAddressValue_pargs {
 public:


  virtual ~Controller_outputAddressValue_pargs() noexcept;
  const ControllerID* c;
  const int32_t* address;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputAddressValue_result__isset {
  _Controller_outputAddressValue_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputAddressValue_result__isset;

class Controller_outputAddressValue_result {
 public:

  Controller_outputAddressValue_result(const Controller_outputAddressValue_result&);
  Controller_outputAddressValue_result& operator=(const Controller_outputAddressValue_result&);
  Controller_outputAddressValue_result() noexcept
                                       : success(0) {
  }

  virtual ~Controller_outputAddressValue_result() noexcept;
  bool success;
  IllegalArgument e;

  _Controller_outputAddressValue_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_outputAddressValue_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_outputAddressValue_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_outputAddressValue_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_outputAddressValue_presult__isset {
  _Controller_outputAddressValue_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_outputAddressValue_presult__isset;

class Controller_outputAddressValue_presult {
 public:


  virtual ~Controller_outputAddressValue_presult() noexcept;
  bool* success;
  IllegalArgument e;

  _Controller_outputAddressValue_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setOutputAddress_args__isset {
  _Controller_setOutputAddress_args__isset() : c(false), address(false), value(false) {}
  bool c :1;
  bool address :1;
  bool value :1;
} _Controller_setOutputAddress_args__isset;

class Controller_setOutputAddress_args {
 public:

  Controller_setOutputAddress_args(const Controller_setOutputAddress_args&) noexcept;
  Controller_setOutputAddress_args& operator=(const Controller_setOutputAddress_args&) noexcept;
  Controller_setOutputAddress_args() noexcept
                                   : c(0),
                                     address(0),
                                     value(0) {
  }

  virtual ~Controller_setOutputAddress_args() noexcept;
  ControllerID c;
  int32_t address;
  bool value;

  _Controller_setOutputAddress_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_address(const int32_t val);

  void __set_value(const bool val);

  bool operator == (const Controller_setOutputAddress_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Controller_setOutputAddress_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setOutputAddress_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setOutputAddress_pargs {
 public:


  virtual ~Controller_setOutputAddress_pargs() noexcept;
  const ControllerID* c;
  const int32_t* address;
  const bool* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_fieldBusStatusInputGroup_args__isset {
  _Controller_fieldBusStatusInputGroup_args__isset() : c(false), busType(false) {}
  bool c :1;
  bool busType :1;
} _Controller_fieldBusStatusInputGroup_args__isset;

class Controller_fieldBusStatusInputGroup_args {
 public:

  Controller_fieldBusStatusInputGroup_args(const Controller_fieldBusStatusInputGroup_args&);
  Controller_fieldBusStatusInputGroup_args& operator=(const Controller_fieldBusStatusInputGroup_args&);
  Controller_fieldBusStatusInputGroup_args() noexcept
                                           : c(0),
                                             busType() {
  }

  virtual ~Controller_fieldBusStatusInputGroup_args() noexcept;
  ControllerID c;
  std::string busType;

  _Controller_fieldBusStatusInputGroup_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_busType(const std::string& val);

  bool operator == (const Controller_fieldBusStatusInputGroup_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(busType == rhs.busType))
      return false;
    return true;
  }
  bool operator != (const Controller_fieldBusStatusInputGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_fieldBusStatusInputGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_fieldBusStatusInputGroup_pargs {
 public:


  virtual ~Controller_fieldBusStatusInputGroup_pargs() noexcept;
  const ControllerID* c;
  const std::string* busType;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_fieldBusStatusInputGroup_result__isset {
  _Controller_fieldBusStatusInputGroup_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_fieldBusStatusInputGroup_result__isset;

class Controller_fieldBusStatusInputGroup_result {
 public:

  Controller_fieldBusStatusInputGroup_result(const Controller_fieldBusStatusInputGroup_result&);
  Controller_fieldBusStatusInputGroup_result& operator=(const Controller_fieldBusStatusInputGroup_result&);
  Controller_fieldBusStatusInputGroup_result() noexcept
                                             : success(0) {
  }

  virtual ~Controller_fieldBusStatusInputGroup_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_fieldBusStatusInputGroup_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_fieldBusStatusInputGroup_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_fieldBusStatusInputGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_fieldBusStatusInputGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_fieldBusStatusInputGroup_presult__isset {
  _Controller_fieldBusStatusInputGroup_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_fieldBusStatusInputGroup_presult__isset;

class Controller_fieldBusStatusInputGroup_presult {
 public:


  virtual ~Controller_fieldBusStatusInputGroup_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_fieldBusStatusInputGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_controlGroups_args__isset {
  _Controller_controlGroups_args__isset() : c(false) {}
  bool c :1;
} _Controller_controlGroups_args__isset;

class Controller_controlGroups_args {
 public:

  Controller_controlGroups_args(const Controller_controlGroups_args&) noexcept;
  Controller_controlGroups_args& operator=(const Controller_controlGroups_args&) noexcept;
  Controller_controlGroups_args() noexcept
                                : c(0) {
  }

  virtual ~Controller_controlGroups_args() noexcept;
  ControllerID c;

  _Controller_controlGroups_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_controlGroups_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_controlGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_controlGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_controlGroups_pargs {
 public:


  virtual ~Controller_controlGroups_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_controlGroups_result__isset {
  _Controller_controlGroups_result__isset() : success(false) {}
  bool success :1;
} _Controller_controlGroups_result__isset;

class Controller_controlGroups_result {
 public:

  Controller_controlGroups_result(const Controller_controlGroups_result&);
  Controller_controlGroups_result& operator=(const Controller_controlGroups_result&);
  Controller_controlGroups_result() noexcept {
  }

  virtual ~Controller_controlGroups_result() noexcept;
  std::vector<ControlGroup>  success;

  _Controller_controlGroups_result__isset __isset;

  void __set_success(const std::vector<ControlGroup> & val);

  bool operator == (const Controller_controlGroups_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_controlGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_controlGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_controlGroups_presult__isset {
  _Controller_controlGroups_presult__isset() : success(false) {}
  bool success :1;
} _Controller_controlGroups_presult__isset;

class Controller_controlGroups_presult {
 public:


  virtual ~Controller_controlGroups_presult() noexcept;
  std::vector<ControlGroup> * success;

  _Controller_controlGroups_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_currentControlGroup_args__isset {
  _Controller_currentControlGroup_args__isset() : c(false) {}
  bool c :1;
} _Controller_currentControlGroup_args__isset;

class Controller_currentControlGroup_args {
 public:

  Controller_currentControlGroup_args(const Controller_currentControlGroup_args&) noexcept;
  Controller_currentControlGroup_args& operator=(const Controller_currentControlGroup_args&) noexcept;
  Controller_currentControlGroup_args() noexcept
                                      : c(0) {
  }

  virtual ~Controller_currentControlGroup_args() noexcept;
  ControllerID c;

  _Controller_currentControlGroup_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_currentControlGroup_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_currentControlGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_currentControlGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_currentControlGroup_pargs {
 public:


  virtual ~Controller_currentControlGroup_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_currentControlGroup_result__isset {
  _Controller_currentControlGroup_result__isset() : success(false) {}
  bool success :1;
} _Controller_currentControlGroup_result__isset;

class Controller_currentControlGroup_result {
 public:

  Controller_currentControlGroup_result(const Controller_currentControlGroup_result&) noexcept;
  Controller_currentControlGroup_result& operator=(const Controller_currentControlGroup_result&) noexcept;
  Controller_currentControlGroup_result() noexcept
                                        : success(0) {
  }

  virtual ~Controller_currentControlGroup_result() noexcept;
  int8_t success;

  _Controller_currentControlGroup_result__isset __isset;

  void __set_success(const int8_t val);

  bool operator == (const Controller_currentControlGroup_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_currentControlGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_currentControlGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_currentControlGroup_presult__isset {
  _Controller_currentControlGroup_presult__isset() : success(false) {}
  bool success :1;
} _Controller_currentControlGroup_presult__isset;

class Controller_currentControlGroup_presult {
 public:


  virtual ~Controller_currentControlGroup_presult() noexcept;
  int8_t* success;

  _Controller_currentControlGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_robotCount_args__isset {
  _Controller_robotCount_args__isset() : c(false) {}
  bool c :1;
} _Controller_robotCount_args__isset;

class Controller_robotCount_args {
 public:

  Controller_robotCount_args(const Controller_robotCount_args&) noexcept;
  Controller_robotCount_args& operator=(const Controller_robotCount_args&) noexcept;
  Controller_robotCount_args() noexcept
                             : c(0) {
  }

  virtual ~Controller_robotCount_args() noexcept;
  ControllerID c;

  _Controller_robotCount_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_robotCount_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_robotCount_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_robotCount_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_robotCount_pargs {
 public:


  virtual ~Controller_robotCount_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_robotCount_result__isset {
  _Controller_robotCount_result__isset() : success(false) {}
  bool success :1;
} _Controller_robotCount_result__isset;

class Controller_robotCount_result {
 public:

  Controller_robotCount_result(const Controller_robotCount_result&) noexcept;
  Controller_robotCount_result& operator=(const Controller_robotCount_result&) noexcept;
  Controller_robotCount_result() noexcept
                               : success(0) {
  }

  virtual ~Controller_robotCount_result() noexcept;
  int8_t success;

  _Controller_robotCount_result__isset __isset;

  void __set_success(const int8_t val);

  bool operator == (const Controller_robotCount_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_robotCount_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_robotCount_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_robotCount_presult__isset {
  _Controller_robotCount_presult__isset() : success(false) {}
  bool success :1;
} _Controller_robotCount_presult__isset;

class Controller_robotCount_presult {
 public:


  virtual ~Controller_robotCount_presult() noexcept;
  int8_t* success;

  _Controller_robotCount_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_currentRobot_args__isset {
  _Controller_currentRobot_args__isset() : c(false) {}
  bool c :1;
} _Controller_currentRobot_args__isset;

class Controller_currentRobot_args {
 public:

  Controller_currentRobot_args(const Controller_currentRobot_args&) noexcept;
  Controller_currentRobot_args& operator=(const Controller_currentRobot_args&) noexcept;
  Controller_currentRobot_args() noexcept
                               : c(0) {
  }

  virtual ~Controller_currentRobot_args() noexcept;
  ControllerID c;

  _Controller_currentRobot_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_currentRobot_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_currentRobot_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_currentRobot_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_currentRobot_pargs {
 public:


  virtual ~Controller_currentRobot_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_currentRobot_result__isset {
  _Controller_currentRobot_result__isset() : success(false) {}
  bool success :1;
} _Controller_currentRobot_result__isset;

class Controller_currentRobot_result {
 public:

  Controller_currentRobot_result(const Controller_currentRobot_result&) noexcept;
  Controller_currentRobot_result& operator=(const Controller_currentRobot_result&) noexcept;
  Controller_currentRobot_result() noexcept
                                 : success(0) {
  }

  virtual ~Controller_currentRobot_result() noexcept;
  RobotIndex success;

  _Controller_currentRobot_result__isset __isset;

  void __set_success(const RobotIndex val);

  bool operator == (const Controller_currentRobot_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Controller_currentRobot_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_currentRobot_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_currentRobot_presult__isset {
  _Controller_currentRobot_presult__isset() : success(false) {}
  bool success :1;
} _Controller_currentRobot_presult__isset;

class Controller_currentRobot_presult {
 public:


  virtual ~Controller_currentRobot_presult() noexcept;
  RobotIndex* success;

  _Controller_currentRobot_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_variable_args__isset {
  _Controller_variable_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_variable_args__isset;

class Controller_variable_args {
 public:

  Controller_variable_args(const Controller_variable_args&);
  Controller_variable_args& operator=(const Controller_variable_args&);
  Controller_variable_args() noexcept
                           : c(0),
                             name() {
  }

  virtual ~Controller_variable_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_variable_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_variable_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_variable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_variable_pargs {
 public:


  virtual ~Controller_variable_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variable_result__isset {
  _Controller_variable_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variable_result__isset;

class Controller_variable_result {
 public:

  Controller_variable_result(const Controller_variable_result&);
  Controller_variable_result& operator=(const Controller_variable_result&);
  Controller_variable_result() noexcept {
  }

  virtual ~Controller_variable_result() noexcept;
  Any success;
  IllegalArgument e;

  _Controller_variable_result__isset __isset;

  void __set_success(const Any& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_variable_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_variable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variable_presult__isset {
  _Controller_variable_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variable_presult__isset;

class Controller_variable_presult {
 public:


  virtual ~Controller_variable_presult() noexcept;
  Any* success;
  IllegalArgument e;

  _Controller_variable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_variableByAddr_args__isset {
  _Controller_variableByAddr_args__isset() : c(false), addr(false) {}
  bool c :1;
  bool addr :1;
} _Controller_variableByAddr_args__isset;

class Controller_variableByAddr_args {
 public:

  Controller_variableByAddr_args(const Controller_variableByAddr_args&) noexcept;
  Controller_variableByAddr_args& operator=(const Controller_variableByAddr_args&) noexcept;
  Controller_variableByAddr_args() noexcept
                                 : c(0) {
  }

  virtual ~Controller_variableByAddr_args() noexcept;
  ControllerID c;
  VariableAddress addr;

  _Controller_variableByAddr_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_addr(const VariableAddress& val);

  bool operator == (const Controller_variableByAddr_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(addr == rhs.addr))
      return false;
    return true;
  }
  bool operator != (const Controller_variableByAddr_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variableByAddr_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_variableByAddr_pargs {
 public:


  virtual ~Controller_variableByAddr_pargs() noexcept;
  const ControllerID* c;
  const VariableAddress* addr;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variableByAddr_result__isset {
  _Controller_variableByAddr_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variableByAddr_result__isset;

class Controller_variableByAddr_result {
 public:

  Controller_variableByAddr_result(const Controller_variableByAddr_result&);
  Controller_variableByAddr_result& operator=(const Controller_variableByAddr_result&);
  Controller_variableByAddr_result() noexcept {
  }

  virtual ~Controller_variableByAddr_result() noexcept;
  Any success;
  IllegalArgument e;

  _Controller_variableByAddr_result__isset __isset;

  void __set_success(const Any& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_variableByAddr_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_variableByAddr_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variableByAddr_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variableByAddr_presult__isset {
  _Controller_variableByAddr_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variableByAddr_presult__isset;

class Controller_variableByAddr_presult {
 public:


  virtual ~Controller_variableByAddr_presult() noexcept;
  Any* success;
  IllegalArgument e;

  _Controller_variableByAddr_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setVariable_args__isset {
  _Controller_setVariable_args__isset() : c(false), name(false), value(false) {}
  bool c :1;
  bool name :1;
  bool value :1;
} _Controller_setVariable_args__isset;

class Controller_setVariable_args {
 public:

  Controller_setVariable_args(const Controller_setVariable_args&);
  Controller_setVariable_args& operator=(const Controller_setVariable_args&);
  Controller_setVariable_args() noexcept
                              : c(0),
                                name() {
  }

  virtual ~Controller_setVariable_args() noexcept;
  ControllerID c;
  std::string name;
  Any value;

  _Controller_setVariable_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  void __set_value(const Any& val);

  bool operator == (const Controller_setVariable_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Controller_setVariable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setVariable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setVariable_pargs {
 public:


  virtual ~Controller_setVariable_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;
  const Any* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setVariable_result__isset {
  _Controller_setVariable_result__isset() : e(false) {}
  bool e :1;
} _Controller_setVariable_result__isset;

class Controller_setVariable_result {
 public:

  Controller_setVariable_result(const Controller_setVariable_result&);
  Controller_setVariable_result& operator=(const Controller_setVariable_result&);
  Controller_setVariable_result() noexcept {
  }

  virtual ~Controller_setVariable_result() noexcept;
  IllegalArgument e;

  _Controller_setVariable_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_setVariable_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_setVariable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setVariable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setVariable_presult__isset {
  _Controller_setVariable_presult__isset() : e(false) {}
  bool e :1;
} _Controller_setVariable_presult__isset;

class Controller_setVariable_presult {
 public:


  virtual ~Controller_setVariable_presult() noexcept;
  IllegalArgument e;

  _Controller_setVariable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setVariableByAddr_args__isset {
  _Controller_setVariableByAddr_args__isset() : c(false), addr(false), value(false) {}
  bool c :1;
  bool addr :1;
  bool value :1;
} _Controller_setVariableByAddr_args__isset;

class Controller_setVariableByAddr_args {
 public:

  Controller_setVariableByAddr_args(const Controller_setVariableByAddr_args&);
  Controller_setVariableByAddr_args& operator=(const Controller_setVariableByAddr_args&);
  Controller_setVariableByAddr_args() noexcept
                                    : c(0) {
  }

  virtual ~Controller_setVariableByAddr_args() noexcept;
  ControllerID c;
  VariableAddress addr;
  Any value;

  _Controller_setVariableByAddr_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_addr(const VariableAddress& val);

  void __set_value(const Any& val);

  bool operator == (const Controller_setVariableByAddr_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(addr == rhs.addr))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Controller_setVariableByAddr_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setVariableByAddr_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setVariableByAddr_pargs {
 public:


  virtual ~Controller_setVariableByAddr_pargs() noexcept;
  const ControllerID* c;
  const VariableAddress* addr;
  const Any* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setVariableByAddr_result__isset {
  _Controller_setVariableByAddr_result__isset() : e(false) {}
  bool e :1;
} _Controller_setVariableByAddr_result__isset;

class Controller_setVariableByAddr_result {
 public:

  Controller_setVariableByAddr_result(const Controller_setVariableByAddr_result&);
  Controller_setVariableByAddr_result& operator=(const Controller_setVariableByAddr_result&);
  Controller_setVariableByAddr_result() noexcept {
  }

  virtual ~Controller_setVariableByAddr_result() noexcept;
  IllegalArgument e;

  _Controller_setVariableByAddr_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_setVariableByAddr_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_setVariableByAddr_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setVariableByAddr_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setVariableByAddr_presult__isset {
  _Controller_setVariableByAddr_presult__isset() : e(false) {}
  bool e :1;
} _Controller_setVariableByAddr_presult__isset;

class Controller_setVariableByAddr_presult {
 public:


  virtual ~Controller_setVariableByAddr_presult() noexcept;
  IllegalArgument e;

  _Controller_setVariableByAddr_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_variableAddrByNameAndSpace_args__isset {
  _Controller_variableAddrByNameAndSpace_args__isset() : c(false), name(false), space(false) {}
  bool c :1;
  bool name :1;
  bool space :1;
} _Controller_variableAddrByNameAndSpace_args__isset;

class Controller_variableAddrByNameAndSpace_args {
 public:

  Controller_variableAddrByNameAndSpace_args(const Controller_variableAddrByNameAndSpace_args&);
  Controller_variableAddrByNameAndSpace_args& operator=(const Controller_variableAddrByNameAndSpace_args&);
  Controller_variableAddrByNameAndSpace_args() noexcept
                                             : c(0),
                                               name(),
                                               space(static_cast<AddressSpace::type>(0)) {
  }

  virtual ~Controller_variableAddrByNameAndSpace_args() noexcept;
  ControllerID c;
  std::string name;
  /**
   * 
   * @see AddressSpace
   */
  AddressSpace::type space;

  _Controller_variableAddrByNameAndSpace_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  void __set_space(const AddressSpace::type val);

  bool operator == (const Controller_variableAddrByNameAndSpace_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(space == rhs.space))
      return false;
    return true;
  }
  bool operator != (const Controller_variableAddrByNameAndSpace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variableAddrByNameAndSpace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_variableAddrByNameAndSpace_pargs {
 public:


  virtual ~Controller_variableAddrByNameAndSpace_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;
  /**
   * 
   * @see AddressSpace
   */
  const AddressSpace::type* space;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variableAddrByNameAndSpace_result__isset {
  _Controller_variableAddrByNameAndSpace_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variableAddrByNameAndSpace_result__isset;

class Controller_variableAddrByNameAndSpace_result {
 public:

  Controller_variableAddrByNameAndSpace_result(const Controller_variableAddrByNameAndSpace_result&);
  Controller_variableAddrByNameAndSpace_result& operator=(const Controller_variableAddrByNameAndSpace_result&);
  Controller_variableAddrByNameAndSpace_result() noexcept {
  }

  virtual ~Controller_variableAddrByNameAndSpace_result() noexcept;
  VariableAddress success;
  IllegalArgument e;

  _Controller_variableAddrByNameAndSpace_result__isset __isset;

  void __set_success(const VariableAddress& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_variableAddrByNameAndSpace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_variableAddrByNameAndSpace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variableAddrByNameAndSpace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variableAddrByNameAndSpace_presult__isset {
  _Controller_variableAddrByNameAndSpace_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variableAddrByNameAndSpace_presult__isset;

class Controller_variableAddrByNameAndSpace_presult {
 public:


  virtual ~Controller_variableAddrByNameAndSpace_presult() noexcept;
  VariableAddress* success;
  IllegalArgument e;

  _Controller_variableAddrByNameAndSpace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_variableAddrByName_args__isset {
  _Controller_variableAddrByName_args__isset() : c(false), name(false) {}
  bool c :1;
  bool name :1;
} _Controller_variableAddrByName_args__isset;

class Controller_variableAddrByName_args {
 public:

  Controller_variableAddrByName_args(const Controller_variableAddrByName_args&);
  Controller_variableAddrByName_args& operator=(const Controller_variableAddrByName_args&);
  Controller_variableAddrByName_args() noexcept
                                     : c(0),
                                       name() {
  }

  virtual ~Controller_variableAddrByName_args() noexcept;
  ControllerID c;
  std::string name;

  _Controller_variableAddrByName_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_variableAddrByName_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_variableAddrByName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variableAddrByName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_variableAddrByName_pargs {
 public:


  virtual ~Controller_variableAddrByName_pargs() noexcept;
  const ControllerID* c;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variableAddrByName_result__isset {
  _Controller_variableAddrByName_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variableAddrByName_result__isset;

class Controller_variableAddrByName_result {
 public:

  Controller_variableAddrByName_result(const Controller_variableAddrByName_result&);
  Controller_variableAddrByName_result& operator=(const Controller_variableAddrByName_result&);
  Controller_variableAddrByName_result() noexcept {
  }

  virtual ~Controller_variableAddrByName_result() noexcept;
  VariableAddress success;
  IllegalArgument e;

  _Controller_variableAddrByName_result__isset __isset;

  void __set_success(const VariableAddress& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_variableAddrByName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_variableAddrByName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_variableAddrByName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_variableAddrByName_presult__isset {
  _Controller_variableAddrByName_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_variableAddrByName_presult__isset;

class Controller_variableAddrByName_presult {
 public:


  virtual ~Controller_variableAddrByName_presult() noexcept;
  VariableAddress* success;
  IllegalArgument e;

  _Controller_variableAddrByName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setVariableName_args__isset {
  _Controller_setVariableName_args__isset() : c(false), addr(false), name(false) {}
  bool c :1;
  bool addr :1;
  bool name :1;
} _Controller_setVariableName_args__isset;

class Controller_setVariableName_args {
 public:

  Controller_setVariableName_args(const Controller_setVariableName_args&);
  Controller_setVariableName_args& operator=(const Controller_setVariableName_args&);
  Controller_setVariableName_args() noexcept
                                  : c(0),
                                    name() {
  }

  virtual ~Controller_setVariableName_args() noexcept;
  ControllerID c;
  VariableAddress addr;
  std::string name;

  _Controller_setVariableName_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_addr(const VariableAddress& val);

  void __set_name(const std::string& val);

  bool operator == (const Controller_setVariableName_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(addr == rhs.addr))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Controller_setVariableName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setVariableName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setVariableName_pargs {
 public:


  virtual ~Controller_setVariableName_pargs() noexcept;
  const ControllerID* c;
  const VariableAddress* addr;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setVariableName_result__isset {
  _Controller_setVariableName_result__isset() : e(false) {}
  bool e :1;
} _Controller_setVariableName_result__isset;

class Controller_setVariableName_result {
 public:

  Controller_setVariableName_result(const Controller_setVariableName_result&);
  Controller_setVariableName_result& operator=(const Controller_setVariableName_result&);
  Controller_setVariableName_result() noexcept {
  }

  virtual ~Controller_setVariableName_result() noexcept;
  IllegalArgument e;

  _Controller_setVariableName_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_setVariableName_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_setVariableName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setVariableName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setVariableName_presult__isset {
  _Controller_setVariableName_presult__isset() : e(false) {}
  bool e :1;
} _Controller_setVariableName_presult__isset;

class Controller_setVariableName_presult {
 public:


  virtual ~Controller_setVariableName_presult() noexcept;
  IllegalArgument e;

  _Controller_setVariableName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_zone_args__isset {
  _Controller_zone_args__isset() : c(false), index(false) {}
  bool c :1;
  bool index :1;
} _Controller_zone_args__isset;

class Controller_zone_args {
 public:

  Controller_zone_args(const Controller_zone_args&) noexcept;
  Controller_zone_args& operator=(const Controller_zone_args&) noexcept;
  Controller_zone_args() noexcept
                       : c(0),
                         index(0) {
  }

  virtual ~Controller_zone_args() noexcept;
  ControllerID c;
  ZoneIndex index;

  _Controller_zone_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_index(const ZoneIndex val);

  bool operator == (const Controller_zone_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const Controller_zone_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_zone_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_zone_pargs {
 public:


  virtual ~Controller_zone_pargs() noexcept;
  const ControllerID* c;
  const ZoneIndex* index;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_zone_result__isset {
  _Controller_zone_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_zone_result__isset;

class Controller_zone_result {
 public:

  Controller_zone_result(const Controller_zone_result&);
  Controller_zone_result& operator=(const Controller_zone_result&);
  Controller_zone_result() noexcept {
  }

  virtual ~Controller_zone_result() noexcept;
  Zone success;
  IllegalArgument e;

  _Controller_zone_result__isset __isset;

  void __set_success(const Zone& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_zone_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_zone_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_zone_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_zone_presult__isset {
  _Controller_zone_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_zone_presult__isset;

class Controller_zone_presult {
 public:


  virtual ~Controller_zone_presult() noexcept;
  Zone* success;
  IllegalArgument e;

  _Controller_zone_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_newZone_args__isset {
  _Controller_newZone_args__isset() : c(false) {}
  bool c :1;
} _Controller_newZone_args__isset;

class Controller_newZone_args {
 public:

  Controller_newZone_args(const Controller_newZone_args&) noexcept;
  Controller_newZone_args& operator=(const Controller_newZone_args&) noexcept;
  Controller_newZone_args() noexcept
                          : c(0) {
  }

  virtual ~Controller_newZone_args() noexcept;
  ControllerID c;

  _Controller_newZone_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_newZone_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_newZone_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_newZone_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_newZone_pargs {
 public:


  virtual ~Controller_newZone_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_newZone_result__isset {
  _Controller_newZone_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_newZone_result__isset;

class Controller_newZone_result {
 public:

  Controller_newZone_result(const Controller_newZone_result&);
  Controller_newZone_result& operator=(const Controller_newZone_result&);
  Controller_newZone_result() noexcept
                            : success(0) {
  }

  virtual ~Controller_newZone_result() noexcept;
  ZoneIndex success;
  IllegalArgument e;

  _Controller_newZone_result__isset __isset;

  void __set_success(const ZoneIndex val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_newZone_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_newZone_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_newZone_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_newZone_presult__isset {
  _Controller_newZone_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_newZone_presult__isset;

class Controller_newZone_presult {
 public:


  virtual ~Controller_newZone_presult() noexcept;
  ZoneIndex* success;
  IllegalArgument e;

  _Controller_newZone_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_modifyZone_args__isset {
  _Controller_modifyZone_args__isset() : c(false), index(false), z(false) {}
  bool c :1;
  bool index :1;
  bool z :1;
} _Controller_modifyZone_args__isset;

class Controller_modifyZone_args {
 public:

  Controller_modifyZone_args(const Controller_modifyZone_args&);
  Controller_modifyZone_args& operator=(const Controller_modifyZone_args&);
  Controller_modifyZone_args() noexcept
                             : c(0),
                               index(0) {
  }

  virtual ~Controller_modifyZone_args() noexcept;
  ControllerID c;
  ZoneIndex index;
  Zone z;

  _Controller_modifyZone_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_index(const ZoneIndex val);

  void __set_z(const Zone& val);

  bool operator == (const Controller_modifyZone_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(index == rhs.index))
      return false;
    if (!(z == rhs.z))
      return false;
    return true;
  }
  bool operator != (const Controller_modifyZone_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_modifyZone_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_modifyZone_pargs {
 public:


  virtual ~Controller_modifyZone_pargs() noexcept;
  const ControllerID* c;
  const ZoneIndex* index;
  const Zone* z;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_modifyZone_result__isset {
  _Controller_modifyZone_result__isset() : e(false) {}
  bool e :1;
} _Controller_modifyZone_result__isset;

class Controller_modifyZone_result {
 public:

  Controller_modifyZone_result(const Controller_modifyZone_result&);
  Controller_modifyZone_result& operator=(const Controller_modifyZone_result&);
  Controller_modifyZone_result() noexcept {
  }

  virtual ~Controller_modifyZone_result() noexcept;
  IllegalArgument e;

  _Controller_modifyZone_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_modifyZone_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_modifyZone_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_modifyZone_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_modifyZone_presult__isset {
  _Controller_modifyZone_presult__isset() : e(false) {}
  bool e :1;
} _Controller_modifyZone_presult__isset;

class Controller_modifyZone_presult {
 public:


  virtual ~Controller_modifyZone_presult() noexcept;
  IllegalArgument e;

  _Controller_modifyZone_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_deleteZone_args__isset {
  _Controller_deleteZone_args__isset() : c(false), index(false) {}
  bool c :1;
  bool index :1;
} _Controller_deleteZone_args__isset;

class Controller_deleteZone_args {
 public:

  Controller_deleteZone_args(const Controller_deleteZone_args&) noexcept;
  Controller_deleteZone_args& operator=(const Controller_deleteZone_args&) noexcept;
  Controller_deleteZone_args() noexcept
                             : c(0),
                               index(0) {
  }

  virtual ~Controller_deleteZone_args() noexcept;
  ControllerID c;
  ZoneIndex index;

  _Controller_deleteZone_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_index(const ZoneIndex val);

  bool operator == (const Controller_deleteZone_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const Controller_deleteZone_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_deleteZone_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_deleteZone_pargs {
 public:


  virtual ~Controller_deleteZone_pargs() noexcept;
  const ControllerID* c;
  const ZoneIndex* index;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_deleteZone_result__isset {
  _Controller_deleteZone_result__isset() : e(false) {}
  bool e :1;
} _Controller_deleteZone_result__isset;

class Controller_deleteZone_result {
 public:

  Controller_deleteZone_result(const Controller_deleteZone_result&);
  Controller_deleteZone_result& operator=(const Controller_deleteZone_result&);
  Controller_deleteZone_result() noexcept {
  }

  virtual ~Controller_deleteZone_result() noexcept;
  IllegalArgument e;

  _Controller_deleteZone_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_deleteZone_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_deleteZone_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_deleteZone_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_deleteZone_presult__isset {
  _Controller_deleteZone_presult__isset() : e(false) {}
  bool e :1;
} _Controller_deleteZone_presult__isset;

class Controller_deleteZone_presult {
 public:


  virtual ~Controller_deleteZone_presult() noexcept;
  IllegalArgument e;

  _Controller_deleteZone_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_userFrames_args__isset {
  _Controller_userFrames_args__isset() : c(false) {}
  bool c :1;
} _Controller_userFrames_args__isset;

class Controller_userFrames_args {
 public:

  Controller_userFrames_args(const Controller_userFrames_args&) noexcept;
  Controller_userFrames_args& operator=(const Controller_userFrames_args&) noexcept;
  Controller_userFrames_args() noexcept
                             : c(0) {
  }

  virtual ~Controller_userFrames_args() noexcept;
  ControllerID c;

  _Controller_userFrames_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_userFrames_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_userFrames_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_userFrames_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_userFrames_pargs {
 public:


  virtual ~Controller_userFrames_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_userFrames_result__isset {
  _Controller_userFrames_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_userFrames_result__isset;

class Controller_userFrames_result {
 public:

  Controller_userFrames_result(const Controller_userFrames_result&);
  Controller_userFrames_result& operator=(const Controller_userFrames_result&);
  Controller_userFrames_result() noexcept {
  }

  virtual ~Controller_userFrames_result() noexcept;
  std::map<UserFrameIndex, std::string>  success;
  IllegalArgument e;

  _Controller_userFrames_result__isset __isset;

  void __set_success(const std::map<UserFrameIndex, std::string> & val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_userFrames_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_userFrames_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_userFrames_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_userFrames_presult__isset {
  _Controller_userFrames_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_userFrames_presult__isset;

class Controller_userFrames_presult {
 public:


  virtual ~Controller_userFrames_presult() noexcept;
  std::map<UserFrameIndex, std::string> * success;
  IllegalArgument e;

  _Controller_userFrames_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_userFrame_args__isset {
  _Controller_userFrame_args__isset() : c(false), index(false) {}
  bool c :1;
  bool index :1;
} _Controller_userFrame_args__isset;

class Controller_userFrame_args {
 public:

  Controller_userFrame_args(const Controller_userFrame_args&) noexcept;
  Controller_userFrame_args& operator=(const Controller_userFrame_args&) noexcept;
  Controller_userFrame_args() noexcept
                            : c(0),
                              index(0) {
  }

  virtual ~Controller_userFrame_args() noexcept;
  ControllerID c;
  UserFrameIndex index;

  _Controller_userFrame_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_index(const UserFrameIndex val);

  bool operator == (const Controller_userFrame_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const Controller_userFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_userFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_userFrame_pargs {
 public:


  virtual ~Controller_userFrame_pargs() noexcept;
  const ControllerID* c;
  const UserFrameIndex* index;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_userFrame_result__isset {
  _Controller_userFrame_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_userFrame_result__isset;

class Controller_userFrame_result {
 public:

  Controller_userFrame_result(const Controller_userFrame_result&);
  Controller_userFrame_result& operator=(const Controller_userFrame_result&);
  Controller_userFrame_result() noexcept {
  }

  virtual ~Controller_userFrame_result() noexcept;
  CoordinateFrame success;
  IllegalArgument e;

  _Controller_userFrame_result__isset __isset;

  void __set_success(const CoordinateFrame& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_userFrame_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_userFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_userFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_userFrame_presult__isset {
  _Controller_userFrame_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_userFrame_presult__isset;

class Controller_userFrame_presult {
 public:


  virtual ~Controller_userFrame_presult() noexcept;
  CoordinateFrame* success;
  IllegalArgument e;

  _Controller_userFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_newUserFrame_args__isset {
  _Controller_newUserFrame_args__isset() : c(false) {}
  bool c :1;
} _Controller_newUserFrame_args__isset;

class Controller_newUserFrame_args {
 public:

  Controller_newUserFrame_args(const Controller_newUserFrame_args&) noexcept;
  Controller_newUserFrame_args& operator=(const Controller_newUserFrame_args&) noexcept;
  Controller_newUserFrame_args() noexcept
                               : c(0) {
  }

  virtual ~Controller_newUserFrame_args() noexcept;
  ControllerID c;

  _Controller_newUserFrame_args__isset __isset;

  void __set_c(const ControllerID val);

  bool operator == (const Controller_newUserFrame_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const Controller_newUserFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_newUserFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_newUserFrame_pargs {
 public:


  virtual ~Controller_newUserFrame_pargs() noexcept;
  const ControllerID* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_newUserFrame_result__isset {
  _Controller_newUserFrame_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_newUserFrame_result__isset;

class Controller_newUserFrame_result {
 public:

  Controller_newUserFrame_result(const Controller_newUserFrame_result&);
  Controller_newUserFrame_result& operator=(const Controller_newUserFrame_result&);
  Controller_newUserFrame_result() noexcept
                                 : success(0) {
  }

  virtual ~Controller_newUserFrame_result() noexcept;
  UserFrameIndex success;
  IllegalArgument e;

  _Controller_newUserFrame_result__isset __isset;

  void __set_success(const UserFrameIndex val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_newUserFrame_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_newUserFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_newUserFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_newUserFrame_presult__isset {
  _Controller_newUserFrame_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_newUserFrame_presult__isset;

class Controller_newUserFrame_presult {
 public:


  virtual ~Controller_newUserFrame_presult() noexcept;
  UserFrameIndex* success;
  IllegalArgument e;

  _Controller_newUserFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_setUserFrame_args__isset {
  _Controller_setUserFrame_args__isset() : c(false), index(false), f(false) {}
  bool c :1;
  bool index :1;
  bool f :1;
} _Controller_setUserFrame_args__isset;

class Controller_setUserFrame_args {
 public:

  Controller_setUserFrame_args(const Controller_setUserFrame_args&);
  Controller_setUserFrame_args& operator=(const Controller_setUserFrame_args&);
  Controller_setUserFrame_args() noexcept
                               : c(0),
                                 index(0) {
  }

  virtual ~Controller_setUserFrame_args() noexcept;
  ControllerID c;
  UserFrameIndex index;
  CoordinateFrame f;

  _Controller_setUserFrame_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_index(const UserFrameIndex val);

  void __set_f(const CoordinateFrame& val);

  bool operator == (const Controller_setUserFrame_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(index == rhs.index))
      return false;
    if (!(f == rhs.f))
      return false;
    return true;
  }
  bool operator != (const Controller_setUserFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setUserFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_setUserFrame_pargs {
 public:


  virtual ~Controller_setUserFrame_pargs() noexcept;
  const ControllerID* c;
  const UserFrameIndex* index;
  const CoordinateFrame* f;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setUserFrame_result__isset {
  _Controller_setUserFrame_result__isset() : e(false) {}
  bool e :1;
} _Controller_setUserFrame_result__isset;

class Controller_setUserFrame_result {
 public:

  Controller_setUserFrame_result(const Controller_setUserFrame_result&);
  Controller_setUserFrame_result& operator=(const Controller_setUserFrame_result&);
  Controller_setUserFrame_result() noexcept {
  }

  virtual ~Controller_setUserFrame_result() noexcept;
  IllegalArgument e;

  _Controller_setUserFrame_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_setUserFrame_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_setUserFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_setUserFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_setUserFrame_presult__isset {
  _Controller_setUserFrame_presult__isset() : e(false) {}
  bool e :1;
} _Controller_setUserFrame_presult__isset;

class Controller_setUserFrame_presult {
 public:


  virtual ~Controller_setUserFrame_presult() noexcept;
  IllegalArgument e;

  _Controller_setUserFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_deleteUserFrame_args__isset {
  _Controller_deleteUserFrame_args__isset() : c(false), index(false) {}
  bool c :1;
  bool index :1;
} _Controller_deleteUserFrame_args__isset;

class Controller_deleteUserFrame_args {
 public:

  Controller_deleteUserFrame_args(const Controller_deleteUserFrame_args&) noexcept;
  Controller_deleteUserFrame_args& operator=(const Controller_deleteUserFrame_args&) noexcept;
  Controller_deleteUserFrame_args() noexcept
                                  : c(0),
                                    index(0) {
  }

  virtual ~Controller_deleteUserFrame_args() noexcept;
  ControllerID c;
  UserFrameIndex index;

  _Controller_deleteUserFrame_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_index(const UserFrameIndex val);

  bool operator == (const Controller_deleteUserFrame_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const Controller_deleteUserFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_deleteUserFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_deleteUserFrame_pargs {
 public:


  virtual ~Controller_deleteUserFrame_pargs() noexcept;
  const ControllerID* c;
  const UserFrameIndex* index;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_deleteUserFrame_result__isset {
  _Controller_deleteUserFrame_result__isset() : e(false) {}
  bool e :1;
} _Controller_deleteUserFrame_result__isset;

class Controller_deleteUserFrame_result {
 public:

  Controller_deleteUserFrame_result(const Controller_deleteUserFrame_result&);
  Controller_deleteUserFrame_result& operator=(const Controller_deleteUserFrame_result&);
  Controller_deleteUserFrame_result() noexcept {
  }

  virtual ~Controller_deleteUserFrame_result() noexcept;
  IllegalArgument e;

  _Controller_deleteUserFrame_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_deleteUserFrame_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_deleteUserFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_deleteUserFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_deleteUserFrame_presult__isset {
  _Controller_deleteUserFrame_presult__isset() : e(false) {}
  bool e :1;
} _Controller_deleteUserFrame_presult__isset;

class Controller_deleteUserFrame_presult {
 public:


  virtual ~Controller_deleteUserFrame_presult() noexcept;
  IllegalArgument e;

  _Controller_deleteUserFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_networkInterfaceAddress_args__isset {
  _Controller_networkInterfaceAddress_args__isset() : c(false), controllerInterface(false) {}
  bool c :1;
  bool controllerInterface :1;
} _Controller_networkInterfaceAddress_args__isset;

class Controller_networkInterfaceAddress_args {
 public:

  Controller_networkInterfaceAddress_args(const Controller_networkInterfaceAddress_args&);
  Controller_networkInterfaceAddress_args& operator=(const Controller_networkInterfaceAddress_args&);
  Controller_networkInterfaceAddress_args() noexcept
                                          : c(0),
                                            controllerInterface() {
  }

  virtual ~Controller_networkInterfaceAddress_args() noexcept;
  ControllerID c;
  std::string controllerInterface;

  _Controller_networkInterfaceAddress_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_controllerInterface(const std::string& val);

  bool operator == (const Controller_networkInterfaceAddress_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(controllerInterface == rhs.controllerInterface))
      return false;
    return true;
  }
  bool operator != (const Controller_networkInterfaceAddress_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_networkInterfaceAddress_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_networkInterfaceAddress_pargs {
 public:


  virtual ~Controller_networkInterfaceAddress_pargs() noexcept;
  const ControllerID* c;
  const std::string* controllerInterface;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_networkInterfaceAddress_result__isset {
  _Controller_networkInterfaceAddress_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_networkInterfaceAddress_result__isset;

class Controller_networkInterfaceAddress_result {
 public:

  Controller_networkInterfaceAddress_result(const Controller_networkInterfaceAddress_result&);
  Controller_networkInterfaceAddress_result& operator=(const Controller_networkInterfaceAddress_result&);
  Controller_networkInterfaceAddress_result() noexcept
                                            : success() {
  }

  virtual ~Controller_networkInterfaceAddress_result() noexcept;
  std::string success;
  IllegalArgument e;

  _Controller_networkInterfaceAddress_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_networkInterfaceAddress_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_networkInterfaceAddress_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_networkInterfaceAddress_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_networkInterfaceAddress_presult__isset {
  _Controller_networkInterfaceAddress_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_networkInterfaceAddress_presult__isset;

class Controller_networkInterfaceAddress_presult {
 public:


  virtual ~Controller_networkInterfaceAddress_presult() noexcept;
  std::string* success;
  IllegalArgument e;

  _Controller_networkInterfaceAddress_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_requestNetworkAccess_args__isset {
  _Controller_requestNetworkAccess_args__isset() : c(false), controllerInterface(false), port(false), protocol(false) {}
  bool c :1;
  bool controllerInterface :1;
  bool port :1;
  bool protocol :1;
} _Controller_requestNetworkAccess_args__isset;

class Controller_requestNetworkAccess_args {
 public:

  Controller_requestNetworkAccess_args(const Controller_requestNetworkAccess_args&);
  Controller_requestNetworkAccess_args& operator=(const Controller_requestNetworkAccess_args&);
  Controller_requestNetworkAccess_args() noexcept
                                       : c(0),
                                         controllerInterface(),
                                         port(0),
                                         protocol() {
  }

  virtual ~Controller_requestNetworkAccess_args() noexcept;
  ControllerID c;
  std::string controllerInterface;
  int32_t port;
  std::string protocol;

  _Controller_requestNetworkAccess_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_controllerInterface(const std::string& val);

  void __set_port(const int32_t val);

  void __set_protocol(const std::string& val);

  bool operator == (const Controller_requestNetworkAccess_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(controllerInterface == rhs.controllerInterface))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(protocol == rhs.protocol))
      return false;
    return true;
  }
  bool operator != (const Controller_requestNetworkAccess_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_requestNetworkAccess_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_requestNetworkAccess_pargs {
 public:


  virtual ~Controller_requestNetworkAccess_pargs() noexcept;
  const ControllerID* c;
  const std::string* controllerInterface;
  const int32_t* port;
  const std::string* protocol;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_requestNetworkAccess_result__isset {
  _Controller_requestNetworkAccess_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_requestNetworkAccess_result__isset;

class Controller_requestNetworkAccess_result {
 public:

  Controller_requestNetworkAccess_result(const Controller_requestNetworkAccess_result&);
  Controller_requestNetworkAccess_result& operator=(const Controller_requestNetworkAccess_result&);
  Controller_requestNetworkAccess_result() noexcept
                                         : success(0) {
  }

  virtual ~Controller_requestNetworkAccess_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_requestNetworkAccess_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_requestNetworkAccess_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_requestNetworkAccess_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_requestNetworkAccess_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_requestNetworkAccess_presult__isset {
  _Controller_requestNetworkAccess_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_requestNetworkAccess_presult__isset;

class Controller_requestNetworkAccess_presult {
 public:


  virtual ~Controller_requestNetworkAccess_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_requestNetworkAccess_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_removeNetworkAccess_args__isset {
  _Controller_removeNetworkAccess_args__isset() : c(false), accessHandle(false) {}
  bool c :1;
  bool accessHandle :1;
} _Controller_removeNetworkAccess_args__isset;

class Controller_removeNetworkAccess_args {
 public:

  Controller_removeNetworkAccess_args(const Controller_removeNetworkAccess_args&) noexcept;
  Controller_removeNetworkAccess_args& operator=(const Controller_removeNetworkAccess_args&) noexcept;
  Controller_removeNetworkAccess_args() noexcept
                                      : c(0),
                                        accessHandle(0) {
  }

  virtual ~Controller_removeNetworkAccess_args() noexcept;
  ControllerID c;
  int32_t accessHandle;

  _Controller_removeNetworkAccess_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_accessHandle(const int32_t val);

  bool operator == (const Controller_removeNetworkAccess_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(accessHandle == rhs.accessHandle))
      return false;
    return true;
  }
  bool operator != (const Controller_removeNetworkAccess_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_removeNetworkAccess_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_removeNetworkAccess_pargs {
 public:


  virtual ~Controller_removeNetworkAccess_pargs() noexcept;
  const ControllerID* c;
  const int32_t* accessHandle;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_removeNetworkAccess_result__isset {
  _Controller_removeNetworkAccess_result__isset() : e(false) {}
  bool e :1;
} _Controller_removeNetworkAccess_result__isset;

class Controller_removeNetworkAccess_result {
 public:

  Controller_removeNetworkAccess_result(const Controller_removeNetworkAccess_result&);
  Controller_removeNetworkAccess_result& operator=(const Controller_removeNetworkAccess_result&);
  Controller_removeNetworkAccess_result() noexcept {
  }

  virtual ~Controller_removeNetworkAccess_result() noexcept;
  IllegalArgument e;

  _Controller_removeNetworkAccess_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_removeNetworkAccess_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_removeNetworkAccess_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_removeNetworkAccess_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_removeNetworkAccess_presult__isset {
  _Controller_removeNetworkAccess_presult__isset() : e(false) {}
  bool e :1;
} _Controller_removeNetworkAccess_presult__isset;

class Controller_removeNetworkAccess_presult {
 public:


  virtual ~Controller_removeNetworkAccess_presult() noexcept;
  IllegalArgument e;

  _Controller_removeNetworkAccess_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_requestNetworkService_args__isset {
  _Controller_requestNetworkService_args__isset() : c(false), controllerInterface(false), port(false), protocol(false) {}
  bool c :1;
  bool controllerInterface :1;
  bool port :1;
  bool protocol :1;
} _Controller_requestNetworkService_args__isset;

class Controller_requestNetworkService_args {
 public:

  Controller_requestNetworkService_args(const Controller_requestNetworkService_args&);
  Controller_requestNetworkService_args& operator=(const Controller_requestNetworkService_args&);
  Controller_requestNetworkService_args() noexcept
                                        : c(0),
                                          controllerInterface(),
                                          port(0),
                                          protocol() {
  }

  virtual ~Controller_requestNetworkService_args() noexcept;
  ControllerID c;
  std::string controllerInterface;
  int32_t port;
  std::string protocol;

  _Controller_requestNetworkService_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_controllerInterface(const std::string& val);

  void __set_port(const int32_t val);

  void __set_protocol(const std::string& val);

  bool operator == (const Controller_requestNetworkService_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(controllerInterface == rhs.controllerInterface))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(protocol == rhs.protocol))
      return false;
    return true;
  }
  bool operator != (const Controller_requestNetworkService_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_requestNetworkService_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_requestNetworkService_pargs {
 public:


  virtual ~Controller_requestNetworkService_pargs() noexcept;
  const ControllerID* c;
  const std::string* controllerInterface;
  const int32_t* port;
  const std::string* protocol;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_requestNetworkService_result__isset {
  _Controller_requestNetworkService_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_requestNetworkService_result__isset;

class Controller_requestNetworkService_result {
 public:

  Controller_requestNetworkService_result(const Controller_requestNetworkService_result&);
  Controller_requestNetworkService_result& operator=(const Controller_requestNetworkService_result&);
  Controller_requestNetworkService_result() noexcept
                                          : success(0) {
  }

  virtual ~Controller_requestNetworkService_result() noexcept;
  int32_t success;
  IllegalArgument e;

  _Controller_requestNetworkService_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_requestNetworkService_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_requestNetworkService_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_requestNetworkService_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_requestNetworkService_presult__isset {
  _Controller_requestNetworkService_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Controller_requestNetworkService_presult__isset;

class Controller_requestNetworkService_presult {
 public:


  virtual ~Controller_requestNetworkService_presult() noexcept;
  int32_t* success;
  IllegalArgument e;

  _Controller_requestNetworkService_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Controller_removeNetworkService_args__isset {
  _Controller_removeNetworkService_args__isset() : c(false), accessHandle(false) {}
  bool c :1;
  bool accessHandle :1;
} _Controller_removeNetworkService_args__isset;

class Controller_removeNetworkService_args {
 public:

  Controller_removeNetworkService_args(const Controller_removeNetworkService_args&) noexcept;
  Controller_removeNetworkService_args& operator=(const Controller_removeNetworkService_args&) noexcept;
  Controller_removeNetworkService_args() noexcept
                                       : c(0),
                                         accessHandle(0) {
  }

  virtual ~Controller_removeNetworkService_args() noexcept;
  ControllerID c;
  int32_t accessHandle;

  _Controller_removeNetworkService_args__isset __isset;

  void __set_c(const ControllerID val);

  void __set_accessHandle(const int32_t val);

  bool operator == (const Controller_removeNetworkService_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(accessHandle == rhs.accessHandle))
      return false;
    return true;
  }
  bool operator != (const Controller_removeNetworkService_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_removeNetworkService_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Controller_removeNetworkService_pargs {
 public:


  virtual ~Controller_removeNetworkService_pargs() noexcept;
  const ControllerID* c;
  const int32_t* accessHandle;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_removeNetworkService_result__isset {
  _Controller_removeNetworkService_result__isset() : e(false) {}
  bool e :1;
} _Controller_removeNetworkService_result__isset;

class Controller_removeNetworkService_result {
 public:

  Controller_removeNetworkService_result(const Controller_removeNetworkService_result&);
  Controller_removeNetworkService_result& operator=(const Controller_removeNetworkService_result&);
  Controller_removeNetworkService_result() noexcept {
  }

  virtual ~Controller_removeNetworkService_result() noexcept;
  IllegalArgument e;

  _Controller_removeNetworkService_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Controller_removeNetworkService_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Controller_removeNetworkService_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Controller_removeNetworkService_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Controller_removeNetworkService_presult__isset {
  _Controller_removeNetworkService_presult__isset() : e(false) {}
  bool e :1;
} _Controller_removeNetworkService_presult__isset;

class Controller_removeNetworkService_presult {
 public:


  virtual ~Controller_removeNetworkService_presult() noexcept;
  IllegalArgument e;

  _Controller_removeNetworkService_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ControllerClient : virtual public ControllerIf {
 public:
  ControllerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ControllerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Request specified permissions.
   * 
   * @param c
   * @param permissions
   */
  bool requestPermissions(const ControllerID c, const std::set<std::string> & permissions) override;
  void send_requestPermissions(const ControllerID c, const std::set<std::string> & permissions);
  bool recv_requestPermissions();
  /**
   * Check permisions obtained.
   * 
   * @param c
   * @param permission
   */
  bool havePermission(const ControllerID c, const std::string& permission) override;
  void send_havePermission(const ControllerID c, const std::string& permission);
  bool recv_havePermission();
  /**
   * Relinquish permissions (no effect if not held).
   * 
   * @param c
   * @param permissions
   */
  void relinquishPermissions(const ControllerID c, const std::set<std::string> & permissions) override;
  void send_relinquishPermissions(const ControllerID c, const std::set<std::string> & permissions);
  void recv_relinquishPermissions();
  /**
   * Connect to the specified Robot Controller (by IP adress or hostname if DNS available)
   * Typically, the pendant will already be connected to a controller when extensions are started,
   * so calling connect() is not required.
   * 
   * @param c
   * @param hostName
   */
  void connect(const ControllerID c, const std::string& hostName) override;
  void send_connect(const ControllerID c, const std::string& hostName);
  void recv_connect();
  /**
   * Disconnect from the connected controller.  This leaves the pendant in the 'disconnected' state.
   * When disconnected, many functions are unavailable or will return default values.
   * 
   * @param c
   */
  void disconnect(const ControllerID c) override;
  void send_disconnect(const ControllerID c);
  void recv_disconnect();
  /**
   * Subscribe to the specified events, if not already.
   * Note: If using a Yaskawa supplied client library with event consumer callback support,
   *       registering an event consumer callback will automatically subscribe to the appropriate event.
   * 
   * @param c
   * @param types
   */
  void subscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) override;
  void send_subscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types);
  void recv_subscribeEventTypes();
  /**
   * Unsubscribe from the specified events.
   * If called directly, this may causes event consumers for the events not to be called.
   * 
   * @param c
   * @param types
   */
  void unsubscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) override;
  void send_unsubscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types);
  void recv_unsubscribeEventTypes();
  /**
   * Poll the API Service for pending events.
   * Note: If using a Yaskawa supplied client library, this does not need to be called explicitly.
   * 
   * @param c
   */
  void events(std::vector<ControllerEvent> & _return, const ControllerID c) override;
  void send_events(const ControllerID c);
  void recv_events(std::vector<ControllerEvent> & _return);
  /**
   * Returns true if the pendant is connected to a robot controller
   * 
   * @param c
   */
  bool connected(const ControllerID c) override;
  void send_connected(const ControllerID c);
  bool recv_connected();
  /**
   * Returns the hostname or IP address of the robot controller to which the pendant is connected, if any
   * 
   * @param c
   */
  void connectedHostName(std::string& _return, const ControllerID c) override;
  void send_connectedHostName(const ControllerID c);
  void recv_connectedHostName(std::string& _return);
  /**
   * The software version string of the robot controller system software.
   * 
   * @param c
   */
  void softwareVersion(std::string& _return, const ControllerID c) override;
  void send_softwareVersion(const ControllerID c);
  void recv_softwareVersion(std::string& _return);
  /**
   * Returns true if the pendant is only monitoring the robot controller to which it is connected.  This
   * implies that no functions that modify the controller and/or robot state will succeed.
   * 
   * @param c
   */
  bool monitoring(const ControllerID c) override;
  void send_monitoring(const ControllerID c);
  bool recv_monitoring();
  /**
   * Returns true if this pendant is the single-point-of-control for the connected Robot Controller.
   * If not, most functions that modify the controller and/or robot state will fail.
   * 
   * @param c
   */
  bool haveExclusiveControl(const ControllerID c) override;
  void send_haveExclusiveControl(const ControllerID c);
  bool recv_haveExclusiveControl();
  /**
   * Current operation mode of the controller
   * Automatic (aka Play) - running jobs
   * Manual (aka Teach) - for editing jobs, teaching points, jogging, setup etc.
   * 
   * @param c
   */
  OperationMode::type operationMode(const ControllerID c) override;
  void send_operationMode(const ControllerID c);
  OperationMode::type recv_operationMode();
  /**
   * Are the servo drives engaged?
   * On - yes, robot(s) are being actively controlled
   * Off - no.  Typically brakes are engaged (unless brake-release engaged)
   * Ready - ready to engage servos.  Typically requires operator to use servo enable switch.
   * 
   * @param c
   */
  ServoState::type servoState(const ControllerID c) override;
  void send_servoState(const ControllerID c);
  ServoState::type recv_servoState();
  /**
   * Indicates if a job us running or stopped.
   * Run - jobs are running (robot may be moving)
   * Held - jobs were running but have been held/paused.
   * Idle - no jobs are running
   * 
   * @param c
   */
  PlaybackState::type playbackState(const ControllerID c) override;
  void send_playbackState(const ControllerID c);
  PlaybackState::type recv_playbackState();
  /**
   * Run the current robot job from the current line.  Requires Servos engaged & Automatic/Play operation and 'jobcontrol' permission.
   * 
   * @param c
   */
  void run(const ControllerID c) override;
  void send_run(const ControllerID c);
  void recv_run();
  /**
   * Pause running job (servoes will remain engaged. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void pause(const ControllerID c) override;
  void send_pause(const ControllerID c);
  void recv_pause();
  /**
   * Resume running job from paused state. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void resume(const ControllerID c) override;
  void send_resume(const ControllerID c);
  void recv_resume();
  /**
   * Stop runnng job (will stop motion and disengage servos). 'jobcontrol' permission required.
   * 
   * @param c
   */
  void stop(const ControllerID c) override;
  void send_stop(const ControllerID c);
  void recv_stop();
  /**
   * Name of the current job (e.g. job being run or edited)
   * Empty if none.
   * 
   * @param c
   */
  void currentJob(std::string& _return, const ControllerID c) override;
  void send_currentJob(const ControllerID c);
  void recv_currentJob(std::string& _return);
  /**
   * Set the current job. 'jobcontrol' permission required. Pass line=1 for start of job, line=0 for default/no-change.
   * 
   * @param c
   * @param name
   * @param line
   */
  void setCurrentJob(const ControllerID c, const std::string& name, const int32_t line) override;
  void send_setCurrentJob(const ControllerID c, const std::string& name, const int32_t line);
  void recv_setCurrentJob();
  /**
   * Name of the default (aka master) job.  Empty if no default job designated
   * 
   * @param c
   */
  void defaultJob(std::string& _return, const ControllerID c) override;
  void send_defaultJob(const ControllerID c);
  void recv_defaultJob(std::string& _return);
  /**
   * query if job with specified name exists
   * 
   * @param c
   * @param name
   */
  bool jobExists(const ControllerID c, const std::string& name) override;
  void send_jobExists(const ControllerID c, const std::string& name);
  bool recv_jobExists();
  /**
   * Details for the named job (throws if non-existent job)
   * 
   * @param c
   * @param name
   */
  void jobDetails(RobotJobInfo& _return, const ControllerID c, const std::string& name) override;
  void send_jobDetails(const ControllerID c, const std::string& name);
  void recv_jobDetails(RobotJobInfo& _return);
  /**
   * List of robot job names (empty if not connected)
   * 
   * @param c
   */
  void jobs(std::vector<std::string> & _return, const ControllerID c) override;
  void send_jobs(const ControllerID c);
  void recv_jobs(std::vector<std::string> & _return);
  /**
   * List of robot job names matching the name regular expression AND with the given tag
   * (empty if not connected or no matches)
   * 
   * @param c
   * @param nameRegex
   * @param tag
   */
  void jobsMatching(std::vector<std::string> & _return, const ControllerID c, const std::string& nameRegex, const std::string& tag) override;
  void send_jobsMatching(const ControllerID c, const std::string& nameRegex, const std::string& tag);
  void recv_jobsMatching(std::vector<std::string> & _return);
  /**
   * Duplicate an existing job with a new name for the copy
   * 
   * @param c
   * @param existingName
   * @param newName
   */
  void duplicateJob(const ControllerID c, const std::string& existingName, const std::string& newName) override;
  void send_duplicateJob(const ControllerID c, const std::string& existingName, const std::string& newName);
  void recv_duplicateJob();
  /**
   * delete the specified job.  The default job cannot be deleted.
   * 
   * @param c
   * @param name
   */
  void deleteJob(const ControllerID c, const std::string& name) override;
  void send_deleteJob(const ControllerID c, const std::string& name);
  void recv_deleteJob();
  /**
   * Read source code for named job (in the programmingLanguage listed in jobDetails() )
   * 
   * @param c
   * @param name
   */
  void jobSource(std::string& _return, const ControllerID c, const std::string& name) override;
  void send_jobSource(const ControllerID c, const std::string& name);
  void recv_jobSource(std::string& _return);
  /**
   * Replace named job with the source code provided, in given programmingLanguage (e.g. "INFORM").
   * Will thow if syntax errors in source.
   * 
   * @param c
   * @param name
   * @param programmingLanguage
   * @param sourceCode
   */
  void storeJobSource(const ControllerID c, const std::string& name, const std::string& programmingLanguage, const std::string& sourceCode) override;
  void send_storeJobSource(const ControllerID c, const std::string& name, const std::string& programmingLanguage, const std::string& sourceCode);
  void recv_storeJobSource();
  /**
   * List of tools mapping index -> name.
   * Unset/defaulted tools are omitted (e.g. those with no name, 0 weight etc.)
   * Indices (map keys) may not be sequential.  Returned map may be empty.
   * 
   * @param c
   */
  void tools(std::map<ToolIndex, std::string> & _return, const ControllerID c) override;
  void send_tools(const ControllerID c);
  void recv_tools(std::map<ToolIndex, std::string> & _return);
  /**
   * Query information on a specific tool, by index
   * 
   * @param c
   * @param index
   */
  void tool(Tool& _return, const ControllerID c, const ToolIndex index) override;
  void send_tool(const ControllerID c, const ToolIndex index);
  void recv_tool(Tool& _return);
  /**
   * Return input number of given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputNumber(const ControllerID c, const std::string& name) override;
  void send_inputNumber(const ControllerID c, const std::string& name);
  int32_t recv_inputNumber();
  /**
   * Return input group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputGroupNumber(const ControllerID c, const std::string& name) override;
  void send_inputGroupNumber(const ControllerID c, const std::string& name);
  int32_t recv_inputGroupNumber();
  /**
   * Return output nunber of given output name
   * 
   * @param c
   * @param name
   */
  int32_t outputNumber(const ControllerID c, const std::string& name) override;
  void send_outputNumber(const ControllerID c, const std::string& name);
  int32_t recv_outputNumber();
  /**
   * Return output group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t outputGroupNumber(const ControllerID c, const std::string& name) override;
  void send_outputGroupNumber(const ControllerID c, const std::string& name);
  int32_t recv_outputGroupNumber();
  /**
   * Return name of specified input number
   * 
   * @param c
   * @param num
   */
  void inputName(std::string& _return, const ControllerID c, const int32_t num) override;
  void send_inputName(const ControllerID c, const int32_t num);
  void recv_inputName(std::string& _return);
  /**
   * Return name of specified output number
   * 
   * @param c
   * @param num
   */
  void outputName(std::string& _return, const ControllerID c, const int32_t num) override;
  void send_outputName(const ControllerID c, const int32_t num);
  void recv_outputName(std::string& _return);
  /**
   * Set name of specified input (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setInputName(const ControllerID c, const int32_t num, const std::string& name) override;
  void send_setInputName(const ControllerID c, const int32_t num, const std::string& name);
  /**
   * Set name of specified output (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setOutputName(const ControllerID c, const int32_t num, const std::string& name) override;
  void send_setOutputName(const ControllerID c, const int32_t num, const std::string& name);
  /**
   * Start monitoring specified input
   * 
   * @param c
   * @param num
   */
  void monitorInput(const ControllerID c, const int32_t num) override;
  void send_monitorInput(const ControllerID c, const int32_t num);
  void recv_monitorInput();
  /**
   * Start monitoring all inputs in given input group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  void send_monitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_monitorInputGroups();
  /**
   * Start monitoring specified output
   * 
   * @param c
   * @param num
   */
  void monitorOutput(const ControllerID c, const int32_t num) override;
  void send_monitorOutput(const ControllerID c, const int32_t num);
  void recv_monitorOutput();
  /**
   * Start monitoring all outputs in given output group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  void send_monitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_monitorOutputGroups();
  /**
   * Stop monitoring specified input
   * 
   * @param c
   * @param num
   */
  void unmonitorInput(const ControllerID c, const int32_t num) override;
  void send_unmonitorInput(const ControllerID c, const int32_t num);
  void recv_unmonitorInput();
  /**
   * Stop monitoring all inputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  void send_unmonitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_unmonitorInputGroups();
  /**
   * Stop monitoring specified output
   * 
   * @param c
   * @param num
   */
  void unmonitorOutput(const ControllerID c, const int32_t num) override;
  void send_unmonitorOutput(const ControllerID c, const int32_t num);
  void recv_unmonitorOutput();
  /**
   * Stop monitoring all outputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  void send_unmonitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_unmonitorOutputGroups();
  /**
   * Return value of given input
   * 
   * @param c
   * @param num
   */
  bool inputValue(const ControllerID c, const int32_t num) override;
  void send_inputValue(const ControllerID c, const int32_t num);
  bool recv_inputValue();
  /**
   * Return values of input groups from specified group number (upto 4 contiguous groups/bytes, from least significant byte)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t inputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  void send_inputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count);
  int32_t recv_inputGroupsValue();
  /**
   * Return the value of given output
   * 
   * @param c
   * @param num
   */
  bool outputValue(const ControllerID c, const int32_t num) override;
  void send_outputValue(const ControllerID c, const int32_t num);
  bool recv_outputValue();
  /**
   * Return values of output groups from specified group number (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t outputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  void send_outputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count);
  int32_t recv_outputGroupsValue();
  /**
   * Set the value of the specified output number
   * 
   * @param c
   * @param num
   * @param value
   */
  void setOutput(const ControllerID c, const int32_t num, const bool value) override;
  void send_setOutput(const ControllerID c, const int32_t num, const bool value);
  /**
   * Set the values of the outputs in the specified contigous output groups (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   * @param value
   */
  void setOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count, const int32_t value) override;
  void send_setOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count, const int32_t value);
  /**
   * Return the logical IO address of the named input
   * 
   * @param c
   * @param name
   */
  int32_t inputAddress(const ControllerID c, const std::string& name) override;
  void send_inputAddress(const ControllerID c, const std::string& name);
  int32_t recv_inputAddress();
  /**
   * Return the logical IO address of the given input number
   * 
   * @param c
   * @param num
   */
  int32_t inputAddressByNumber(const ControllerID c, const int32_t num) override;
  void send_inputAddressByNumber(const ControllerID c, const int32_t num);
  int32_t recv_inputAddressByNumber();
  /**
   * Return the logical IO address of the named output
   * 
   * @param c
   * @param name
   */
  int32_t outputAddress(const ControllerID c, const std::string& name) override;
  void send_outputAddress(const ControllerID c, const std::string& name);
  int32_t recv_outputAddress();
  /**
   * Return the logical IO address of the given output number
   * 
   * @param c
   * @param num
   */
  int32_t outputAddressByNumber(const ControllerID c, const int32_t num) override;
  void send_outputAddressByNumber(const ControllerID c, const int32_t num);
  int32_t recv_outputAddressByNumber();
  /**
   * Start monitoring a logical IO address.  Will generate IOValueChanged events
   * 
   * @param c
   * @param address
   */
  void monitorIOAddress(const ControllerID c, const int32_t address) override;
  void send_monitorIOAddress(const ControllerID c, const int32_t address);
  void recv_monitorIOAddress();
  /**
   * Stop monitoring a logical IO address. (events for address may still be generated if it corresponds to a monitored input or output)
   * 
   * @param c
   * @param address
   */
  void unmonitorIOAddress(const ControllerID c, const int32_t address) override;
  void send_unmonitorIOAddress(const ControllerID c, const int32_t address);
  void recv_unmonitorIOAddress();
  /**
   * Return the value of the given input by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool inputAddressValue(const ControllerID c, const int32_t address) override;
  void send_inputAddressValue(const ControllerID c, const int32_t address);
  bool recv_inputAddressValue();
  /**
   * Return the value of the given output by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool outputAddressValue(const ControllerID c, const int32_t address) override;
  void send_outputAddressValue(const ControllerID c, const int32_t address);
  bool recv_outputAddressValue();
  /**
   * Set the value of the given output by logical IO address
   * 
   * @param c
   * @param address
   * @param value
   */
  void setOutputAddress(const ControllerID c, const int32_t address, const bool value) override;
  void send_setOutputAddress(const ControllerID c, const int32_t address, const bool value);
  /**
   * Obtain input group number (byte) of field bus status input.  e.g. busType 'ethip' yields EtherNet/IP status byte group
   * 
   * @param c
   * @param busType
   */
  int32_t fieldBusStatusInputGroup(const ControllerID c, const std::string& busType) override;
  void send_fieldBusStatusInputGroup(const ControllerID c, const std::string& busType);
  int32_t recv_fieldBusStatusInputGroup();
  /**
   * Return the list of control groups configured on the controller.
   * If only one robot is connected to the controller, this will return a single element,
   * containing the simple control group representing the robot.
   * 
   * @param c
   */
  void controlGroups(std::vector<ControlGroup> & _return, const ControllerID c) override;
  void send_controlGroups(const ControllerID c);
  void recv_controlGroups(std::vector<ControlGroup> & _return);
  /**
   * Returns the index of the currently active control group.
   * 
   * @param c
   */
  int8_t currentControlGroup(const ControllerID c) override;
  void send_currentControlGroup(const ControllerID c);
  int8_t recv_currentControlGroup();
  /**
   * Returns the number of robots connected to the controller
   * 
   * @param c
   */
  int8_t robotCount(const ControllerID c) override;
  void send_robotCount(const ControllerID c);
  int8_t recv_robotCount();
  /**
   * Returns the index of the currently active robot.
   * Note: index is 0-based, but in the UI the first robot is Robot 1.
   * 
   * @param c
   */
  RobotIndex currentRobot(const ControllerID c) override;
  void send_currentRobot(const ControllerID c);
  RobotIndex recv_currentRobot();
  /**
   * Variable value by name
   * 
   * @param c
   * @param name
   */
  void variable(Any& _return, const ControllerID c, const std::string& name) override;
  void send_variable(const ControllerID c, const std::string& name);
  void recv_variable(Any& _return);
  /**
   * Variable value by address
   * 
   * @param c
   * @param addr
   */
  void variableByAddr(Any& _return, const ControllerID c, const VariableAddress& addr) override;
  void send_variableByAddr(const ControllerID c, const VariableAddress& addr);
  void recv_variableByAddr(Any& _return);
  /**
   * Set variable value by name
   * 
   * @param c
   * @param name
   * @param value
   */
  void setVariable(const ControllerID c, const std::string& name, const Any& value) override;
  void send_setVariable(const ControllerID c, const std::string& name, const Any& value);
  void recv_setVariable();
  /**
   * Set variable by address
   * 
   * @param c
   * @param addr
   * @param value
   */
  void setVariableByAddr(const ControllerID c, const VariableAddress& addr, const Any& value) override;
  void send_setVariableByAddr(const ControllerID c, const VariableAddress& addr, const Any& value);
  void recv_setVariableByAddr();
  /**
   * Lookup variable address by name and space
   * 
   * @param c
   * @param name
   * @param space
   */
  void variableAddrByNameAndSpace(VariableAddress& _return, const ControllerID c, const std::string& name, const AddressSpace::type space) override;
  void send_variableAddrByNameAndSpace(const ControllerID c, const std::string& name, const AddressSpace::type space);
  void recv_variableAddrByNameAndSpace(VariableAddress& _return);
  /**
   * Lookup variable address by name (less efficient)
   * 
   * @param c
   * @param name
   */
  void variableAddrByName(VariableAddress& _return, const ControllerID c, const std::string& name) override;
  void send_variableAddrByName(const ControllerID c, const std::string& name);
  void recv_variableAddrByName(VariableAddress& _return);
  /**
   * Set name of variable by address
   * 
   * @param c
   * @param addr
   * @param name
   */
  void setVariableName(const ControllerID c, const VariableAddress& addr, const std::string& name) override;
  void send_setVariableName(const ControllerID c, const VariableAddress& addr, const std::string& name);
  void recv_setVariableName();
  /**
   * Query information on specified zone, by index (not number)
   * 
   * @param c
   * @param index
   */
  void zone(Zone& _return, const ControllerID c, const ZoneIndex index) override;
  void send_zone(const ControllerID c, const ZoneIndex index);
  void recv_zone(Zone& _return);
  /**
   * Creates a new Zone and returns its index.  It will have default values
   * which can be change via modifyZone()
   * 
   * @param c
   */
  ZoneIndex newZone(const ControllerID c) override;
  void send_newZone(const ControllerID c);
  ZoneIndex recv_newZone();
  /**
   * Modify Zone information.  Only fields set in Zone will be updated.
   * 
   * @param c
   * @param index
   * @param z
   */
  void modifyZone(const ControllerID c, const ZoneIndex index, const Zone& z) override;
  void send_modifyZone(const ControllerID c, const ZoneIndex index, const Zone& z);
  void recv_modifyZone();
  /**
   * Delete a Zone
   * 
   * @param c
   * @param index
   */
  void deleteZone(const ControllerID c, const ZoneIndex index) override;
  void send_deleteZone(const ControllerID c, const ZoneIndex index);
  void recv_deleteZone();
  /**
   * List of user frames mapping index -> name.
   * NB: Indices (map keys) may not be sequential. Returned map may be empty.
   * 
   * @param c
   */
  void userFrames(std::map<UserFrameIndex, std::string> & _return, const ControllerID c) override;
  void send_userFrames(const ControllerID c);
  void recv_userFrames(std::map<UserFrameIndex, std::string> & _return);
  /**
   * Query information on specified User Frame, by index (not number)
   * 
   * @param c
   * @param index
   */
  void userFrame(CoordinateFrame& _return, const ControllerID c, const UserFrameIndex index) override;
  void send_userFrame(const ControllerID c, const UserFrameIndex index);
  void recv_userFrame(CoordinateFrame& _return);
  /**
   * Creates a new User Frame with default values and returns its index.
   * 
   * @param c
   */
  UserFrameIndex newUserFrame(const ControllerID c) override;
  void send_newUserFrame(const ControllerID c);
  UserFrameIndex recv_newUserFrame();
  /**
   * Set the specified User Frame to the provided values
   * 
   * @param c
   * @param index
   * @param f
   */
  void setUserFrame(const ControllerID c, const UserFrameIndex index, const CoordinateFrame& f) override;
  void send_setUserFrame(const ControllerID c, const UserFrameIndex index, const CoordinateFrame& f);
  void recv_setUserFrame();
  /**
   * Delete a User Frame
   * 
   * @param c
   * @param index
   */
  void deleteUserFrame(const ControllerID c, const UserFrameIndex index) override;
  void send_deleteUserFrame(const ControllerID c, const UserFrameIndex index);
  void recv_deleteUserFrame();
  /**
   * Query current controller network interface IP address.
   * controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3']
   * (NB: On YRC1000micro, 'LAN' is the external Ethernet port, corresponding to 'LAN2' on the YRC1000)
   * 
   * @param c
   * @param controllerInterface
   */
  void networkInterfaceAddress(std::string& _return, const ControllerID c, const std::string& controllerInterface) override;
  void send_networkInterfaceAddress(const ControllerID c, const std::string& controllerInterface);
  void recv_networkInterfaceAddress(std::string& _return);
  /**
   * Request external network access via specified protocol and port originating
   * from the given controller interface. The controllerInferface may be left blank, in which case
   * connections will be routed from the controller according to the destination address and
   * current subnetwork of the external LAN ports).
   * Access only persists while power is maintained to the controller.
   * The protocol must be either 'tcp' or 'udp'. controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3'].
   * Returns a handle that can subsequently used to remove the access, or -1 if the access request
   * failed (may happen in case of network conflicts with other extensions).
   * Requires 'networking' permision.
   * 
   * @param c
   * @param controllerInterface
   * @param port
   * @param protocol
   */
  int32_t requestNetworkAccess(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) override;
  void send_requestNetworkAccess(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol);
  int32_t recv_requestNetworkAccess();
  void removeNetworkAccess(const ControllerID c, const int32_t accessHandle) override;
  void send_removeNetworkAccess(const ControllerID c, const int32_t accessHandle);
  void recv_removeNetworkAccess();
  int32_t requestNetworkService(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) override;
  void send_requestNetworkService(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol);
  int32_t recv_requestNetworkService();
  void removeNetworkService(const ControllerID c, const int32_t accessHandle) override;
  void send_removeNetworkService(const ControllerID c, const int32_t accessHandle);
  void recv_removeNetworkService();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ControllerProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<ControllerIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) override;
 private:
  typedef  void (ControllerProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_requestPermissions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_havePermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_relinquishPermissions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_connect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disconnect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_subscribeEventTypes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unsubscribeEventTypes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_events(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_connected(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_connectedHostName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_softwareVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_monitoring(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_haveExclusiveControl(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_operationMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_servoState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_playbackState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_run(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pause(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resume(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_stop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_currentJob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setCurrentJob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_defaultJob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_jobExists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_jobDetails(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_jobs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_jobsMatching(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_duplicateJob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteJob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_jobSource(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_storeJobSource(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_tools(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_tool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputNumber(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputGroupNumber(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputNumber(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputGroupNumber(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setInputName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setOutputName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_monitorInput(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_monitorInputGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_monitorOutput(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_monitorOutputGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unmonitorInput(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unmonitorInputGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unmonitorOutput(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unmonitorOutputGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputValue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputGroupsValue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputValue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputGroupsValue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setOutput(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setOutputGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputAddress(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputAddressByNumber(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputAddress(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputAddressByNumber(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_monitorIOAddress(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unmonitorIOAddress(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_inputAddressValue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_outputAddressValue(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setOutputAddress(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_fieldBusStatusInputGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_controlGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_currentControlGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_robotCount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_currentRobot(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_variable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_variableByAddr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setVariable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setVariableByAddr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_variableAddrByNameAndSpace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_variableAddrByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setVariableName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_zone(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newZone(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_modifyZone(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteZone(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_userFrames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_userFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newUserFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setUserFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteUserFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_networkInterfaceAddress(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_requestNetworkAccess(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeNetworkAccess(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_requestNetworkService(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeNetworkService(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ControllerProcessor(::std::shared_ptr<ControllerIf> iface) :
    iface_(iface) {
    processMap_["requestPermissions"] = &ControllerProcessor::process_requestPermissions;
    processMap_["havePermission"] = &ControllerProcessor::process_havePermission;
    processMap_["relinquishPermissions"] = &ControllerProcessor::process_relinquishPermissions;
    processMap_["connect"] = &ControllerProcessor::process_connect;
    processMap_["disconnect"] = &ControllerProcessor::process_disconnect;
    processMap_["subscribeEventTypes"] = &ControllerProcessor::process_subscribeEventTypes;
    processMap_["unsubscribeEventTypes"] = &ControllerProcessor::process_unsubscribeEventTypes;
    processMap_["events"] = &ControllerProcessor::process_events;
    processMap_["connected"] = &ControllerProcessor::process_connected;
    processMap_["connectedHostName"] = &ControllerProcessor::process_connectedHostName;
    processMap_["softwareVersion"] = &ControllerProcessor::process_softwareVersion;
    processMap_["monitoring"] = &ControllerProcessor::process_monitoring;
    processMap_["haveExclusiveControl"] = &ControllerProcessor::process_haveExclusiveControl;
    processMap_["operationMode"] = &ControllerProcessor::process_operationMode;
    processMap_["servoState"] = &ControllerProcessor::process_servoState;
    processMap_["playbackState"] = &ControllerProcessor::process_playbackState;
    processMap_["run"] = &ControllerProcessor::process_run;
    processMap_["pause"] = &ControllerProcessor::process_pause;
    processMap_["resume"] = &ControllerProcessor::process_resume;
    processMap_["stop"] = &ControllerProcessor::process_stop;
    processMap_["currentJob"] = &ControllerProcessor::process_currentJob;
    processMap_["setCurrentJob"] = &ControllerProcessor::process_setCurrentJob;
    processMap_["defaultJob"] = &ControllerProcessor::process_defaultJob;
    processMap_["jobExists"] = &ControllerProcessor::process_jobExists;
    processMap_["jobDetails"] = &ControllerProcessor::process_jobDetails;
    processMap_["jobs"] = &ControllerProcessor::process_jobs;
    processMap_["jobsMatching"] = &ControllerProcessor::process_jobsMatching;
    processMap_["duplicateJob"] = &ControllerProcessor::process_duplicateJob;
    processMap_["deleteJob"] = &ControllerProcessor::process_deleteJob;
    processMap_["jobSource"] = &ControllerProcessor::process_jobSource;
    processMap_["storeJobSource"] = &ControllerProcessor::process_storeJobSource;
    processMap_["tools"] = &ControllerProcessor::process_tools;
    processMap_["tool"] = &ControllerProcessor::process_tool;
    processMap_["inputNumber"] = &ControllerProcessor::process_inputNumber;
    processMap_["inputGroupNumber"] = &ControllerProcessor::process_inputGroupNumber;
    processMap_["outputNumber"] = &ControllerProcessor::process_outputNumber;
    processMap_["outputGroupNumber"] = &ControllerProcessor::process_outputGroupNumber;
    processMap_["inputName"] = &ControllerProcessor::process_inputName;
    processMap_["outputName"] = &ControllerProcessor::process_outputName;
    processMap_["setInputName"] = &ControllerProcessor::process_setInputName;
    processMap_["setOutputName"] = &ControllerProcessor::process_setOutputName;
    processMap_["monitorInput"] = &ControllerProcessor::process_monitorInput;
    processMap_["monitorInputGroups"] = &ControllerProcessor::process_monitorInputGroups;
    processMap_["monitorOutput"] = &ControllerProcessor::process_monitorOutput;
    processMap_["monitorOutputGroups"] = &ControllerProcessor::process_monitorOutputGroups;
    processMap_["unmonitorInput"] = &ControllerProcessor::process_unmonitorInput;
    processMap_["unmonitorInputGroups"] = &ControllerProcessor::process_unmonitorInputGroups;
    processMap_["unmonitorOutput"] = &ControllerProcessor::process_unmonitorOutput;
    processMap_["unmonitorOutputGroups"] = &ControllerProcessor::process_unmonitorOutputGroups;
    processMap_["inputValue"] = &ControllerProcessor::process_inputValue;
    processMap_["inputGroupsValue"] = &ControllerProcessor::process_inputGroupsValue;
    processMap_["outputValue"] = &ControllerProcessor::process_outputValue;
    processMap_["outputGroupsValue"] = &ControllerProcessor::process_outputGroupsValue;
    processMap_["setOutput"] = &ControllerProcessor::process_setOutput;
    processMap_["setOutputGroups"] = &ControllerProcessor::process_setOutputGroups;
    processMap_["inputAddress"] = &ControllerProcessor::process_inputAddress;
    processMap_["inputAddressByNumber"] = &ControllerProcessor::process_inputAddressByNumber;
    processMap_["outputAddress"] = &ControllerProcessor::process_outputAddress;
    processMap_["outputAddressByNumber"] = &ControllerProcessor::process_outputAddressByNumber;
    processMap_["monitorIOAddress"] = &ControllerProcessor::process_monitorIOAddress;
    processMap_["unmonitorIOAddress"] = &ControllerProcessor::process_unmonitorIOAddress;
    processMap_["inputAddressValue"] = &ControllerProcessor::process_inputAddressValue;
    processMap_["outputAddressValue"] = &ControllerProcessor::process_outputAddressValue;
    processMap_["setOutputAddress"] = &ControllerProcessor::process_setOutputAddress;
    processMap_["fieldBusStatusInputGroup"] = &ControllerProcessor::process_fieldBusStatusInputGroup;
    processMap_["controlGroups"] = &ControllerProcessor::process_controlGroups;
    processMap_["currentControlGroup"] = &ControllerProcessor::process_currentControlGroup;
    processMap_["robotCount"] = &ControllerProcessor::process_robotCount;
    processMap_["currentRobot"] = &ControllerProcessor::process_currentRobot;
    processMap_["variable"] = &ControllerProcessor::process_variable;
    processMap_["variableByAddr"] = &ControllerProcessor::process_variableByAddr;
    processMap_["setVariable"] = &ControllerProcessor::process_setVariable;
    processMap_["setVariableByAddr"] = &ControllerProcessor::process_setVariableByAddr;
    processMap_["variableAddrByNameAndSpace"] = &ControllerProcessor::process_variableAddrByNameAndSpace;
    processMap_["variableAddrByName"] = &ControllerProcessor::process_variableAddrByName;
    processMap_["setVariableName"] = &ControllerProcessor::process_setVariableName;
    processMap_["zone"] = &ControllerProcessor::process_zone;
    processMap_["newZone"] = &ControllerProcessor::process_newZone;
    processMap_["modifyZone"] = &ControllerProcessor::process_modifyZone;
    processMap_["deleteZone"] = &ControllerProcessor::process_deleteZone;
    processMap_["userFrames"] = &ControllerProcessor::process_userFrames;
    processMap_["userFrame"] = &ControllerProcessor::process_userFrame;
    processMap_["newUserFrame"] = &ControllerProcessor::process_newUserFrame;
    processMap_["setUserFrame"] = &ControllerProcessor::process_setUserFrame;
    processMap_["deleteUserFrame"] = &ControllerProcessor::process_deleteUserFrame;
    processMap_["networkInterfaceAddress"] = &ControllerProcessor::process_networkInterfaceAddress;
    processMap_["requestNetworkAccess"] = &ControllerProcessor::process_requestNetworkAccess;
    processMap_["removeNetworkAccess"] = &ControllerProcessor::process_removeNetworkAccess;
    processMap_["requestNetworkService"] = &ControllerProcessor::process_requestNetworkService;
    processMap_["removeNetworkService"] = &ControllerProcessor::process_removeNetworkService;
  }

  virtual ~ControllerProcessor() {}
};

class ControllerProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ControllerProcessorFactory(const ::std::shared_ptr< ControllerIfFactory >& handlerFactory) noexcept :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) override;

 protected:
  ::std::shared_ptr< ControllerIfFactory > handlerFactory_;
};

class ControllerMultiface : virtual public ControllerIf {
 public:
  ControllerMultiface(std::vector<std::shared_ptr<ControllerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ControllerMultiface() {}
 protected:
  std::vector<std::shared_ptr<ControllerIf> > ifaces_;
  ControllerMultiface() {}
  void add(::std::shared_ptr<ControllerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  /**
   * Request specified permissions.
   * 
   * @param c
   * @param permissions
   */
  bool requestPermissions(const ControllerID c, const std::set<std::string> & permissions) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->requestPermissions(c, permissions);
    }
    return ifaces_[i]->requestPermissions(c, permissions);
  }

  /**
   * Check permisions obtained.
   * 
   * @param c
   * @param permission
   */
  bool havePermission(const ControllerID c, const std::string& permission) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->havePermission(c, permission);
    }
    return ifaces_[i]->havePermission(c, permission);
  }

  /**
   * Relinquish permissions (no effect if not held).
   * 
   * @param c
   * @param permissions
   */
  void relinquishPermissions(const ControllerID c, const std::set<std::string> & permissions) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->relinquishPermissions(c, permissions);
    }
    ifaces_[i]->relinquishPermissions(c, permissions);
  }

  /**
   * Connect to the specified Robot Controller (by IP adress or hostname if DNS available)
   * Typically, the pendant will already be connected to a controller when extensions are started,
   * so calling connect() is not required.
   * 
   * @param c
   * @param hostName
   */
  void connect(const ControllerID c, const std::string& hostName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->connect(c, hostName);
    }
    ifaces_[i]->connect(c, hostName);
  }

  /**
   * Disconnect from the connected controller.  This leaves the pendant in the 'disconnected' state.
   * When disconnected, many functions are unavailable or will return default values.
   * 
   * @param c
   */
  void disconnect(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disconnect(c);
    }
    ifaces_[i]->disconnect(c);
  }

  /**
   * Subscribe to the specified events, if not already.
   * Note: If using a Yaskawa supplied client library with event consumer callback support,
   *       registering an event consumer callback will automatically subscribe to the appropriate event.
   * 
   * @param c
   * @param types
   */
  void subscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->subscribeEventTypes(c, types);
    }
    ifaces_[i]->subscribeEventTypes(c, types);
  }

  /**
   * Unsubscribe from the specified events.
   * If called directly, this may causes event consumers for the events not to be called.
   * 
   * @param c
   * @param types
   */
  void unsubscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unsubscribeEventTypes(c, types);
    }
    ifaces_[i]->unsubscribeEventTypes(c, types);
  }

  /**
   * Poll the API Service for pending events.
   * Note: If using a Yaskawa supplied client library, this does not need to be called explicitly.
   * 
   * @param c
   */
  void events(std::vector<ControllerEvent> & _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->events(_return, c);
    }
    ifaces_[i]->events(_return, c);
    return;
  }

  /**
   * Returns true if the pendant is connected to a robot controller
   * 
   * @param c
   */
  bool connected(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->connected(c);
    }
    return ifaces_[i]->connected(c);
  }

  /**
   * Returns the hostname or IP address of the robot controller to which the pendant is connected, if any
   * 
   * @param c
   */
  void connectedHostName(std::string& _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->connectedHostName(_return, c);
    }
    ifaces_[i]->connectedHostName(_return, c);
    return;
  }

  /**
   * The software version string of the robot controller system software.
   * 
   * @param c
   */
  void softwareVersion(std::string& _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->softwareVersion(_return, c);
    }
    ifaces_[i]->softwareVersion(_return, c);
    return;
  }

  /**
   * Returns true if the pendant is only monitoring the robot controller to which it is connected.  This
   * implies that no functions that modify the controller and/or robot state will succeed.
   * 
   * @param c
   */
  bool monitoring(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->monitoring(c);
    }
    return ifaces_[i]->monitoring(c);
  }

  /**
   * Returns true if this pendant is the single-point-of-control for the connected Robot Controller.
   * If not, most functions that modify the controller and/or robot state will fail.
   * 
   * @param c
   */
  bool haveExclusiveControl(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->haveExclusiveControl(c);
    }
    return ifaces_[i]->haveExclusiveControl(c);
  }

  /**
   * Current operation mode of the controller
   * Automatic (aka Play) - running jobs
   * Manual (aka Teach) - for editing jobs, teaching points, jogging, setup etc.
   * 
   * @param c
   */
  OperationMode::type operationMode(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->operationMode(c);
    }
    return ifaces_[i]->operationMode(c);
  }

  /**
   * Are the servo drives engaged?
   * On - yes, robot(s) are being actively controlled
   * Off - no.  Typically brakes are engaged (unless brake-release engaged)
   * Ready - ready to engage servos.  Typically requires operator to use servo enable switch.
   * 
   * @param c
   */
  ServoState::type servoState(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->servoState(c);
    }
    return ifaces_[i]->servoState(c);
  }

  /**
   * Indicates if a job us running or stopped.
   * Run - jobs are running (robot may be moving)
   * Held - jobs were running but have been held/paused.
   * Idle - no jobs are running
   * 
   * @param c
   */
  PlaybackState::type playbackState(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->playbackState(c);
    }
    return ifaces_[i]->playbackState(c);
  }

  /**
   * Run the current robot job from the current line.  Requires Servos engaged & Automatic/Play operation and 'jobcontrol' permission.
   * 
   * @param c
   */
  void run(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->run(c);
    }
    ifaces_[i]->run(c);
  }

  /**
   * Pause running job (servoes will remain engaged. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void pause(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pause(c);
    }
    ifaces_[i]->pause(c);
  }

  /**
   * Resume running job from paused state. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void resume(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resume(c);
    }
    ifaces_[i]->resume(c);
  }

  /**
   * Stop runnng job (will stop motion and disengage servos). 'jobcontrol' permission required.
   * 
   * @param c
   */
  void stop(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->stop(c);
    }
    ifaces_[i]->stop(c);
  }

  /**
   * Name of the current job (e.g. job being run or edited)
   * Empty if none.
   * 
   * @param c
   */
  void currentJob(std::string& _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->currentJob(_return, c);
    }
    ifaces_[i]->currentJob(_return, c);
    return;
  }

  /**
   * Set the current job. 'jobcontrol' permission required. Pass line=1 for start of job, line=0 for default/no-change.
   * 
   * @param c
   * @param name
   * @param line
   */
  void setCurrentJob(const ControllerID c, const std::string& name, const int32_t line) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setCurrentJob(c, name, line);
    }
    ifaces_[i]->setCurrentJob(c, name, line);
  }

  /**
   * Name of the default (aka master) job.  Empty if no default job designated
   * 
   * @param c
   */
  void defaultJob(std::string& _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->defaultJob(_return, c);
    }
    ifaces_[i]->defaultJob(_return, c);
    return;
  }

  /**
   * query if job with specified name exists
   * 
   * @param c
   * @param name
   */
  bool jobExists(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->jobExists(c, name);
    }
    return ifaces_[i]->jobExists(c, name);
  }

  /**
   * Details for the named job (throws if non-existent job)
   * 
   * @param c
   * @param name
   */
  void jobDetails(RobotJobInfo& _return, const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->jobDetails(_return, c, name);
    }
    ifaces_[i]->jobDetails(_return, c, name);
    return;
  }

  /**
   * List of robot job names (empty if not connected)
   * 
   * @param c
   */
  void jobs(std::vector<std::string> & _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->jobs(_return, c);
    }
    ifaces_[i]->jobs(_return, c);
    return;
  }

  /**
   * List of robot job names matching the name regular expression AND with the given tag
   * (empty if not connected or no matches)
   * 
   * @param c
   * @param nameRegex
   * @param tag
   */
  void jobsMatching(std::vector<std::string> & _return, const ControllerID c, const std::string& nameRegex, const std::string& tag) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->jobsMatching(_return, c, nameRegex, tag);
    }
    ifaces_[i]->jobsMatching(_return, c, nameRegex, tag);
    return;
  }

  /**
   * Duplicate an existing job with a new name for the copy
   * 
   * @param c
   * @param existingName
   * @param newName
   */
  void duplicateJob(const ControllerID c, const std::string& existingName, const std::string& newName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->duplicateJob(c, existingName, newName);
    }
    ifaces_[i]->duplicateJob(c, existingName, newName);
  }

  /**
   * delete the specified job.  The default job cannot be deleted.
   * 
   * @param c
   * @param name
   */
  void deleteJob(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteJob(c, name);
    }
    ifaces_[i]->deleteJob(c, name);
  }

  /**
   * Read source code for named job (in the programmingLanguage listed in jobDetails() )
   * 
   * @param c
   * @param name
   */
  void jobSource(std::string& _return, const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->jobSource(_return, c, name);
    }
    ifaces_[i]->jobSource(_return, c, name);
    return;
  }

  /**
   * Replace named job with the source code provided, in given programmingLanguage (e.g. "INFORM").
   * Will thow if syntax errors in source.
   * 
   * @param c
   * @param name
   * @param programmingLanguage
   * @param sourceCode
   */
  void storeJobSource(const ControllerID c, const std::string& name, const std::string& programmingLanguage, const std::string& sourceCode) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->storeJobSource(c, name, programmingLanguage, sourceCode);
    }
    ifaces_[i]->storeJobSource(c, name, programmingLanguage, sourceCode);
  }

  /**
   * List of tools mapping index -> name.
   * Unset/defaulted tools are omitted (e.g. those with no name, 0 weight etc.)
   * Indices (map keys) may not be sequential.  Returned map may be empty.
   * 
   * @param c
   */
  void tools(std::map<ToolIndex, std::string> & _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->tools(_return, c);
    }
    ifaces_[i]->tools(_return, c);
    return;
  }

  /**
   * Query information on a specific tool, by index
   * 
   * @param c
   * @param index
   */
  void tool(Tool& _return, const ControllerID c, const ToolIndex index) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->tool(_return, c, index);
    }
    ifaces_[i]->tool(_return, c, index);
    return;
  }

  /**
   * Return input number of given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputNumber(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputNumber(c, name);
    }
    return ifaces_[i]->inputNumber(c, name);
  }

  /**
   * Return input group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputGroupNumber(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputGroupNumber(c, name);
    }
    return ifaces_[i]->inputGroupNumber(c, name);
  }

  /**
   * Return output nunber of given output name
   * 
   * @param c
   * @param name
   */
  int32_t outputNumber(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputNumber(c, name);
    }
    return ifaces_[i]->outputNumber(c, name);
  }

  /**
   * Return output group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t outputGroupNumber(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputGroupNumber(c, name);
    }
    return ifaces_[i]->outputGroupNumber(c, name);
  }

  /**
   * Return name of specified input number
   * 
   * @param c
   * @param num
   */
  void inputName(std::string& _return, const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputName(_return, c, num);
    }
    ifaces_[i]->inputName(_return, c, num);
    return;
  }

  /**
   * Return name of specified output number
   * 
   * @param c
   * @param num
   */
  void outputName(std::string& _return, const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputName(_return, c, num);
    }
    ifaces_[i]->outputName(_return, c, num);
    return;
  }

  /**
   * Set name of specified input (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setInputName(const ControllerID c, const int32_t num, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setInputName(c, num, name);
    }
    ifaces_[i]->setInputName(c, num, name);
  }

  /**
   * Set name of specified output (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setOutputName(const ControllerID c, const int32_t num, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setOutputName(c, num, name);
    }
    ifaces_[i]->setOutputName(c, num, name);
  }

  /**
   * Start monitoring specified input
   * 
   * @param c
   * @param num
   */
  void monitorInput(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->monitorInput(c, num);
    }
    ifaces_[i]->monitorInput(c, num);
  }

  /**
   * Start monitoring all inputs in given input group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->monitorInputGroups(c, groupNum, count);
    }
    ifaces_[i]->monitorInputGroups(c, groupNum, count);
  }

  /**
   * Start monitoring specified output
   * 
   * @param c
   * @param num
   */
  void monitorOutput(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->monitorOutput(c, num);
    }
    ifaces_[i]->monitorOutput(c, num);
  }

  /**
   * Start monitoring all outputs in given output group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->monitorOutputGroups(c, groupNum, count);
    }
    ifaces_[i]->monitorOutputGroups(c, groupNum, count);
  }

  /**
   * Stop monitoring specified input
   * 
   * @param c
   * @param num
   */
  void unmonitorInput(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unmonitorInput(c, num);
    }
    ifaces_[i]->unmonitorInput(c, num);
  }

  /**
   * Stop monitoring all inputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unmonitorInputGroups(c, groupNum, count);
    }
    ifaces_[i]->unmonitorInputGroups(c, groupNum, count);
  }

  /**
   * Stop monitoring specified output
   * 
   * @param c
   * @param num
   */
  void unmonitorOutput(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unmonitorOutput(c, num);
    }
    ifaces_[i]->unmonitorOutput(c, num);
  }

  /**
   * Stop monitoring all outputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unmonitorOutputGroups(c, groupNum, count);
    }
    ifaces_[i]->unmonitorOutputGroups(c, groupNum, count);
  }

  /**
   * Return value of given input
   * 
   * @param c
   * @param num
   */
  bool inputValue(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputValue(c, num);
    }
    return ifaces_[i]->inputValue(c, num);
  }

  /**
   * Return values of input groups from specified group number (upto 4 contiguous groups/bytes, from least significant byte)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t inputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputGroupsValue(c, groupNum, count);
    }
    return ifaces_[i]->inputGroupsValue(c, groupNum, count);
  }

  /**
   * Return the value of given output
   * 
   * @param c
   * @param num
   */
  bool outputValue(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputValue(c, num);
    }
    return ifaces_[i]->outputValue(c, num);
  }

  /**
   * Return values of output groups from specified group number (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t outputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputGroupsValue(c, groupNum, count);
    }
    return ifaces_[i]->outputGroupsValue(c, groupNum, count);
  }

  /**
   * Set the value of the specified output number
   * 
   * @param c
   * @param num
   * @param value
   */
  void setOutput(const ControllerID c, const int32_t num, const bool value) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setOutput(c, num, value);
    }
    ifaces_[i]->setOutput(c, num, value);
  }

  /**
   * Set the values of the outputs in the specified contigous output groups (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   * @param value
   */
  void setOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count, const int32_t value) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setOutputGroups(c, groupNum, count, value);
    }
    ifaces_[i]->setOutputGroups(c, groupNum, count, value);
  }

  /**
   * Return the logical IO address of the named input
   * 
   * @param c
   * @param name
   */
  int32_t inputAddress(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputAddress(c, name);
    }
    return ifaces_[i]->inputAddress(c, name);
  }

  /**
   * Return the logical IO address of the given input number
   * 
   * @param c
   * @param num
   */
  int32_t inputAddressByNumber(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputAddressByNumber(c, num);
    }
    return ifaces_[i]->inputAddressByNumber(c, num);
  }

  /**
   * Return the logical IO address of the named output
   * 
   * @param c
   * @param name
   */
  int32_t outputAddress(const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputAddress(c, name);
    }
    return ifaces_[i]->outputAddress(c, name);
  }

  /**
   * Return the logical IO address of the given output number
   * 
   * @param c
   * @param num
   */
  int32_t outputAddressByNumber(const ControllerID c, const int32_t num) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputAddressByNumber(c, num);
    }
    return ifaces_[i]->outputAddressByNumber(c, num);
  }

  /**
   * Start monitoring a logical IO address.  Will generate IOValueChanged events
   * 
   * @param c
   * @param address
   */
  void monitorIOAddress(const ControllerID c, const int32_t address) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->monitorIOAddress(c, address);
    }
    ifaces_[i]->monitorIOAddress(c, address);
  }

  /**
   * Stop monitoring a logical IO address. (events for address may still be generated if it corresponds to a monitored input or output)
   * 
   * @param c
   * @param address
   */
  void unmonitorIOAddress(const ControllerID c, const int32_t address) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unmonitorIOAddress(c, address);
    }
    ifaces_[i]->unmonitorIOAddress(c, address);
  }

  /**
   * Return the value of the given input by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool inputAddressValue(const ControllerID c, const int32_t address) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->inputAddressValue(c, address);
    }
    return ifaces_[i]->inputAddressValue(c, address);
  }

  /**
   * Return the value of the given output by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool outputAddressValue(const ControllerID c, const int32_t address) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->outputAddressValue(c, address);
    }
    return ifaces_[i]->outputAddressValue(c, address);
  }

  /**
   * Set the value of the given output by logical IO address
   * 
   * @param c
   * @param address
   * @param value
   */
  void setOutputAddress(const ControllerID c, const int32_t address, const bool value) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setOutputAddress(c, address, value);
    }
    ifaces_[i]->setOutputAddress(c, address, value);
  }

  /**
   * Obtain input group number (byte) of field bus status input.  e.g. busType 'ethip' yields EtherNet/IP status byte group
   * 
   * @param c
   * @param busType
   */
  int32_t fieldBusStatusInputGroup(const ControllerID c, const std::string& busType) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->fieldBusStatusInputGroup(c, busType);
    }
    return ifaces_[i]->fieldBusStatusInputGroup(c, busType);
  }

  /**
   * Return the list of control groups configured on the controller.
   * If only one robot is connected to the controller, this will return a single element,
   * containing the simple control group representing the robot.
   * 
   * @param c
   */
  void controlGroups(std::vector<ControlGroup> & _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->controlGroups(_return, c);
    }
    ifaces_[i]->controlGroups(_return, c);
    return;
  }

  /**
   * Returns the index of the currently active control group.
   * 
   * @param c
   */
  int8_t currentControlGroup(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->currentControlGroup(c);
    }
    return ifaces_[i]->currentControlGroup(c);
  }

  /**
   * Returns the number of robots connected to the controller
   * 
   * @param c
   */
  int8_t robotCount(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->robotCount(c);
    }
    return ifaces_[i]->robotCount(c);
  }

  /**
   * Returns the index of the currently active robot.
   * Note: index is 0-based, but in the UI the first robot is Robot 1.
   * 
   * @param c
   */
  RobotIndex currentRobot(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->currentRobot(c);
    }
    return ifaces_[i]->currentRobot(c);
  }

  /**
   * Variable value by name
   * 
   * @param c
   * @param name
   */
  void variable(Any& _return, const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->variable(_return, c, name);
    }
    ifaces_[i]->variable(_return, c, name);
    return;
  }

  /**
   * Variable value by address
   * 
   * @param c
   * @param addr
   */
  void variableByAddr(Any& _return, const ControllerID c, const VariableAddress& addr) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->variableByAddr(_return, c, addr);
    }
    ifaces_[i]->variableByAddr(_return, c, addr);
    return;
  }

  /**
   * Set variable value by name
   * 
   * @param c
   * @param name
   * @param value
   */
  void setVariable(const ControllerID c, const std::string& name, const Any& value) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setVariable(c, name, value);
    }
    ifaces_[i]->setVariable(c, name, value);
  }

  /**
   * Set variable by address
   * 
   * @param c
   * @param addr
   * @param value
   */
  void setVariableByAddr(const ControllerID c, const VariableAddress& addr, const Any& value) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setVariableByAddr(c, addr, value);
    }
    ifaces_[i]->setVariableByAddr(c, addr, value);
  }

  /**
   * Lookup variable address by name and space
   * 
   * @param c
   * @param name
   * @param space
   */
  void variableAddrByNameAndSpace(VariableAddress& _return, const ControllerID c, const std::string& name, const AddressSpace::type space) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->variableAddrByNameAndSpace(_return, c, name, space);
    }
    ifaces_[i]->variableAddrByNameAndSpace(_return, c, name, space);
    return;
  }

  /**
   * Lookup variable address by name (less efficient)
   * 
   * @param c
   * @param name
   */
  void variableAddrByName(VariableAddress& _return, const ControllerID c, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->variableAddrByName(_return, c, name);
    }
    ifaces_[i]->variableAddrByName(_return, c, name);
    return;
  }

  /**
   * Set name of variable by address
   * 
   * @param c
   * @param addr
   * @param name
   */
  void setVariableName(const ControllerID c, const VariableAddress& addr, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setVariableName(c, addr, name);
    }
    ifaces_[i]->setVariableName(c, addr, name);
  }

  /**
   * Query information on specified zone, by index (not number)
   * 
   * @param c
   * @param index
   */
  void zone(Zone& _return, const ControllerID c, const ZoneIndex index) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->zone(_return, c, index);
    }
    ifaces_[i]->zone(_return, c, index);
    return;
  }

  /**
   * Creates a new Zone and returns its index.  It will have default values
   * which can be change via modifyZone()
   * 
   * @param c
   */
  ZoneIndex newZone(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newZone(c);
    }
    return ifaces_[i]->newZone(c);
  }

  /**
   * Modify Zone information.  Only fields set in Zone will be updated.
   * 
   * @param c
   * @param index
   * @param z
   */
  void modifyZone(const ControllerID c, const ZoneIndex index, const Zone& z) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->modifyZone(c, index, z);
    }
    ifaces_[i]->modifyZone(c, index, z);
  }

  /**
   * Delete a Zone
   * 
   * @param c
   * @param index
   */
  void deleteZone(const ControllerID c, const ZoneIndex index) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteZone(c, index);
    }
    ifaces_[i]->deleteZone(c, index);
  }

  /**
   * List of user frames mapping index -> name.
   * NB: Indices (map keys) may not be sequential. Returned map may be empty.
   * 
   * @param c
   */
  void userFrames(std::map<UserFrameIndex, std::string> & _return, const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->userFrames(_return, c);
    }
    ifaces_[i]->userFrames(_return, c);
    return;
  }

  /**
   * Query information on specified User Frame, by index (not number)
   * 
   * @param c
   * @param index
   */
  void userFrame(CoordinateFrame& _return, const ControllerID c, const UserFrameIndex index) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->userFrame(_return, c, index);
    }
    ifaces_[i]->userFrame(_return, c, index);
    return;
  }

  /**
   * Creates a new User Frame with default values and returns its index.
   * 
   * @param c
   */
  UserFrameIndex newUserFrame(const ControllerID c) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newUserFrame(c);
    }
    return ifaces_[i]->newUserFrame(c);
  }

  /**
   * Set the specified User Frame to the provided values
   * 
   * @param c
   * @param index
   * @param f
   */
  void setUserFrame(const ControllerID c, const UserFrameIndex index, const CoordinateFrame& f) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setUserFrame(c, index, f);
    }
    ifaces_[i]->setUserFrame(c, index, f);
  }

  /**
   * Delete a User Frame
   * 
   * @param c
   * @param index
   */
  void deleteUserFrame(const ControllerID c, const UserFrameIndex index) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteUserFrame(c, index);
    }
    ifaces_[i]->deleteUserFrame(c, index);
  }

  /**
   * Query current controller network interface IP address.
   * controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3']
   * (NB: On YRC1000micro, 'LAN' is the external Ethernet port, corresponding to 'LAN2' on the YRC1000)
   * 
   * @param c
   * @param controllerInterface
   */
  void networkInterfaceAddress(std::string& _return, const ControllerID c, const std::string& controllerInterface) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->networkInterfaceAddress(_return, c, controllerInterface);
    }
    ifaces_[i]->networkInterfaceAddress(_return, c, controllerInterface);
    return;
  }

  /**
   * Request external network access via specified protocol and port originating
   * from the given controller interface. The controllerInferface may be left blank, in which case
   * connections will be routed from the controller according to the destination address and
   * current subnetwork of the external LAN ports).
   * Access only persists while power is maintained to the controller.
   * The protocol must be either 'tcp' or 'udp'. controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3'].
   * Returns a handle that can subsequently used to remove the access, or -1 if the access request
   * failed (may happen in case of network conflicts with other extensions).
   * Requires 'networking' permision.
   * 
   * @param c
   * @param controllerInterface
   * @param port
   * @param protocol
   */
  int32_t requestNetworkAccess(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->requestNetworkAccess(c, controllerInterface, port, protocol);
    }
    return ifaces_[i]->requestNetworkAccess(c, controllerInterface, port, protocol);
  }

  void removeNetworkAccess(const ControllerID c, const int32_t accessHandle) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeNetworkAccess(c, accessHandle);
    }
    ifaces_[i]->removeNetworkAccess(c, accessHandle);
  }

  int32_t requestNetworkService(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->requestNetworkService(c, controllerInterface, port, protocol);
    }
    return ifaces_[i]->requestNetworkService(c, controllerInterface, port, protocol);
  }

  void removeNetworkService(const ControllerID c, const int32_t accessHandle) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeNetworkService(c, accessHandle);
    }
    ifaces_[i]->removeNetworkService(c, accessHandle);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ControllerConcurrentClient : virtual public ControllerIf {
 public:
  ControllerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  ControllerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Request specified permissions.
   * 
   * @param c
   * @param permissions
   */
  bool requestPermissions(const ControllerID c, const std::set<std::string> & permissions) override;
  int32_t send_requestPermissions(const ControllerID c, const std::set<std::string> & permissions);
  bool recv_requestPermissions(const int32_t seqid);
  /**
   * Check permisions obtained.
   * 
   * @param c
   * @param permission
   */
  bool havePermission(const ControllerID c, const std::string& permission) override;
  int32_t send_havePermission(const ControllerID c, const std::string& permission);
  bool recv_havePermission(const int32_t seqid);
  /**
   * Relinquish permissions (no effect if not held).
   * 
   * @param c
   * @param permissions
   */
  void relinquishPermissions(const ControllerID c, const std::set<std::string> & permissions) override;
  int32_t send_relinquishPermissions(const ControllerID c, const std::set<std::string> & permissions);
  void recv_relinquishPermissions(const int32_t seqid);
  /**
   * Connect to the specified Robot Controller (by IP adress or hostname if DNS available)
   * Typically, the pendant will already be connected to a controller when extensions are started,
   * so calling connect() is not required.
   * 
   * @param c
   * @param hostName
   */
  void connect(const ControllerID c, const std::string& hostName) override;
  int32_t send_connect(const ControllerID c, const std::string& hostName);
  void recv_connect(const int32_t seqid);
  /**
   * Disconnect from the connected controller.  This leaves the pendant in the 'disconnected' state.
   * When disconnected, many functions are unavailable or will return default values.
   * 
   * @param c
   */
  void disconnect(const ControllerID c) override;
  int32_t send_disconnect(const ControllerID c);
  void recv_disconnect(const int32_t seqid);
  /**
   * Subscribe to the specified events, if not already.
   * Note: If using a Yaskawa supplied client library with event consumer callback support,
   *       registering an event consumer callback will automatically subscribe to the appropriate event.
   * 
   * @param c
   * @param types
   */
  void subscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) override;
  int32_t send_subscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types);
  void recv_subscribeEventTypes(const int32_t seqid);
  /**
   * Unsubscribe from the specified events.
   * If called directly, this may causes event consumers for the events not to be called.
   * 
   * @param c
   * @param types
   */
  void unsubscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types) override;
  int32_t send_unsubscribeEventTypes(const ControllerID c, const std::set<ControllerEventType::type> & types);
  void recv_unsubscribeEventTypes(const int32_t seqid);
  /**
   * Poll the API Service for pending events.
   * Note: If using a Yaskawa supplied client library, this does not need to be called explicitly.
   * 
   * @param c
   */
  void events(std::vector<ControllerEvent> & _return, const ControllerID c) override;
  int32_t send_events(const ControllerID c);
  void recv_events(std::vector<ControllerEvent> & _return, const int32_t seqid);
  /**
   * Returns true if the pendant is connected to a robot controller
   * 
   * @param c
   */
  bool connected(const ControllerID c) override;
  int32_t send_connected(const ControllerID c);
  bool recv_connected(const int32_t seqid);
  /**
   * Returns the hostname or IP address of the robot controller to which the pendant is connected, if any
   * 
   * @param c
   */
  void connectedHostName(std::string& _return, const ControllerID c) override;
  int32_t send_connectedHostName(const ControllerID c);
  void recv_connectedHostName(std::string& _return, const int32_t seqid);
  /**
   * The software version string of the robot controller system software.
   * 
   * @param c
   */
  void softwareVersion(std::string& _return, const ControllerID c) override;
  int32_t send_softwareVersion(const ControllerID c);
  void recv_softwareVersion(std::string& _return, const int32_t seqid);
  /**
   * Returns true if the pendant is only monitoring the robot controller to which it is connected.  This
   * implies that no functions that modify the controller and/or robot state will succeed.
   * 
   * @param c
   */
  bool monitoring(const ControllerID c) override;
  int32_t send_monitoring(const ControllerID c);
  bool recv_monitoring(const int32_t seqid);
  /**
   * Returns true if this pendant is the single-point-of-control for the connected Robot Controller.
   * If not, most functions that modify the controller and/or robot state will fail.
   * 
   * @param c
   */
  bool haveExclusiveControl(const ControllerID c) override;
  int32_t send_haveExclusiveControl(const ControllerID c);
  bool recv_haveExclusiveControl(const int32_t seqid);
  /**
   * Current operation mode of the controller
   * Automatic (aka Play) - running jobs
   * Manual (aka Teach) - for editing jobs, teaching points, jogging, setup etc.
   * 
   * @param c
   */
  OperationMode::type operationMode(const ControllerID c) override;
  int32_t send_operationMode(const ControllerID c);
  OperationMode::type recv_operationMode(const int32_t seqid);
  /**
   * Are the servo drives engaged?
   * On - yes, robot(s) are being actively controlled
   * Off - no.  Typically brakes are engaged (unless brake-release engaged)
   * Ready - ready to engage servos.  Typically requires operator to use servo enable switch.
   * 
   * @param c
   */
  ServoState::type servoState(const ControllerID c) override;
  int32_t send_servoState(const ControllerID c);
  ServoState::type recv_servoState(const int32_t seqid);
  /**
   * Indicates if a job us running or stopped.
   * Run - jobs are running (robot may be moving)
   * Held - jobs were running but have been held/paused.
   * Idle - no jobs are running
   * 
   * @param c
   */
  PlaybackState::type playbackState(const ControllerID c) override;
  int32_t send_playbackState(const ControllerID c);
  PlaybackState::type recv_playbackState(const int32_t seqid);
  /**
   * Run the current robot job from the current line.  Requires Servos engaged & Automatic/Play operation and 'jobcontrol' permission.
   * 
   * @param c
   */
  void run(const ControllerID c) override;
  int32_t send_run(const ControllerID c);
  void recv_run(const int32_t seqid);
  /**
   * Pause running job (servoes will remain engaged. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void pause(const ControllerID c) override;
  int32_t send_pause(const ControllerID c);
  void recv_pause(const int32_t seqid);
  /**
   * Resume running job from paused state. 'jobcontrol' permission required.
   * 
   * @param c
   */
  void resume(const ControllerID c) override;
  int32_t send_resume(const ControllerID c);
  void recv_resume(const int32_t seqid);
  /**
   * Stop runnng job (will stop motion and disengage servos). 'jobcontrol' permission required.
   * 
   * @param c
   */
  void stop(const ControllerID c) override;
  int32_t send_stop(const ControllerID c);
  void recv_stop(const int32_t seqid);
  /**
   * Name of the current job (e.g. job being run or edited)
   * Empty if none.
   * 
   * @param c
   */
  void currentJob(std::string& _return, const ControllerID c) override;
  int32_t send_currentJob(const ControllerID c);
  void recv_currentJob(std::string& _return, const int32_t seqid);
  /**
   * Set the current job. 'jobcontrol' permission required. Pass line=1 for start of job, line=0 for default/no-change.
   * 
   * @param c
   * @param name
   * @param line
   */
  void setCurrentJob(const ControllerID c, const std::string& name, const int32_t line) override;
  int32_t send_setCurrentJob(const ControllerID c, const std::string& name, const int32_t line);
  void recv_setCurrentJob(const int32_t seqid);
  /**
   * Name of the default (aka master) job.  Empty if no default job designated
   * 
   * @param c
   */
  void defaultJob(std::string& _return, const ControllerID c) override;
  int32_t send_defaultJob(const ControllerID c);
  void recv_defaultJob(std::string& _return, const int32_t seqid);
  /**
   * query if job with specified name exists
   * 
   * @param c
   * @param name
   */
  bool jobExists(const ControllerID c, const std::string& name) override;
  int32_t send_jobExists(const ControllerID c, const std::string& name);
  bool recv_jobExists(const int32_t seqid);
  /**
   * Details for the named job (throws if non-existent job)
   * 
   * @param c
   * @param name
   */
  void jobDetails(RobotJobInfo& _return, const ControllerID c, const std::string& name) override;
  int32_t send_jobDetails(const ControllerID c, const std::string& name);
  void recv_jobDetails(RobotJobInfo& _return, const int32_t seqid);
  /**
   * List of robot job names (empty if not connected)
   * 
   * @param c
   */
  void jobs(std::vector<std::string> & _return, const ControllerID c) override;
  int32_t send_jobs(const ControllerID c);
  void recv_jobs(std::vector<std::string> & _return, const int32_t seqid);
  /**
   * List of robot job names matching the name regular expression AND with the given tag
   * (empty if not connected or no matches)
   * 
   * @param c
   * @param nameRegex
   * @param tag
   */
  void jobsMatching(std::vector<std::string> & _return, const ControllerID c, const std::string& nameRegex, const std::string& tag) override;
  int32_t send_jobsMatching(const ControllerID c, const std::string& nameRegex, const std::string& tag);
  void recv_jobsMatching(std::vector<std::string> & _return, const int32_t seqid);
  /**
   * Duplicate an existing job with a new name for the copy
   * 
   * @param c
   * @param existingName
   * @param newName
   */
  void duplicateJob(const ControllerID c, const std::string& existingName, const std::string& newName) override;
  int32_t send_duplicateJob(const ControllerID c, const std::string& existingName, const std::string& newName);
  void recv_duplicateJob(const int32_t seqid);
  /**
   * delete the specified job.  The default job cannot be deleted.
   * 
   * @param c
   * @param name
   */
  void deleteJob(const ControllerID c, const std::string& name) override;
  int32_t send_deleteJob(const ControllerID c, const std::string& name);
  void recv_deleteJob(const int32_t seqid);
  /**
   * Read source code for named job (in the programmingLanguage listed in jobDetails() )
   * 
   * @param c
   * @param name
   */
  void jobSource(std::string& _return, const ControllerID c, const std::string& name) override;
  int32_t send_jobSource(const ControllerID c, const std::string& name);
  void recv_jobSource(std::string& _return, const int32_t seqid);
  /**
   * Replace named job with the source code provided, in given programmingLanguage (e.g. "INFORM").
   * Will thow if syntax errors in source.
   * 
   * @param c
   * @param name
   * @param programmingLanguage
   * @param sourceCode
   */
  void storeJobSource(const ControllerID c, const std::string& name, const std::string& programmingLanguage, const std::string& sourceCode) override;
  int32_t send_storeJobSource(const ControllerID c, const std::string& name, const std::string& programmingLanguage, const std::string& sourceCode);
  void recv_storeJobSource(const int32_t seqid);
  /**
   * List of tools mapping index -> name.
   * Unset/defaulted tools are omitted (e.g. those with no name, 0 weight etc.)
   * Indices (map keys) may not be sequential.  Returned map may be empty.
   * 
   * @param c
   */
  void tools(std::map<ToolIndex, std::string> & _return, const ControllerID c) override;
  int32_t send_tools(const ControllerID c);
  void recv_tools(std::map<ToolIndex, std::string> & _return, const int32_t seqid);
  /**
   * Query information on a specific tool, by index
   * 
   * @param c
   * @param index
   */
  void tool(Tool& _return, const ControllerID c, const ToolIndex index) override;
  int32_t send_tool(const ControllerID c, const ToolIndex index);
  void recv_tool(Tool& _return, const int32_t seqid);
  /**
   * Return input number of given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputNumber(const ControllerID c, const std::string& name) override;
  int32_t send_inputNumber(const ControllerID c, const std::string& name);
  int32_t recv_inputNumber(const int32_t seqid);
  /**
   * Return input group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t inputGroupNumber(const ControllerID c, const std::string& name) override;
  int32_t send_inputGroupNumber(const ControllerID c, const std::string& name);
  int32_t recv_inputGroupNumber(const int32_t seqid);
  /**
   * Return output nunber of given output name
   * 
   * @param c
   * @param name
   */
  int32_t outputNumber(const ControllerID c, const std::string& name) override;
  int32_t send_outputNumber(const ControllerID c, const std::string& name);
  int32_t recv_outputNumber(const int32_t seqid);
  /**
   * Return output group number for group beginning with given input name
   * 
   * @param c
   * @param name
   */
  int32_t outputGroupNumber(const ControllerID c, const std::string& name) override;
  int32_t send_outputGroupNumber(const ControllerID c, const std::string& name);
  int32_t recv_outputGroupNumber(const int32_t seqid);
  /**
   * Return name of specified input number
   * 
   * @param c
   * @param num
   */
  void inputName(std::string& _return, const ControllerID c, const int32_t num) override;
  int32_t send_inputName(const ControllerID c, const int32_t num);
  void recv_inputName(std::string& _return, const int32_t seqid);
  /**
   * Return name of specified output number
   * 
   * @param c
   * @param num
   */
  void outputName(std::string& _return, const ControllerID c, const int32_t num) override;
  int32_t send_outputName(const ControllerID c, const int32_t num);
  void recv_outputName(std::string& _return, const int32_t seqid);
  /**
   * Set name of specified input (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setInputName(const ControllerID c, const int32_t num, const std::string& name) override;
  void send_setInputName(const ControllerID c, const int32_t num, const std::string& name);
  /**
   * Set name of specified output (asynchronously)
   * 
   * @param c
   * @param num
   * @param name
   */
  void setOutputName(const ControllerID c, const int32_t num, const std::string& name) override;
  void send_setOutputName(const ControllerID c, const int32_t num, const std::string& name);
  /**
   * Start monitoring specified input
   * 
   * @param c
   * @param num
   */
  void monitorInput(const ControllerID c, const int32_t num) override;
  int32_t send_monitorInput(const ControllerID c, const int32_t num);
  void recv_monitorInput(const int32_t seqid);
  /**
   * Start monitoring all inputs in given input group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  int32_t send_monitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_monitorInputGroups(const int32_t seqid);
  /**
   * Start monitoring specified output
   * 
   * @param c
   * @param num
   */
  void monitorOutput(const ControllerID c, const int32_t num) override;
  int32_t send_monitorOutput(const ControllerID c, const int32_t num);
  void recv_monitorOutput(const int32_t seqid);
  /**
   * Start monitoring all outputs in given output group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void monitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  int32_t send_monitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_monitorOutputGroups(const int32_t seqid);
  /**
   * Stop monitoring specified input
   * 
   * @param c
   * @param num
   */
  void unmonitorInput(const ControllerID c, const int32_t num) override;
  int32_t send_unmonitorInput(const ControllerID c, const int32_t num);
  void recv_unmonitorInput(const int32_t seqid);
  /**
   * Stop monitoring all inputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  int32_t send_unmonitorInputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_unmonitorInputGroups(const int32_t seqid);
  /**
   * Stop monitoring specified output
   * 
   * @param c
   * @param num
   */
  void unmonitorOutput(const ControllerID c, const int32_t num) override;
  int32_t send_unmonitorOutput(const ControllerID c, const int32_t num);
  void recv_unmonitorOutput(const int32_t seqid);
  /**
   * Stop monitoring all outputs in specified group
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  void unmonitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  int32_t send_unmonitorOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count);
  void recv_unmonitorOutputGroups(const int32_t seqid);
  /**
   * Return value of given input
   * 
   * @param c
   * @param num
   */
  bool inputValue(const ControllerID c, const int32_t num) override;
  int32_t send_inputValue(const ControllerID c, const int32_t num);
  bool recv_inputValue(const int32_t seqid);
  /**
   * Return values of input groups from specified group number (upto 4 contiguous groups/bytes, from least significant byte)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t inputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  int32_t send_inputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count);
  int32_t recv_inputGroupsValue(const int32_t seqid);
  /**
   * Return the value of given output
   * 
   * @param c
   * @param num
   */
  bool outputValue(const ControllerID c, const int32_t num) override;
  int32_t send_outputValue(const ControllerID c, const int32_t num);
  bool recv_outputValue(const int32_t seqid);
  /**
   * Return values of output groups from specified group number (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   */
  int32_t outputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count) override;
  int32_t send_outputGroupsValue(const ControllerID c, const int32_t groupNum, const int32_t count);
  int32_t recv_outputGroupsValue(const int32_t seqid);
  /**
   * Set the value of the specified output number
   * 
   * @param c
   * @param num
   * @param value
   */
  void setOutput(const ControllerID c, const int32_t num, const bool value) override;
  void send_setOutput(const ControllerID c, const int32_t num, const bool value);
  /**
   * Set the values of the outputs in the specified contigous output groups (upto 4 contiguous groups/bytes)
   * 
   * @param c
   * @param groupNum
   * @param count
   * @param value
   */
  void setOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count, const int32_t value) override;
  void send_setOutputGroups(const ControllerID c, const int32_t groupNum, const int32_t count, const int32_t value);
  /**
   * Return the logical IO address of the named input
   * 
   * @param c
   * @param name
   */
  int32_t inputAddress(const ControllerID c, const std::string& name) override;
  int32_t send_inputAddress(const ControllerID c, const std::string& name);
  int32_t recv_inputAddress(const int32_t seqid);
  /**
   * Return the logical IO address of the given input number
   * 
   * @param c
   * @param num
   */
  int32_t inputAddressByNumber(const ControllerID c, const int32_t num) override;
  int32_t send_inputAddressByNumber(const ControllerID c, const int32_t num);
  int32_t recv_inputAddressByNumber(const int32_t seqid);
  /**
   * Return the logical IO address of the named output
   * 
   * @param c
   * @param name
   */
  int32_t outputAddress(const ControllerID c, const std::string& name) override;
  int32_t send_outputAddress(const ControllerID c, const std::string& name);
  int32_t recv_outputAddress(const int32_t seqid);
  /**
   * Return the logical IO address of the given output number
   * 
   * @param c
   * @param num
   */
  int32_t outputAddressByNumber(const ControllerID c, const int32_t num) override;
  int32_t send_outputAddressByNumber(const ControllerID c, const int32_t num);
  int32_t recv_outputAddressByNumber(const int32_t seqid);
  /**
   * Start monitoring a logical IO address.  Will generate IOValueChanged events
   * 
   * @param c
   * @param address
   */
  void monitorIOAddress(const ControllerID c, const int32_t address) override;
  int32_t send_monitorIOAddress(const ControllerID c, const int32_t address);
  void recv_monitorIOAddress(const int32_t seqid);
  /**
   * Stop monitoring a logical IO address. (events for address may still be generated if it corresponds to a monitored input or output)
   * 
   * @param c
   * @param address
   */
  void unmonitorIOAddress(const ControllerID c, const int32_t address) override;
  int32_t send_unmonitorIOAddress(const ControllerID c, const int32_t address);
  void recv_unmonitorIOAddress(const int32_t seqid);
  /**
   * Return the value of the given input by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool inputAddressValue(const ControllerID c, const int32_t address) override;
  int32_t send_inputAddressValue(const ControllerID c, const int32_t address);
  bool recv_inputAddressValue(const int32_t seqid);
  /**
   * Return the value of the given output by logcial IO address
   * 
   * @param c
   * @param address
   */
  bool outputAddressValue(const ControllerID c, const int32_t address) override;
  int32_t send_outputAddressValue(const ControllerID c, const int32_t address);
  bool recv_outputAddressValue(const int32_t seqid);
  /**
   * Set the value of the given output by logical IO address
   * 
   * @param c
   * @param address
   * @param value
   */
  void setOutputAddress(const ControllerID c, const int32_t address, const bool value) override;
  void send_setOutputAddress(const ControllerID c, const int32_t address, const bool value);
  /**
   * Obtain input group number (byte) of field bus status input.  e.g. busType 'ethip' yields EtherNet/IP status byte group
   * 
   * @param c
   * @param busType
   */
  int32_t fieldBusStatusInputGroup(const ControllerID c, const std::string& busType) override;
  int32_t send_fieldBusStatusInputGroup(const ControllerID c, const std::string& busType);
  int32_t recv_fieldBusStatusInputGroup(const int32_t seqid);
  /**
   * Return the list of control groups configured on the controller.
   * If only one robot is connected to the controller, this will return a single element,
   * containing the simple control group representing the robot.
   * 
   * @param c
   */
  void controlGroups(std::vector<ControlGroup> & _return, const ControllerID c) override;
  int32_t send_controlGroups(const ControllerID c);
  void recv_controlGroups(std::vector<ControlGroup> & _return, const int32_t seqid);
  /**
   * Returns the index of the currently active control group.
   * 
   * @param c
   */
  int8_t currentControlGroup(const ControllerID c) override;
  int32_t send_currentControlGroup(const ControllerID c);
  int8_t recv_currentControlGroup(const int32_t seqid);
  /**
   * Returns the number of robots connected to the controller
   * 
   * @param c
   */
  int8_t robotCount(const ControllerID c) override;
  int32_t send_robotCount(const ControllerID c);
  int8_t recv_robotCount(const int32_t seqid);
  /**
   * Returns the index of the currently active robot.
   * Note: index is 0-based, but in the UI the first robot is Robot 1.
   * 
   * @param c
   */
  RobotIndex currentRobot(const ControllerID c) override;
  int32_t send_currentRobot(const ControllerID c);
  RobotIndex recv_currentRobot(const int32_t seqid);
  /**
   * Variable value by name
   * 
   * @param c
   * @param name
   */
  void variable(Any& _return, const ControllerID c, const std::string& name) override;
  int32_t send_variable(const ControllerID c, const std::string& name);
  void recv_variable(Any& _return, const int32_t seqid);
  /**
   * Variable value by address
   * 
   * @param c
   * @param addr
   */
  void variableByAddr(Any& _return, const ControllerID c, const VariableAddress& addr) override;
  int32_t send_variableByAddr(const ControllerID c, const VariableAddress& addr);
  void recv_variableByAddr(Any& _return, const int32_t seqid);
  /**
   * Set variable value by name
   * 
   * @param c
   * @param name
   * @param value
   */
  void setVariable(const ControllerID c, const std::string& name, const Any& value) override;
  int32_t send_setVariable(const ControllerID c, const std::string& name, const Any& value);
  void recv_setVariable(const int32_t seqid);
  /**
   * Set variable by address
   * 
   * @param c
   * @param addr
   * @param value
   */
  void setVariableByAddr(const ControllerID c, const VariableAddress& addr, const Any& value) override;
  int32_t send_setVariableByAddr(const ControllerID c, const VariableAddress& addr, const Any& value);
  void recv_setVariableByAddr(const int32_t seqid);
  /**
   * Lookup variable address by name and space
   * 
   * @param c
   * @param name
   * @param space
   */
  void variableAddrByNameAndSpace(VariableAddress& _return, const ControllerID c, const std::string& name, const AddressSpace::type space) override;
  int32_t send_variableAddrByNameAndSpace(const ControllerID c, const std::string& name, const AddressSpace::type space);
  void recv_variableAddrByNameAndSpace(VariableAddress& _return, const int32_t seqid);
  /**
   * Lookup variable address by name (less efficient)
   * 
   * @param c
   * @param name
   */
  void variableAddrByName(VariableAddress& _return, const ControllerID c, const std::string& name) override;
  int32_t send_variableAddrByName(const ControllerID c, const std::string& name);
  void recv_variableAddrByName(VariableAddress& _return, const int32_t seqid);
  /**
   * Set name of variable by address
   * 
   * @param c
   * @param addr
   * @param name
   */
  void setVariableName(const ControllerID c, const VariableAddress& addr, const std::string& name) override;
  int32_t send_setVariableName(const ControllerID c, const VariableAddress& addr, const std::string& name);
  void recv_setVariableName(const int32_t seqid);
  /**
   * Query information on specified zone, by index (not number)
   * 
   * @param c
   * @param index
   */
  void zone(Zone& _return, const ControllerID c, const ZoneIndex index) override;
  int32_t send_zone(const ControllerID c, const ZoneIndex index);
  void recv_zone(Zone& _return, const int32_t seqid);
  /**
   * Creates a new Zone and returns its index.  It will have default values
   * which can be change via modifyZone()
   * 
   * @param c
   */
  ZoneIndex newZone(const ControllerID c) override;
  int32_t send_newZone(const ControllerID c);
  ZoneIndex recv_newZone(const int32_t seqid);
  /**
   * Modify Zone information.  Only fields set in Zone will be updated.
   * 
   * @param c
   * @param index
   * @param z
   */
  void modifyZone(const ControllerID c, const ZoneIndex index, const Zone& z) override;
  int32_t send_modifyZone(const ControllerID c, const ZoneIndex index, const Zone& z);
  void recv_modifyZone(const int32_t seqid);
  /**
   * Delete a Zone
   * 
   * @param c
   * @param index
   */
  void deleteZone(const ControllerID c, const ZoneIndex index) override;
  int32_t send_deleteZone(const ControllerID c, const ZoneIndex index);
  void recv_deleteZone(const int32_t seqid);
  /**
   * List of user frames mapping index -> name.
   * NB: Indices (map keys) may not be sequential. Returned map may be empty.
   * 
   * @param c
   */
  void userFrames(std::map<UserFrameIndex, std::string> & _return, const ControllerID c) override;
  int32_t send_userFrames(const ControllerID c);
  void recv_userFrames(std::map<UserFrameIndex, std::string> & _return, const int32_t seqid);
  /**
   * Query information on specified User Frame, by index (not number)
   * 
   * @param c
   * @param index
   */
  void userFrame(CoordinateFrame& _return, const ControllerID c, const UserFrameIndex index) override;
  int32_t send_userFrame(const ControllerID c, const UserFrameIndex index);
  void recv_userFrame(CoordinateFrame& _return, const int32_t seqid);
  /**
   * Creates a new User Frame with default values and returns its index.
   * 
   * @param c
   */
  UserFrameIndex newUserFrame(const ControllerID c) override;
  int32_t send_newUserFrame(const ControllerID c);
  UserFrameIndex recv_newUserFrame(const int32_t seqid);
  /**
   * Set the specified User Frame to the provided values
   * 
   * @param c
   * @param index
   * @param f
   */
  void setUserFrame(const ControllerID c, const UserFrameIndex index, const CoordinateFrame& f) override;
  int32_t send_setUserFrame(const ControllerID c, const UserFrameIndex index, const CoordinateFrame& f);
  void recv_setUserFrame(const int32_t seqid);
  /**
   * Delete a User Frame
   * 
   * @param c
   * @param index
   */
  void deleteUserFrame(const ControllerID c, const UserFrameIndex index) override;
  int32_t send_deleteUserFrame(const ControllerID c, const UserFrameIndex index);
  void recv_deleteUserFrame(const int32_t seqid);
  /**
   * Query current controller network interface IP address.
   * controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3']
   * (NB: On YRC1000micro, 'LAN' is the external Ethernet port, corresponding to 'LAN2' on the YRC1000)
   * 
   * @param c
   * @param controllerInterface
   */
  void networkInterfaceAddress(std::string& _return, const ControllerID c, const std::string& controllerInterface) override;
  int32_t send_networkInterfaceAddress(const ControllerID c, const std::string& controllerInterface);
  void recv_networkInterfaceAddress(std::string& _return, const int32_t seqid);
  /**
   * Request external network access via specified protocol and port originating
   * from the given controller interface. The controllerInferface may be left blank, in which case
   * connections will be routed from the controller according to the destination address and
   * current subnetwork of the external LAN ports).
   * Access only persists while power is maintained to the controller.
   * The protocol must be either 'tcp' or 'udp'. controllerInterface must be one of ['LAN1','LAN'/'LAN2' or 'LAN3'].
   * Returns a handle that can subsequently used to remove the access, or -1 if the access request
   * failed (may happen in case of network conflicts with other extensions).
   * Requires 'networking' permision.
   * 
   * @param c
   * @param controllerInterface
   * @param port
   * @param protocol
   */
  int32_t requestNetworkAccess(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) override;
  int32_t send_requestNetworkAccess(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol);
  int32_t recv_requestNetworkAccess(const int32_t seqid);
  void removeNetworkAccess(const ControllerID c, const int32_t accessHandle) override;
  int32_t send_removeNetworkAccess(const ControllerID c, const int32_t accessHandle);
  void recv_removeNetworkAccess(const int32_t seqid);
  int32_t requestNetworkService(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol) override;
  int32_t send_requestNetworkService(const ControllerID c, const std::string& controllerInterface, const int32_t port, const std::string& protocol);
  int32_t recv_requestNetworkService(const int32_t seqid);
  void removeNetworkService(const ControllerID c, const int32_t accessHandle) override;
  int32_t send_removeNetworkService(const ControllerID c, const int32_t accessHandle);
  void recv_removeNetworkService(const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}}} // namespace

#endif
