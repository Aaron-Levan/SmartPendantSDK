// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Pendant.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::yaskawa::ext::api;

class PendantHandler : virtual public PendantIf {
 public:
  PendantHandler() {
    // Your initialization goes here
  }

  /**
   * Version of the Smart Pendant itself
   * (avoid using this for conditional feature use - use the Extension apiVersion() instead)
   * 
   * @param p
   */
  void pendantVersion(Version& _return, const PendantID p) {
    // Your implementation goes here
    printf("pendantVersion\n");
  }

  /**
   * Subscribe to specified set of Pendant service events.  May be called multiple times to add to subscription.
   * 
   * @param p
   * @param types
   */
  void subscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) {
    // Your implementation goes here
    printf("subscribeEventTypes\n");
  }

  /**
   * Unsubscribe from specified set of Pendant service events.
   * 
   * @param p
   * @param types
   */
  void unsubscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) {
    // Your implementation goes here
    printf("unsubscribeEventTypes\n");
  }

  /**
   * Obtain list of Pendant service events that have occured since last call
   * 
   * @param p
   */
  void events(std::vector<PendantEvent> & _return, const PendantID p) {
    // Your implementation goes here
    printf("events\n");
  }

  /**
   * Query the current UI language of the pendant interface.
   * Returns IETF language codes (RFCs 5646, 5645, 4647) of languages
   * (typically ISO 693-1 code when region insignificant)
   * 
   * @param p
   */
  void currentLanguage(std::string& _return, const PendantID p) {
    // Your implementation goes here
    printf("currentLanguage\n");
  }

  void currentLocale(std::string& _return, const PendantID p) {
    // Your implementation goes here
    printf("currentLocale\n");
  }

  /**
   * The UI screen currently shown to the pendant user
   * 
   * @param p
   */
  void currentScreenName(std::string& _return, const PendantID p) {
    // Your implementation goes here
    printf("currentScreenName\n");
  }

  /**
   * Register an Item type described using a YML source code string
   * Returns a list of parsing errors (0 on success)
   * 
   * @param p
   * @param ymlSource
   */
  void registerYML(std::vector<std::string> & _return, const PendantID p, const std::string& ymlSource) {
    // Your implementation goes here
    printf("registerYML\n");
  }

  /**
   * Register an image file for later reference by filename (must be uniquely named, with .jpg or .png).
   * If file cannot be accessed by service, it will be locally read and registerImageData called instead.
   * 
   * @param p
   * @param imageFileName
   */
  void registerImageFile(const PendantID p, const std::string& imageFileName) {
    // Your implementation goes here
    printf("registerImageFile\n");
  }

  /**
   * Register an image for later reference by name (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param imageData
   * @param imageName
   */
  void registerImageData(const PendantID p, const std::string& imageData, const std::string& imageName) {
    // Your implementation goes here
    printf("registerImageData\n");
  }

  /**
   * Register a HTML file for later reference by filename (must be uniquely named, with .html).
   * If file cannot be accessed by service, it will be locally read and registerHTMLData called instead.
   * 
   * @param p
   * @param htmlFileName
   */
  void registerHTMLFile(const PendantID p, const std::string& htmlFileName) {
    // Your implementation goes here
    printf("registerHTMLFile\n");
  }

  /**
   * Register HTML for later reference by name (must be uniquely named, with .html extension)
   * 
   * @param p
   * @param htmlData
   * @param htmlName
   */
  void registerHTMLData(const PendantID p, const std::string& htmlData, const std::string& htmlName) {
    // Your implementation goes here
    printf("registerHTMLData\n");
  }

  /**
   * Register a translation file (e.g. a Java properties file for a language); extension is used to determine format
   * 
   * @param p
   * @param locale
   * @param translationFileName
   */
  void registerTranslationFile(const PendantID p, const std::string& locale, const std::string& translationFileName) {
    // Your implementation goes here
    printf("registerTranslationFile\n");
  }

  /**
   * Register translation file data (translationName typically filename-like; extension is used to determine format)
   * 
   * @param p
   * @param locale
   * @param translationData
   * @param translationName
   */
  void registerTranslationData(const PendantID p, const std::string& locale, const std::string& translationData, const std::string& translationName) {
    // Your implementation goes here
    printf("registerTranslationData\n");
  }

  /**
   * Register a Utility window with the UI.
   * The itemType references a previously registered YML item instantiated for the window
   * UI content.
   * A main menu entry will automatically be added to the pendant UI, for opening the utility window.
   * 
   * @param p
   * @param identifier
   * @param itemType
   * @param menuItemName
   * @param windowTitle
   */
  void registerUtilityWindow(const PendantID p, const std::string& identifier, const std::string& itemType, const std::string& menuItemName, const std::string& windowTitle) {
    // Your implementation goes here
    printf("registerUtilityWindow\n");
  }

  void unregisterUtilityWindow(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("unregisterUtilityWindow\n");
  }

  /**
   * Open (make visible) previously registered Utility Window
   * 
   * @param p
   * @param identifier
   */
  void openUtilityWindow(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("openUtilityWindow\n");
  }

  /**
   * Close a visible Utility Window (make invisible - state is maintained)
   * 
   * @param p
   * @param identifier
   */
  void closeUtilityWindow(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("closeUtilityWindow\n");
  }

  /**
   * Collapse previously registered Utility Window, if in expanded state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void collapseUtilityWindow(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("collapseUtilityWindow\n");
  }

  /**
   * Expand previously registered Utility Window, if in collapsed state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void expandUtilityWindow(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("expandUtilityWindow\n");
  }

  /**
   * Register UI content at the specified integration point in the pendant UI.
   * The itemType should reference a YML item previouslt registered via registerYML().
   * 
   * @param p
   * @param identifier
   * @param integrationPoint
   * @param itemType
   * @param buttonLabel
   * @param buttonImage
   */
  void registerIntegration(const PendantID p, const std::string& identifier, const IntegrationPoint::type integrationPoint, const std::string& itemType, const std::string& buttonLabel, const std::string& buttonImage) {
    // Your implementation goes here
    printf("registerIntegration\n");
  }

  void unregisterIntegration(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("unregisterIntegration\n");
  }

  /**
   * get property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   */
  void property(Any& _return, const PendantID p, const std::string& itemID, const std::string& name) {
    // Your implementation goes here
    printf("property\n");
  }

  /**
   * Set property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   * @param value
   */
  void setProperty(const PendantID p, const std::string& itemID, const std::string& name, const Any& value) {
    // Your implementation goes here
    printf("setProperty\n");
  }

  /**
   * Set several properties (potentially for different items) at once.  This is more
   * efficient that many repeated calls to setProperty().  Note it is async so no
   * errors/exceptions are thrown
   * 
   * @param p
   * @param propValuesList
   */
  void setProperties(const PendantID p, const std::vector<PropValues> & propValuesList) {
    // Your implementation goes here
    printf("setProperties\n");
  }

  /**
   * Set the configuration of a chart by ID.
   * 
   * @param p
   * @param chartID
   * @param config
   */
  void setChartConfig(const PendantID p, const std::string& chartID, const Any& config) {
    // Your implementation goes here
    printf("setChartConfig\n");
  }

  /**
   * Get the configuration of a chart by ID
   * 
   * @param p
   * @param chartID
   */
  void getChartConfig(Any& _return, const PendantID p, const std::string& chartID) {
    // Your implementation goes here
    printf("getChartConfig\n");
  }

  /**
   * Set the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param dataset
   * @param right
   */
  void setChartData(const PendantID p, const std::string& chartID, const DataSet& dataset, const bool right) {
    // Your implementation goes here
    printf("setChartData\n");
  }

  /**
   * Get the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to access the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param right
   */
  void getChartData(DataSet& _return, const PendantID p, const std::string& chartID, const bool right) {
    // Your implementation goes here
    printf("getChartData\n");
  }

  /**
   * Add a new key to the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param data
   * @param right
   */
  void addChartKey(const PendantID p, const std::string& chartID, const std::string& key, const Data& data, const bool right) {
    // Your implementation goes here
    printf("addChartKey\n");
  }

  /**
   * Removes an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to remove from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param right
   */
  void removeChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool right) {
    // Your implementation goes here
    printf("removeChartKey\n");
  }

  /**
   * Hides an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to hide a key from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param hidden
   * @param right
   */
  void hideChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool hidden, const bool right) {
    // Your implementation goes here
    printf("hideChartKey\n");
  }

  /**
   * Append new data points to a specified key in the data of a chart by ID.
   * This function will only have an effect on line/scatter charts. Set
   * 'right' to true to pass the dataset for a secondary scale on the right
   * hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param points
   * @param right
   */
  void appendChartPoints(const PendantID p, const std::string& chartID, const std::string& key, const std::vector<DataPoint> & points, const bool right) {
    // Your implementation goes here
    printf("appendChartPoints\n");
  }

  /**
   * Increments a category value by `val`.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param val
   */
  void incrementChartKey(const PendantID p, const std::string& chartID, const std::string& key, const double val) {
    // Your implementation goes here
    printf("incrementChartKey\n");
  }

  /**
   * Export the current chart contents to the specified filename (must be uniquely named, with .jpg or .png).
   * Calls exportChartImageData if the extension is unable to access the file.
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImage(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) {
    // Your implementation goes here
    printf("exportChartImage\n");
  }

  /**
   * Export the current chart contents to a binary blob (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImageData(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) {
    // Your implementation goes here
    printf("exportChartImageData\n");
  }

  /**
   * Show notice to user.
   * Notices are automaticlly hidden after a short display period.
   * Notice messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void notice(const PendantID p, const std::string& title, const std::string& message, const std::string& log) {
    // Your implementation goes here
    printf("notice\n");
  }

  /**
   * Show notice to user with specified disposition.
   * As for notice() but displayed in a way that connotes the specified disposition.
   * For example, a Positive disposition may be shown in green.
   * (API version 2.1 and later)
   * 
   * @param p
   * @param disposition
   * @param title
   * @param message
   * @param log
   */
  void dispNotice(const PendantID p, const Disposition::type disposition, const std::string& title, const std::string& message, const std::string& log) {
    // Your implementation goes here
    printf("dispNotice\n");
  }

  /**
   * Show error to user.
   * Errors should only indicate important situations that the user must be aware of and for which deliberate
   * acknowledgement is required before proceeding.  Typically, some action will be required to correct the situation.
   * Errors are displayed until dismissed by the user.
   * Error messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void error(const PendantID p, const std::string& title, const std::string& message, const std::string& log) {
    // Your implementation goes here
    printf("error\n");
  }

  /**
   * Display modal pop-up dialog.  Typically, Yes/No, although negativeOption can be omitted
   * The identifier can be used to associate the corresponding PopupOpened & PopupClosed events triggered by
   * user positive/negative selection or automatic dismissal/cancellation - for example is screen switched, alarm etc.
   * 
   * @param p
   * @param identifier
   * @param title
   * @param message
   * @param positiveOption
   * @param negativeOption
   */
  void popupDialog(const PendantID p, const std::string& identifier, const std::string& title, const std::string& message, const std::string& positiveOption, const std::string& negativeOption) {
    // Your implementation goes here
    printf("popupDialog\n");
  }

  /**
   * Cancel an open popup dialog.  If the dialog has a negative option, behaves as if user selected it, otherwise
   * no event is generated
   * 
   * @param p
   * @param identifier
   */
  void cancelPopupDialog(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("cancelPopupDialog\n");
  }

  /**
   * Inserts an instruction, returns a string:
   * Success,
   * UnsupportedCommand,
   * InvalidFormat,
   * ProgrammingViewClosed,
   * JobDoesNotExist,
   * CallingJobFromSameJob,
   * ExceededMaxArguments,
   * JobNotEditable,
   * MultiSelectActive,
   * TimedOut,
   * Unknown
   * 
   * @param p
   * @param instruction
   */
  void insertInstructionAtSelectedLine(std::string& _return, const PendantID p, const std::string& instruction) {
    // Your implementation goes here
    printf("insertInstructionAtSelectedLine\n");
  }

  /**
   * Displays a standard pendant UI screen by passing a string with the screen identifier. (Only available from SDK API 2.2 onward)
   * Refer to the YML - URI Links documentation for the list of supported screens and settings.
   * Do not include the URI "&lt;a href&gt; screen:" portion in the identifier.  For example to display the jogging panel use:
   * pendant.displayScreen("programmingView?panel=jogging");
   * 
   * @param p
   * @param identifier
   */
  void displayScreen(const PendantID p, const std::string& identifier) {
    // Your implementation goes here
    printf("displayScreen\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::std::shared_ptr<PendantHandler> handler(new PendantHandler());
  ::std::shared_ptr<TProcessor> processor(new PendantProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

