/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Pendant_H
#define Pendant_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "extension_types.h"

namespace yaskawa { namespace ext { namespace api {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

/**
 * The Pendant API provides functions for interacting with and
 * integrating the main Smart Pendant user-interface.
 * 
 * (Extensions are not required to have a user-interface)
 */
class PendantIf {
 public:
  virtual ~PendantIf() {}

  /**
   * Version of the Smart Pendant itself
   * (avoid using this for conditional feature use - use the Extension apiVersion() instead)
   * 
   * @param p
   */
  virtual void pendantVersion(Version& _return, const PendantID p) = 0;

  /**
   * Subscribe to specified set of Pendant service events.  May be called multiple times to add to subscription.
   * 
   * @param p
   * @param types
   */
  virtual void subscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) = 0;

  /**
   * Unsubscribe from specified set of Pendant service events.
   * 
   * @param p
   * @param types
   */
  virtual void unsubscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) = 0;

  /**
   * Obtain list of Pendant service events that have occured since last call
   * 
   * @param p
   */
  virtual void events(std::vector<PendantEvent> & _return, const PendantID p) = 0;

  /**
   * Query the current UI language of the pendant interface.
   * Returns IETF language codes (RFCs 5646, 5645, 4647) of languages
   * (typically ISO 693-1 code when region insignificant)
   * 
   * @param p
   */
  virtual void currentLanguage(std::string& _return, const PendantID p) = 0;
  virtual void currentLocale(std::string& _return, const PendantID p) = 0;

  /**
   * The UI screen currently shown to the pendant user
   * 
   * @param p
   */
  virtual void currentScreenName(std::string& _return, const PendantID p) = 0;

  /**
   * Register an Item type described using a YML source code string
   * Returns a list of parsing errors (0 on success)
   * 
   * @param p
   * @param ymlSource
   */
  virtual void registerYML(std::vector<std::string> & _return, const PendantID p, const std::string& ymlSource) = 0;

  /**
   * Register an image file for later reference by filename (must be uniquely named, with .jpg or .png).
   * If file cannot be accessed by service, it will be locally read and registerImageData called instead.
   * 
   * @param p
   * @param imageFileName
   */
  virtual void registerImageFile(const PendantID p, const std::string& imageFileName) = 0;

  /**
   * Register an image for later reference by name (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param imageData
   * @param imageName
   */
  virtual void registerImageData(const PendantID p, const std::string& imageData, const std::string& imageName) = 0;

  /**
   * Register a HTML file for later reference by filename (must be uniquely named, with .html).
   * If file cannot be accessed by service, it will be locally read and registerHTMLData called instead.
   * 
   * @param p
   * @param htmlFileName
   */
  virtual void registerHTMLFile(const PendantID p, const std::string& htmlFileName) = 0;

  /**
   * Register HTML for later reference by name (must be uniquely named, with .html extension)
   * 
   * @param p
   * @param htmlData
   * @param htmlName
   */
  virtual void registerHTMLData(const PendantID p, const std::string& htmlData, const std::string& htmlName) = 0;

  /**
   * Register a translation file (e.g. a Java properties file for a language); extension is used to determine format
   * 
   * @param p
   * @param locale
   * @param translationFileName
   */
  virtual void registerTranslationFile(const PendantID p, const std::string& locale, const std::string& translationFileName) = 0;

  /**
   * Register translation file data (translationName typically filename-like; extension is used to determine format)
   * 
   * @param p
   * @param locale
   * @param translationData
   * @param translationName
   */
  virtual void registerTranslationData(const PendantID p, const std::string& locale, const std::string& translationData, const std::string& translationName) = 0;

  /**
   * Register a Utility window with the UI.
   * The itemType references a previously registered YML item instantiated for the window
   * UI content.
   * A main menu entry will automatically be added to the pendant UI, for opening the utility window.
   * 
   * @param p
   * @param identifier
   * @param itemType
   * @param menuItemName
   * @param windowTitle
   */
  virtual void registerUtilityWindow(const PendantID p, const std::string& identifier, const std::string& itemType, const std::string& menuItemName, const std::string& windowTitle) = 0;
  virtual void unregisterUtilityWindow(const PendantID p, const std::string& identifier) = 0;

  /**
   * Open (make visible) previously registered Utility Window
   * 
   * @param p
   * @param identifier
   */
  virtual void openUtilityWindow(const PendantID p, const std::string& identifier) = 0;

  /**
   * Close a visible Utility Window (make invisible - state is maintained)
   * 
   * @param p
   * @param identifier
   */
  virtual void closeUtilityWindow(const PendantID p, const std::string& identifier) = 0;

  /**
   * Collapse previously registered Utility Window, if in expanded state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  virtual void collapseUtilityWindow(const PendantID p, const std::string& identifier) = 0;

  /**
   * Expand previously registered Utility Window, if in collapsed state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  virtual void expandUtilityWindow(const PendantID p, const std::string& identifier) = 0;

  /**
   * Register UI content at the specified integration point in the pendant UI.
   * The itemType should reference a YML item previouslt registered via registerYML().
   * 
   * @param p
   * @param identifier
   * @param integrationPoint
   * @param itemType
   * @param buttonLabel
   * @param buttonImage
   */
  virtual void registerIntegration(const PendantID p, const std::string& identifier, const IntegrationPoint::type integrationPoint, const std::string& itemType, const std::string& buttonLabel, const std::string& buttonImage) = 0;
  virtual void unregisterIntegration(const PendantID p, const std::string& identifier) = 0;

  /**
   * get property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   */
  virtual void property(Any& _return, const PendantID p, const std::string& itemID, const std::string& name) = 0;

  /**
   * Set property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   * @param value
   */
  virtual void setProperty(const PendantID p, const std::string& itemID, const std::string& name, const Any& value) = 0;

  /**
   * Set several properties (potentially for different items) at once.  This is more
   * efficient that many repeated calls to setProperty().  Note it is async so no
   * errors/exceptions are thrown
   * 
   * @param p
   * @param propValuesList
   */
  virtual void setProperties(const PendantID p, const std::vector<PropValues> & propValuesList) = 0;

  /**
   * Set the configuration of a chart by ID.
   * 
   * @param p
   * @param chartID
   * @param config
   */
  virtual void setChartConfig(const PendantID p, const std::string& chartID, const Any& config) = 0;

  /**
   * Get the configuration of a chart by ID
   * 
   * @param p
   * @param chartID
   */
  virtual void getChartConfig(Any& _return, const PendantID p, const std::string& chartID) = 0;

  /**
   * Set the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param dataset
   * @param right
   */
  virtual void setChartData(const PendantID p, const std::string& chartID, const DataSet& dataset, const bool right) = 0;

  /**
   * Get the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to access the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param right
   */
  virtual void getChartData(DataSet& _return, const PendantID p, const std::string& chartID, const bool right) = 0;

  /**
   * Add a new key to the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param data
   * @param right
   */
  virtual void addChartKey(const PendantID p, const std::string& chartID, const std::string& key, const Data& data, const bool right) = 0;

  /**
   * Removes an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to remove from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param right
   */
  virtual void removeChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool right) = 0;

  /**
   * Hides an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to hide a key from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param hidden
   * @param right
   */
  virtual void hideChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool hidden, const bool right) = 0;

  /**
   * Append new data points to a specified key in the data of a chart by ID.
   * This function will only have an effect on line/scatter charts. Set
   * 'right' to true to pass the dataset for a secondary scale on the right
   * hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param points
   * @param right
   */
  virtual void appendChartPoints(const PendantID p, const std::string& chartID, const std::string& key, const std::vector<DataPoint> & points, const bool right) = 0;

  /**
   * Increments a category value by `val`.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param val
   */
  virtual void incrementChartKey(const PendantID p, const std::string& chartID, const std::string& key, const double val) = 0;

  /**
   * Export the current chart contents to the specified filename (must be uniquely named, with .jpg or .png).
   * Calls exportChartImageData if the extension is unable to access the file.
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  virtual void exportChartImage(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) = 0;

  /**
   * Export the current chart contents to a binary blob (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  virtual void exportChartImageData(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) = 0;

  /**
   * Show notice to user.
   * Notices are automaticlly hidden after a short display period.
   * Notice messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  virtual void notice(const PendantID p, const std::string& title, const std::string& message, const std::string& log) = 0;

  /**
   * Show notice to user with specified disposition.
   * As for notice() but displayed in a way that connotes the specified disposition.
   * For example, a Positive disposition may be shown in green.
   * (API version 2.1 and later)
   * 
   * @param p
   * @param disposition
   * @param title
   * @param message
   * @param log
   */
  virtual void dispNotice(const PendantID p, const Disposition::type disposition, const std::string& title, const std::string& message, const std::string& log) = 0;

  /**
   * Show error to user.
   * Errors should only indicate important situations that the user must be aware of and for which deliberate
   * acknowledgement is required before proceeding.  Typically, some action will be required to correct the situation.
   * Errors are displayed until dismissed by the user.
   * Error messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  virtual void error(const PendantID p, const std::string& title, const std::string& message, const std::string& log) = 0;

  /**
   * Display modal pop-up dialog.  Typically, Yes/No, although negativeOption can be omitted
   * The identifier can be used to associate the corresponding PopupOpened & PopupClosed events triggered by
   * user positive/negative selection or automatic dismissal/cancellation - for example is screen switched, alarm etc.
   * 
   * @param p
   * @param identifier
   * @param title
   * @param message
   * @param positiveOption
   * @param negativeOption
   */
  virtual void popupDialog(const PendantID p, const std::string& identifier, const std::string& title, const std::string& message, const std::string& positiveOption, const std::string& negativeOption) = 0;

  /**
   * Cancel an open popup dialog.  If the dialog has a negative option, behaves as if user selected it, otherwise
   * no event is generated
   * 
   * @param p
   * @param identifier
   */
  virtual void cancelPopupDialog(const PendantID p, const std::string& identifier) = 0;

  /**
   * Inserts an instruction, returns a string:
   * Success,
   * UnsupportedCommand,
   * InvalidFormat,
   * ProgrammingViewClosed,
   * JobDoesNotExist,
   * CallingJobFromSameJob,
   * ExceededMaxArguments,
   * JobNotEditable,
   * MultiSelectActive,
   * TimedOut,
   * Unknown
   * 
   * @param p
   * @param instruction
   */
  virtual void insertInstructionAtSelectedLine(std::string& _return, const PendantID p, const std::string& instruction) = 0;

  /**
   * Displays a standard pendant UI screen by passing a string with the screen identifier. (Only available from SDK API 2.2 onward)
   * Refer to the YML - URI Links documentation for the list of supported screens and settings.
   * Do not include the URI "&lt;a href&gt; screen:" portion in the identifier.  For example to display the jogging panel use:
   * pendant.displayScreen("programmingView?panel=jogging");
   * 
   * @param p
   * @param identifier
   */
  virtual void displayScreen(const PendantID p, const std::string& identifier) = 0;
};

class PendantIfFactory {
 public:
  typedef PendantIf Handler;

  virtual ~PendantIfFactory() {}

  virtual PendantIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(PendantIf* /* handler */) = 0;
  };

class PendantIfSingletonFactory : virtual public PendantIfFactory {
 public:
  PendantIfSingletonFactory(const ::std::shared_ptr<PendantIf>& iface) : iface_(iface) {}
  virtual ~PendantIfSingletonFactory() {}

  virtual PendantIf* getHandler(const ::apache::thrift::TConnectionInfo&) override {
    return iface_.get();
  }
  virtual void releaseHandler(PendantIf* /* handler */) override {}

 protected:
  ::std::shared_ptr<PendantIf> iface_;
};

class PendantNull : virtual public PendantIf {
 public:
  virtual ~PendantNull() {}
  void pendantVersion(Version& /* _return */, const PendantID /* p */) override {
    return;
  }
  void subscribeEventTypes(const PendantID /* p */, const std::set<PendantEventType::type> & /* types */) override {
    return;
  }
  void unsubscribeEventTypes(const PendantID /* p */, const std::set<PendantEventType::type> & /* types */) override {
    return;
  }
  void events(std::vector<PendantEvent> & /* _return */, const PendantID /* p */) override {
    return;
  }
  void currentLanguage(std::string& /* _return */, const PendantID /* p */) override {
    return;
  }
  void currentLocale(std::string& /* _return */, const PendantID /* p */) override {
    return;
  }
  void currentScreenName(std::string& /* _return */, const PendantID /* p */) override {
    return;
  }
  void registerYML(std::vector<std::string> & /* _return */, const PendantID /* p */, const std::string& /* ymlSource */) override {
    return;
  }
  void registerImageFile(const PendantID /* p */, const std::string& /* imageFileName */) override {
    return;
  }
  void registerImageData(const PendantID /* p */, const std::string& /* imageData */, const std::string& /* imageName */) override {
    return;
  }
  void registerHTMLFile(const PendantID /* p */, const std::string& /* htmlFileName */) override {
    return;
  }
  void registerHTMLData(const PendantID /* p */, const std::string& /* htmlData */, const std::string& /* htmlName */) override {
    return;
  }
  void registerTranslationFile(const PendantID /* p */, const std::string& /* locale */, const std::string& /* translationFileName */) override {
    return;
  }
  void registerTranslationData(const PendantID /* p */, const std::string& /* locale */, const std::string& /* translationData */, const std::string& /* translationName */) override {
    return;
  }
  void registerUtilityWindow(const PendantID /* p */, const std::string& /* identifier */, const std::string& /* itemType */, const std::string& /* menuItemName */, const std::string& /* windowTitle */) override {
    return;
  }
  void unregisterUtilityWindow(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
  void openUtilityWindow(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
  void closeUtilityWindow(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
  void collapseUtilityWindow(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
  void expandUtilityWindow(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
  void registerIntegration(const PendantID /* p */, const std::string& /* identifier */, const IntegrationPoint::type /* integrationPoint */, const std::string& /* itemType */, const std::string& /* buttonLabel */, const std::string& /* buttonImage */) override {
    return;
  }
  void unregisterIntegration(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
  void property(Any& /* _return */, const PendantID /* p */, const std::string& /* itemID */, const std::string& /* name */) override {
    return;
  }
  void setProperty(const PendantID /* p */, const std::string& /* itemID */, const std::string& /* name */, const Any& /* value */) override {
    return;
  }
  void setProperties(const PendantID /* p */, const std::vector<PropValues> & /* propValuesList */) override {
    return;
  }
  void setChartConfig(const PendantID /* p */, const std::string& /* chartID */, const Any& /* config */) override {
    return;
  }
  void getChartConfig(Any& /* _return */, const PendantID /* p */, const std::string& /* chartID */) override {
    return;
  }
  void setChartData(const PendantID /* p */, const std::string& /* chartID */, const DataSet& /* dataset */, const bool /* right */) override {
    return;
  }
  void getChartData(DataSet& /* _return */, const PendantID /* p */, const std::string& /* chartID */, const bool /* right */) override {
    return;
  }
  void addChartKey(const PendantID /* p */, const std::string& /* chartID */, const std::string& /* key */, const Data& /* data */, const bool /* right */) override {
    return;
  }
  void removeChartKey(const PendantID /* p */, const std::string& /* chartID */, const std::string& /* key */, const bool /* right */) override {
    return;
  }
  void hideChartKey(const PendantID /* p */, const std::string& /* chartID */, const std::string& /* key */, const bool /* hidden */, const bool /* right */) override {
    return;
  }
  void appendChartPoints(const PendantID /* p */, const std::string& /* chartID */, const std::string& /* key */, const std::vector<DataPoint> & /* points */, const bool /* right */) override {
    return;
  }
  void incrementChartKey(const PendantID /* p */, const std::string& /* chartID */, const std::string& /* key */, const double /* val */) override {
    return;
  }
  void exportChartImage(std::string& /* _return */, const PendantID /* p */, const std::string& /* chartID */, const std::string& /* imageFileName */) override {
    return;
  }
  void exportChartImageData(std::string& /* _return */, const PendantID /* p */, const std::string& /* chartID */, const std::string& /* imageFileName */) override {
    return;
  }
  void notice(const PendantID /* p */, const std::string& /* title */, const std::string& /* message */, const std::string& /* log */) override {
    return;
  }
  void dispNotice(const PendantID /* p */, const Disposition::type /* disposition */, const std::string& /* title */, const std::string& /* message */, const std::string& /* log */) override {
    return;
  }
  void error(const PendantID /* p */, const std::string& /* title */, const std::string& /* message */, const std::string& /* log */) override {
    return;
  }
  void popupDialog(const PendantID /* p */, const std::string& /* identifier */, const std::string& /* title */, const std::string& /* message */, const std::string& /* positiveOption */, const std::string& /* negativeOption */) override {
    return;
  }
  void cancelPopupDialog(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
  void insertInstructionAtSelectedLine(std::string& /* _return */, const PendantID /* p */, const std::string& /* instruction */) override {
    return;
  }
  void displayScreen(const PendantID /* p */, const std::string& /* identifier */) override {
    return;
  }
};

typedef struct _Pendant_pendantVersion_args__isset {
  _Pendant_pendantVersion_args__isset() : p(false) {}
  bool p :1;
} _Pendant_pendantVersion_args__isset;

class Pendant_pendantVersion_args {
 public:

  Pendant_pendantVersion_args(const Pendant_pendantVersion_args&) noexcept;
  Pendant_pendantVersion_args& operator=(const Pendant_pendantVersion_args&) noexcept;
  Pendant_pendantVersion_args() noexcept
                              : p(0) {
  }

  virtual ~Pendant_pendantVersion_args() noexcept;
  PendantID p;

  _Pendant_pendantVersion_args__isset __isset;

  void __set_p(const PendantID val);

  bool operator == (const Pendant_pendantVersion_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    return true;
  }
  bool operator != (const Pendant_pendantVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_pendantVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_pendantVersion_pargs {
 public:


  virtual ~Pendant_pendantVersion_pargs() noexcept;
  const PendantID* p;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_pendantVersion_result__isset {
  _Pendant_pendantVersion_result__isset() : success(false) {}
  bool success :1;
} _Pendant_pendantVersion_result__isset;

class Pendant_pendantVersion_result {
 public:

  Pendant_pendantVersion_result(const Pendant_pendantVersion_result&);
  Pendant_pendantVersion_result& operator=(const Pendant_pendantVersion_result&);
  Pendant_pendantVersion_result() noexcept {
  }

  virtual ~Pendant_pendantVersion_result() noexcept;
  Version success;

  _Pendant_pendantVersion_result__isset __isset;

  void __set_success(const Version& val);

  bool operator == (const Pendant_pendantVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pendant_pendantVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_pendantVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_pendantVersion_presult__isset {
  _Pendant_pendantVersion_presult__isset() : success(false) {}
  bool success :1;
} _Pendant_pendantVersion_presult__isset;

class Pendant_pendantVersion_presult {
 public:


  virtual ~Pendant_pendantVersion_presult() noexcept;
  Version* success;

  _Pendant_pendantVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_subscribeEventTypes_args__isset {
  _Pendant_subscribeEventTypes_args__isset() : p(false), types(false) {}
  bool p :1;
  bool types :1;
} _Pendant_subscribeEventTypes_args__isset;

class Pendant_subscribeEventTypes_args {
 public:

  Pendant_subscribeEventTypes_args(const Pendant_subscribeEventTypes_args&);
  Pendant_subscribeEventTypes_args& operator=(const Pendant_subscribeEventTypes_args&);
  Pendant_subscribeEventTypes_args() noexcept
                                   : p(0) {
  }

  virtual ~Pendant_subscribeEventTypes_args() noexcept;
  PendantID p;
  std::set<PendantEventType::type>  types;

  _Pendant_subscribeEventTypes_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_types(const std::set<PendantEventType::type> & val);

  bool operator == (const Pendant_subscribeEventTypes_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const Pendant_subscribeEventTypes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_subscribeEventTypes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_subscribeEventTypes_pargs {
 public:


  virtual ~Pendant_subscribeEventTypes_pargs() noexcept;
  const PendantID* p;
  const std::set<PendantEventType::type> * types;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_subscribeEventTypes_result {
 public:

  Pendant_subscribeEventTypes_result(const Pendant_subscribeEventTypes_result&) noexcept;
  Pendant_subscribeEventTypes_result& operator=(const Pendant_subscribeEventTypes_result&) noexcept;
  Pendant_subscribeEventTypes_result() noexcept {
  }

  virtual ~Pendant_subscribeEventTypes_result() noexcept;

  bool operator == (const Pendant_subscribeEventTypes_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_subscribeEventTypes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_subscribeEventTypes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_subscribeEventTypes_presult {
 public:


  virtual ~Pendant_subscribeEventTypes_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_unsubscribeEventTypes_args__isset {
  _Pendant_unsubscribeEventTypes_args__isset() : p(false), types(false) {}
  bool p :1;
  bool types :1;
} _Pendant_unsubscribeEventTypes_args__isset;

class Pendant_unsubscribeEventTypes_args {
 public:

  Pendant_unsubscribeEventTypes_args(const Pendant_unsubscribeEventTypes_args&);
  Pendant_unsubscribeEventTypes_args& operator=(const Pendant_unsubscribeEventTypes_args&);
  Pendant_unsubscribeEventTypes_args() noexcept
                                     : p(0) {
  }

  virtual ~Pendant_unsubscribeEventTypes_args() noexcept;
  PendantID p;
  std::set<PendantEventType::type>  types;

  _Pendant_unsubscribeEventTypes_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_types(const std::set<PendantEventType::type> & val);

  bool operator == (const Pendant_unsubscribeEventTypes_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const Pendant_unsubscribeEventTypes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_unsubscribeEventTypes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_unsubscribeEventTypes_pargs {
 public:


  virtual ~Pendant_unsubscribeEventTypes_pargs() noexcept;
  const PendantID* p;
  const std::set<PendantEventType::type> * types;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_unsubscribeEventTypes_result {
 public:

  Pendant_unsubscribeEventTypes_result(const Pendant_unsubscribeEventTypes_result&) noexcept;
  Pendant_unsubscribeEventTypes_result& operator=(const Pendant_unsubscribeEventTypes_result&) noexcept;
  Pendant_unsubscribeEventTypes_result() noexcept {
  }

  virtual ~Pendant_unsubscribeEventTypes_result() noexcept;

  bool operator == (const Pendant_unsubscribeEventTypes_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_unsubscribeEventTypes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_unsubscribeEventTypes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_unsubscribeEventTypes_presult {
 public:


  virtual ~Pendant_unsubscribeEventTypes_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_events_args__isset {
  _Pendant_events_args__isset() : p(false) {}
  bool p :1;
} _Pendant_events_args__isset;

class Pendant_events_args {
 public:

  Pendant_events_args(const Pendant_events_args&) noexcept;
  Pendant_events_args& operator=(const Pendant_events_args&) noexcept;
  Pendant_events_args() noexcept
                      : p(0) {
  }

  virtual ~Pendant_events_args() noexcept;
  PendantID p;

  _Pendant_events_args__isset __isset;

  void __set_p(const PendantID val);

  bool operator == (const Pendant_events_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    return true;
  }
  bool operator != (const Pendant_events_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_events_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_events_pargs {
 public:


  virtual ~Pendant_events_pargs() noexcept;
  const PendantID* p;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_events_result__isset {
  _Pendant_events_result__isset() : success(false) {}
  bool success :1;
} _Pendant_events_result__isset;

class Pendant_events_result {
 public:

  Pendant_events_result(const Pendant_events_result&);
  Pendant_events_result& operator=(const Pendant_events_result&);
  Pendant_events_result() noexcept {
  }

  virtual ~Pendant_events_result() noexcept;
  std::vector<PendantEvent>  success;

  _Pendant_events_result__isset __isset;

  void __set_success(const std::vector<PendantEvent> & val);

  bool operator == (const Pendant_events_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pendant_events_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_events_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_events_presult__isset {
  _Pendant_events_presult__isset() : success(false) {}
  bool success :1;
} _Pendant_events_presult__isset;

class Pendant_events_presult {
 public:


  virtual ~Pendant_events_presult() noexcept;
  std::vector<PendantEvent> * success;

  _Pendant_events_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_currentLanguage_args__isset {
  _Pendant_currentLanguage_args__isset() : p(false) {}
  bool p :1;
} _Pendant_currentLanguage_args__isset;

class Pendant_currentLanguage_args {
 public:

  Pendant_currentLanguage_args(const Pendant_currentLanguage_args&) noexcept;
  Pendant_currentLanguage_args& operator=(const Pendant_currentLanguage_args&) noexcept;
  Pendant_currentLanguage_args() noexcept
                               : p(0) {
  }

  virtual ~Pendant_currentLanguage_args() noexcept;
  PendantID p;

  _Pendant_currentLanguage_args__isset __isset;

  void __set_p(const PendantID val);

  bool operator == (const Pendant_currentLanguage_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    return true;
  }
  bool operator != (const Pendant_currentLanguage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_currentLanguage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_currentLanguage_pargs {
 public:


  virtual ~Pendant_currentLanguage_pargs() noexcept;
  const PendantID* p;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_currentLanguage_result__isset {
  _Pendant_currentLanguage_result__isset() : success(false) {}
  bool success :1;
} _Pendant_currentLanguage_result__isset;

class Pendant_currentLanguage_result {
 public:

  Pendant_currentLanguage_result(const Pendant_currentLanguage_result&);
  Pendant_currentLanguage_result& operator=(const Pendant_currentLanguage_result&);
  Pendant_currentLanguage_result() noexcept
                                 : success() {
  }

  virtual ~Pendant_currentLanguage_result() noexcept;
  std::string success;

  _Pendant_currentLanguage_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Pendant_currentLanguage_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pendant_currentLanguage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_currentLanguage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_currentLanguage_presult__isset {
  _Pendant_currentLanguage_presult__isset() : success(false) {}
  bool success :1;
} _Pendant_currentLanguage_presult__isset;

class Pendant_currentLanguage_presult {
 public:


  virtual ~Pendant_currentLanguage_presult() noexcept;
  std::string* success;

  _Pendant_currentLanguage_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_currentLocale_args__isset {
  _Pendant_currentLocale_args__isset() : p(false) {}
  bool p :1;
} _Pendant_currentLocale_args__isset;

class Pendant_currentLocale_args {
 public:

  Pendant_currentLocale_args(const Pendant_currentLocale_args&) noexcept;
  Pendant_currentLocale_args& operator=(const Pendant_currentLocale_args&) noexcept;
  Pendant_currentLocale_args() noexcept
                             : p(0) {
  }

  virtual ~Pendant_currentLocale_args() noexcept;
  PendantID p;

  _Pendant_currentLocale_args__isset __isset;

  void __set_p(const PendantID val);

  bool operator == (const Pendant_currentLocale_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    return true;
  }
  bool operator != (const Pendant_currentLocale_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_currentLocale_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_currentLocale_pargs {
 public:


  virtual ~Pendant_currentLocale_pargs() noexcept;
  const PendantID* p;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_currentLocale_result__isset {
  _Pendant_currentLocale_result__isset() : success(false) {}
  bool success :1;
} _Pendant_currentLocale_result__isset;

class Pendant_currentLocale_result {
 public:

  Pendant_currentLocale_result(const Pendant_currentLocale_result&);
  Pendant_currentLocale_result& operator=(const Pendant_currentLocale_result&);
  Pendant_currentLocale_result() noexcept
                               : success() {
  }

  virtual ~Pendant_currentLocale_result() noexcept;
  std::string success;

  _Pendant_currentLocale_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Pendant_currentLocale_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pendant_currentLocale_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_currentLocale_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_currentLocale_presult__isset {
  _Pendant_currentLocale_presult__isset() : success(false) {}
  bool success :1;
} _Pendant_currentLocale_presult__isset;

class Pendant_currentLocale_presult {
 public:


  virtual ~Pendant_currentLocale_presult() noexcept;
  std::string* success;

  _Pendant_currentLocale_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_currentScreenName_args__isset {
  _Pendant_currentScreenName_args__isset() : p(false) {}
  bool p :1;
} _Pendant_currentScreenName_args__isset;

class Pendant_currentScreenName_args {
 public:

  Pendant_currentScreenName_args(const Pendant_currentScreenName_args&) noexcept;
  Pendant_currentScreenName_args& operator=(const Pendant_currentScreenName_args&) noexcept;
  Pendant_currentScreenName_args() noexcept
                                 : p(0) {
  }

  virtual ~Pendant_currentScreenName_args() noexcept;
  PendantID p;

  _Pendant_currentScreenName_args__isset __isset;

  void __set_p(const PendantID val);

  bool operator == (const Pendant_currentScreenName_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    return true;
  }
  bool operator != (const Pendant_currentScreenName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_currentScreenName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_currentScreenName_pargs {
 public:


  virtual ~Pendant_currentScreenName_pargs() noexcept;
  const PendantID* p;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_currentScreenName_result__isset {
  _Pendant_currentScreenName_result__isset() : success(false) {}
  bool success :1;
} _Pendant_currentScreenName_result__isset;

class Pendant_currentScreenName_result {
 public:

  Pendant_currentScreenName_result(const Pendant_currentScreenName_result&);
  Pendant_currentScreenName_result& operator=(const Pendant_currentScreenName_result&);
  Pendant_currentScreenName_result() noexcept
                                   : success() {
  }

  virtual ~Pendant_currentScreenName_result() noexcept;
  std::string success;

  _Pendant_currentScreenName_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Pendant_currentScreenName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pendant_currentScreenName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_currentScreenName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_currentScreenName_presult__isset {
  _Pendant_currentScreenName_presult__isset() : success(false) {}
  bool success :1;
} _Pendant_currentScreenName_presult__isset;

class Pendant_currentScreenName_presult {
 public:


  virtual ~Pendant_currentScreenName_presult() noexcept;
  std::string* success;

  _Pendant_currentScreenName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerYML_args__isset {
  _Pendant_registerYML_args__isset() : p(false), ymlSource(false) {}
  bool p :1;
  bool ymlSource :1;
} _Pendant_registerYML_args__isset;

class Pendant_registerYML_args {
 public:

  Pendant_registerYML_args(const Pendant_registerYML_args&);
  Pendant_registerYML_args& operator=(const Pendant_registerYML_args&);
  Pendant_registerYML_args() noexcept
                           : p(0),
                             ymlSource() {
  }

  virtual ~Pendant_registerYML_args() noexcept;
  PendantID p;
  std::string ymlSource;

  _Pendant_registerYML_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_ymlSource(const std::string& val);

  bool operator == (const Pendant_registerYML_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(ymlSource == rhs.ymlSource))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerYML_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerYML_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerYML_pargs {
 public:


  virtual ~Pendant_registerYML_pargs() noexcept;
  const PendantID* p;
  const std::string* ymlSource;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerYML_result__isset {
  _Pendant_registerYML_result__isset() : success(false) {}
  bool success :1;
} _Pendant_registerYML_result__isset;

class Pendant_registerYML_result {
 public:

  Pendant_registerYML_result(const Pendant_registerYML_result&);
  Pendant_registerYML_result& operator=(const Pendant_registerYML_result&);
  Pendant_registerYML_result() noexcept {
  }

  virtual ~Pendant_registerYML_result() noexcept;
  std::vector<std::string>  success;

  _Pendant_registerYML_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  bool operator == (const Pendant_registerYML_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerYML_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerYML_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerYML_presult__isset {
  _Pendant_registerYML_presult__isset() : success(false) {}
  bool success :1;
} _Pendant_registerYML_presult__isset;

class Pendant_registerYML_presult {
 public:


  virtual ~Pendant_registerYML_presult() noexcept;
  std::vector<std::string> * success;

  _Pendant_registerYML_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerImageFile_args__isset {
  _Pendant_registerImageFile_args__isset() : p(false), imageFileName(false) {}
  bool p :1;
  bool imageFileName :1;
} _Pendant_registerImageFile_args__isset;

class Pendant_registerImageFile_args {
 public:

  Pendant_registerImageFile_args(const Pendant_registerImageFile_args&);
  Pendant_registerImageFile_args& operator=(const Pendant_registerImageFile_args&);
  Pendant_registerImageFile_args() noexcept
                                 : p(0),
                                   imageFileName() {
  }

  virtual ~Pendant_registerImageFile_args() noexcept;
  PendantID p;
  std::string imageFileName;

  _Pendant_registerImageFile_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_imageFileName(const std::string& val);

  bool operator == (const Pendant_registerImageFile_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(imageFileName == rhs.imageFileName))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerImageFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerImageFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerImageFile_pargs {
 public:


  virtual ~Pendant_registerImageFile_pargs() noexcept;
  const PendantID* p;
  const std::string* imageFileName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerImageFile_result__isset {
  _Pendant_registerImageFile_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerImageFile_result__isset;

class Pendant_registerImageFile_result {
 public:

  Pendant_registerImageFile_result(const Pendant_registerImageFile_result&);
  Pendant_registerImageFile_result& operator=(const Pendant_registerImageFile_result&);
  Pendant_registerImageFile_result() noexcept {
  }

  virtual ~Pendant_registerImageFile_result() noexcept;
  IllegalArgument e;

  _Pendant_registerImageFile_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerImageFile_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerImageFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerImageFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerImageFile_presult__isset {
  _Pendant_registerImageFile_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerImageFile_presult__isset;

class Pendant_registerImageFile_presult {
 public:


  virtual ~Pendant_registerImageFile_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerImageFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerImageData_args__isset {
  _Pendant_registerImageData_args__isset() : p(false), imageData(false), imageName(false) {}
  bool p :1;
  bool imageData :1;
  bool imageName :1;
} _Pendant_registerImageData_args__isset;

class Pendant_registerImageData_args {
 public:

  Pendant_registerImageData_args(const Pendant_registerImageData_args&);
  Pendant_registerImageData_args& operator=(const Pendant_registerImageData_args&);
  Pendant_registerImageData_args() noexcept
                                 : p(0),
                                   imageData(),
                                   imageName() {
  }

  virtual ~Pendant_registerImageData_args() noexcept;
  PendantID p;
  std::string imageData;
  std::string imageName;

  _Pendant_registerImageData_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_imageData(const std::string& val);

  void __set_imageName(const std::string& val);

  bool operator == (const Pendant_registerImageData_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(imageData == rhs.imageData))
      return false;
    if (!(imageName == rhs.imageName))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerImageData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerImageData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerImageData_pargs {
 public:


  virtual ~Pendant_registerImageData_pargs() noexcept;
  const PendantID* p;
  const std::string* imageData;
  const std::string* imageName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerImageData_result__isset {
  _Pendant_registerImageData_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerImageData_result__isset;

class Pendant_registerImageData_result {
 public:

  Pendant_registerImageData_result(const Pendant_registerImageData_result&);
  Pendant_registerImageData_result& operator=(const Pendant_registerImageData_result&);
  Pendant_registerImageData_result() noexcept {
  }

  virtual ~Pendant_registerImageData_result() noexcept;
  IllegalArgument e;

  _Pendant_registerImageData_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerImageData_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerImageData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerImageData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerImageData_presult__isset {
  _Pendant_registerImageData_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerImageData_presult__isset;

class Pendant_registerImageData_presult {
 public:


  virtual ~Pendant_registerImageData_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerImageData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerHTMLFile_args__isset {
  _Pendant_registerHTMLFile_args__isset() : p(false), htmlFileName(false) {}
  bool p :1;
  bool htmlFileName :1;
} _Pendant_registerHTMLFile_args__isset;

class Pendant_registerHTMLFile_args {
 public:

  Pendant_registerHTMLFile_args(const Pendant_registerHTMLFile_args&);
  Pendant_registerHTMLFile_args& operator=(const Pendant_registerHTMLFile_args&);
  Pendant_registerHTMLFile_args() noexcept
                                : p(0),
                                  htmlFileName() {
  }

  virtual ~Pendant_registerHTMLFile_args() noexcept;
  PendantID p;
  std::string htmlFileName;

  _Pendant_registerHTMLFile_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_htmlFileName(const std::string& val);

  bool operator == (const Pendant_registerHTMLFile_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(htmlFileName == rhs.htmlFileName))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerHTMLFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerHTMLFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerHTMLFile_pargs {
 public:


  virtual ~Pendant_registerHTMLFile_pargs() noexcept;
  const PendantID* p;
  const std::string* htmlFileName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerHTMLFile_result__isset {
  _Pendant_registerHTMLFile_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerHTMLFile_result__isset;

class Pendant_registerHTMLFile_result {
 public:

  Pendant_registerHTMLFile_result(const Pendant_registerHTMLFile_result&);
  Pendant_registerHTMLFile_result& operator=(const Pendant_registerHTMLFile_result&);
  Pendant_registerHTMLFile_result() noexcept {
  }

  virtual ~Pendant_registerHTMLFile_result() noexcept;
  IllegalArgument e;

  _Pendant_registerHTMLFile_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerHTMLFile_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerHTMLFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerHTMLFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerHTMLFile_presult__isset {
  _Pendant_registerHTMLFile_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerHTMLFile_presult__isset;

class Pendant_registerHTMLFile_presult {
 public:


  virtual ~Pendant_registerHTMLFile_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerHTMLFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerHTMLData_args__isset {
  _Pendant_registerHTMLData_args__isset() : p(false), htmlData(false), htmlName(false) {}
  bool p :1;
  bool htmlData :1;
  bool htmlName :1;
} _Pendant_registerHTMLData_args__isset;

class Pendant_registerHTMLData_args {
 public:

  Pendant_registerHTMLData_args(const Pendant_registerHTMLData_args&);
  Pendant_registerHTMLData_args& operator=(const Pendant_registerHTMLData_args&);
  Pendant_registerHTMLData_args() noexcept
                                : p(0),
                                  htmlData(),
                                  htmlName() {
  }

  virtual ~Pendant_registerHTMLData_args() noexcept;
  PendantID p;
  std::string htmlData;
  std::string htmlName;

  _Pendant_registerHTMLData_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_htmlData(const std::string& val);

  void __set_htmlName(const std::string& val);

  bool operator == (const Pendant_registerHTMLData_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(htmlData == rhs.htmlData))
      return false;
    if (!(htmlName == rhs.htmlName))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerHTMLData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerHTMLData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerHTMLData_pargs {
 public:


  virtual ~Pendant_registerHTMLData_pargs() noexcept;
  const PendantID* p;
  const std::string* htmlData;
  const std::string* htmlName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerHTMLData_result__isset {
  _Pendant_registerHTMLData_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerHTMLData_result__isset;

class Pendant_registerHTMLData_result {
 public:

  Pendant_registerHTMLData_result(const Pendant_registerHTMLData_result&);
  Pendant_registerHTMLData_result& operator=(const Pendant_registerHTMLData_result&);
  Pendant_registerHTMLData_result() noexcept {
  }

  virtual ~Pendant_registerHTMLData_result() noexcept;
  IllegalArgument e;

  _Pendant_registerHTMLData_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerHTMLData_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerHTMLData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerHTMLData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerHTMLData_presult__isset {
  _Pendant_registerHTMLData_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerHTMLData_presult__isset;

class Pendant_registerHTMLData_presult {
 public:


  virtual ~Pendant_registerHTMLData_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerHTMLData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerTranslationFile_args__isset {
  _Pendant_registerTranslationFile_args__isset() : p(false), locale(false), translationFileName(false) {}
  bool p :1;
  bool locale :1;
  bool translationFileName :1;
} _Pendant_registerTranslationFile_args__isset;

class Pendant_registerTranslationFile_args {
 public:

  Pendant_registerTranslationFile_args(const Pendant_registerTranslationFile_args&);
  Pendant_registerTranslationFile_args& operator=(const Pendant_registerTranslationFile_args&);
  Pendant_registerTranslationFile_args() noexcept
                                       : p(0),
                                         locale(),
                                         translationFileName() {
  }

  virtual ~Pendant_registerTranslationFile_args() noexcept;
  PendantID p;
  std::string locale;
  std::string translationFileName;

  _Pendant_registerTranslationFile_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_locale(const std::string& val);

  void __set_translationFileName(const std::string& val);

  bool operator == (const Pendant_registerTranslationFile_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(locale == rhs.locale))
      return false;
    if (!(translationFileName == rhs.translationFileName))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerTranslationFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerTranslationFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerTranslationFile_pargs {
 public:


  virtual ~Pendant_registerTranslationFile_pargs() noexcept;
  const PendantID* p;
  const std::string* locale;
  const std::string* translationFileName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerTranslationFile_result__isset {
  _Pendant_registerTranslationFile_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerTranslationFile_result__isset;

class Pendant_registerTranslationFile_result {
 public:

  Pendant_registerTranslationFile_result(const Pendant_registerTranslationFile_result&);
  Pendant_registerTranslationFile_result& operator=(const Pendant_registerTranslationFile_result&);
  Pendant_registerTranslationFile_result() noexcept {
  }

  virtual ~Pendant_registerTranslationFile_result() noexcept;
  IllegalArgument e;

  _Pendant_registerTranslationFile_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerTranslationFile_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerTranslationFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerTranslationFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerTranslationFile_presult__isset {
  _Pendant_registerTranslationFile_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerTranslationFile_presult__isset;

class Pendant_registerTranslationFile_presult {
 public:


  virtual ~Pendant_registerTranslationFile_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerTranslationFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerTranslationData_args__isset {
  _Pendant_registerTranslationData_args__isset() : p(false), locale(false), translationData(false), translationName(false) {}
  bool p :1;
  bool locale :1;
  bool translationData :1;
  bool translationName :1;
} _Pendant_registerTranslationData_args__isset;

class Pendant_registerTranslationData_args {
 public:

  Pendant_registerTranslationData_args(const Pendant_registerTranslationData_args&);
  Pendant_registerTranslationData_args& operator=(const Pendant_registerTranslationData_args&);
  Pendant_registerTranslationData_args() noexcept
                                       : p(0),
                                         locale(),
                                         translationData(),
                                         translationName() {
  }

  virtual ~Pendant_registerTranslationData_args() noexcept;
  PendantID p;
  std::string locale;
  std::string translationData;
  std::string translationName;

  _Pendant_registerTranslationData_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_locale(const std::string& val);

  void __set_translationData(const std::string& val);

  void __set_translationName(const std::string& val);

  bool operator == (const Pendant_registerTranslationData_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(locale == rhs.locale))
      return false;
    if (!(translationData == rhs.translationData))
      return false;
    if (!(translationName == rhs.translationName))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerTranslationData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerTranslationData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerTranslationData_pargs {
 public:


  virtual ~Pendant_registerTranslationData_pargs() noexcept;
  const PendantID* p;
  const std::string* locale;
  const std::string* translationData;
  const std::string* translationName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerTranslationData_result__isset {
  _Pendant_registerTranslationData_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerTranslationData_result__isset;

class Pendant_registerTranslationData_result {
 public:

  Pendant_registerTranslationData_result(const Pendant_registerTranslationData_result&);
  Pendant_registerTranslationData_result& operator=(const Pendant_registerTranslationData_result&);
  Pendant_registerTranslationData_result() noexcept {
  }

  virtual ~Pendant_registerTranslationData_result() noexcept;
  IllegalArgument e;

  _Pendant_registerTranslationData_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerTranslationData_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerTranslationData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerTranslationData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerTranslationData_presult__isset {
  _Pendant_registerTranslationData_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerTranslationData_presult__isset;

class Pendant_registerTranslationData_presult {
 public:


  virtual ~Pendant_registerTranslationData_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerTranslationData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerUtilityWindow_args__isset {
  _Pendant_registerUtilityWindow_args__isset() : p(false), identifier(false), itemType(false), menuItemName(false), windowTitle(false) {}
  bool p :1;
  bool identifier :1;
  bool itemType :1;
  bool menuItemName :1;
  bool windowTitle :1;
} _Pendant_registerUtilityWindow_args__isset;

class Pendant_registerUtilityWindow_args {
 public:

  Pendant_registerUtilityWindow_args(const Pendant_registerUtilityWindow_args&);
  Pendant_registerUtilityWindow_args& operator=(const Pendant_registerUtilityWindow_args&);
  Pendant_registerUtilityWindow_args() noexcept
                                     : p(0),
                                       identifier(),
                                       itemType(),
                                       menuItemName(),
                                       windowTitle() {
  }

  virtual ~Pendant_registerUtilityWindow_args() noexcept;
  PendantID p;
  std::string identifier;
  std::string itemType;
  std::string menuItemName;
  std::string windowTitle;

  _Pendant_registerUtilityWindow_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  void __set_itemType(const std::string& val);

  void __set_menuItemName(const std::string& val);

  void __set_windowTitle(const std::string& val);

  bool operator == (const Pendant_registerUtilityWindow_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    if (!(itemType == rhs.itemType))
      return false;
    if (!(menuItemName == rhs.menuItemName))
      return false;
    if (!(windowTitle == rhs.windowTitle))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerUtilityWindow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerUtilityWindow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerUtilityWindow_pargs {
 public:


  virtual ~Pendant_registerUtilityWindow_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;
  const std::string* itemType;
  const std::string* menuItemName;
  const std::string* windowTitle;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerUtilityWindow_result__isset {
  _Pendant_registerUtilityWindow_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerUtilityWindow_result__isset;

class Pendant_registerUtilityWindow_result {
 public:

  Pendant_registerUtilityWindow_result(const Pendant_registerUtilityWindow_result&);
  Pendant_registerUtilityWindow_result& operator=(const Pendant_registerUtilityWindow_result&);
  Pendant_registerUtilityWindow_result() noexcept {
  }

  virtual ~Pendant_registerUtilityWindow_result() noexcept;
  IllegalArgument e;

  _Pendant_registerUtilityWindow_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerUtilityWindow_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerUtilityWindow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerUtilityWindow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerUtilityWindow_presult__isset {
  _Pendant_registerUtilityWindow_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerUtilityWindow_presult__isset;

class Pendant_registerUtilityWindow_presult {
 public:


  virtual ~Pendant_registerUtilityWindow_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerUtilityWindow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_unregisterUtilityWindow_args__isset {
  _Pendant_unregisterUtilityWindow_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_unregisterUtilityWindow_args__isset;

class Pendant_unregisterUtilityWindow_args {
 public:

  Pendant_unregisterUtilityWindow_args(const Pendant_unregisterUtilityWindow_args&);
  Pendant_unregisterUtilityWindow_args& operator=(const Pendant_unregisterUtilityWindow_args&);
  Pendant_unregisterUtilityWindow_args() noexcept
                                       : p(0),
                                         identifier() {
  }

  virtual ~Pendant_unregisterUtilityWindow_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_unregisterUtilityWindow_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_unregisterUtilityWindow_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_unregisterUtilityWindow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_unregisterUtilityWindow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_unregisterUtilityWindow_pargs {
 public:


  virtual ~Pendant_unregisterUtilityWindow_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_unregisterUtilityWindow_result__isset {
  _Pendant_unregisterUtilityWindow_result__isset() : e(false) {}
  bool e :1;
} _Pendant_unregisterUtilityWindow_result__isset;

class Pendant_unregisterUtilityWindow_result {
 public:

  Pendant_unregisterUtilityWindow_result(const Pendant_unregisterUtilityWindow_result&);
  Pendant_unregisterUtilityWindow_result& operator=(const Pendant_unregisterUtilityWindow_result&);
  Pendant_unregisterUtilityWindow_result() noexcept {
  }

  virtual ~Pendant_unregisterUtilityWindow_result() noexcept;
  IllegalArgument e;

  _Pendant_unregisterUtilityWindow_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_unregisterUtilityWindow_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_unregisterUtilityWindow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_unregisterUtilityWindow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_unregisterUtilityWindow_presult__isset {
  _Pendant_unregisterUtilityWindow_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_unregisterUtilityWindow_presult__isset;

class Pendant_unregisterUtilityWindow_presult {
 public:


  virtual ~Pendant_unregisterUtilityWindow_presult() noexcept;
  IllegalArgument e;

  _Pendant_unregisterUtilityWindow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_openUtilityWindow_args__isset {
  _Pendant_openUtilityWindow_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_openUtilityWindow_args__isset;

class Pendant_openUtilityWindow_args {
 public:

  Pendant_openUtilityWindow_args(const Pendant_openUtilityWindow_args&);
  Pendant_openUtilityWindow_args& operator=(const Pendant_openUtilityWindow_args&);
  Pendant_openUtilityWindow_args() noexcept
                                 : p(0),
                                   identifier() {
  }

  virtual ~Pendant_openUtilityWindow_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_openUtilityWindow_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_openUtilityWindow_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_openUtilityWindow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_openUtilityWindow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_openUtilityWindow_pargs {
 public:


  virtual ~Pendant_openUtilityWindow_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_openUtilityWindow_result {
 public:

  Pendant_openUtilityWindow_result(const Pendant_openUtilityWindow_result&) noexcept;
  Pendant_openUtilityWindow_result& operator=(const Pendant_openUtilityWindow_result&) noexcept;
  Pendant_openUtilityWindow_result() noexcept {
  }

  virtual ~Pendant_openUtilityWindow_result() noexcept;

  bool operator == (const Pendant_openUtilityWindow_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_openUtilityWindow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_openUtilityWindow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_openUtilityWindow_presult {
 public:


  virtual ~Pendant_openUtilityWindow_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_closeUtilityWindow_args__isset {
  _Pendant_closeUtilityWindow_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_closeUtilityWindow_args__isset;

class Pendant_closeUtilityWindow_args {
 public:

  Pendant_closeUtilityWindow_args(const Pendant_closeUtilityWindow_args&);
  Pendant_closeUtilityWindow_args& operator=(const Pendant_closeUtilityWindow_args&);
  Pendant_closeUtilityWindow_args() noexcept
                                  : p(0),
                                    identifier() {
  }

  virtual ~Pendant_closeUtilityWindow_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_closeUtilityWindow_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_closeUtilityWindow_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_closeUtilityWindow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_closeUtilityWindow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_closeUtilityWindow_pargs {
 public:


  virtual ~Pendant_closeUtilityWindow_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_closeUtilityWindow_result {
 public:

  Pendant_closeUtilityWindow_result(const Pendant_closeUtilityWindow_result&) noexcept;
  Pendant_closeUtilityWindow_result& operator=(const Pendant_closeUtilityWindow_result&) noexcept;
  Pendant_closeUtilityWindow_result() noexcept {
  }

  virtual ~Pendant_closeUtilityWindow_result() noexcept;

  bool operator == (const Pendant_closeUtilityWindow_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_closeUtilityWindow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_closeUtilityWindow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_closeUtilityWindow_presult {
 public:


  virtual ~Pendant_closeUtilityWindow_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_collapseUtilityWindow_args__isset {
  _Pendant_collapseUtilityWindow_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_collapseUtilityWindow_args__isset;

class Pendant_collapseUtilityWindow_args {
 public:

  Pendant_collapseUtilityWindow_args(const Pendant_collapseUtilityWindow_args&);
  Pendant_collapseUtilityWindow_args& operator=(const Pendant_collapseUtilityWindow_args&);
  Pendant_collapseUtilityWindow_args() noexcept
                                     : p(0),
                                       identifier() {
  }

  virtual ~Pendant_collapseUtilityWindow_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_collapseUtilityWindow_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_collapseUtilityWindow_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_collapseUtilityWindow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_collapseUtilityWindow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_collapseUtilityWindow_pargs {
 public:


  virtual ~Pendant_collapseUtilityWindow_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_collapseUtilityWindow_result {
 public:

  Pendant_collapseUtilityWindow_result(const Pendant_collapseUtilityWindow_result&) noexcept;
  Pendant_collapseUtilityWindow_result& operator=(const Pendant_collapseUtilityWindow_result&) noexcept;
  Pendant_collapseUtilityWindow_result() noexcept {
  }

  virtual ~Pendant_collapseUtilityWindow_result() noexcept;

  bool operator == (const Pendant_collapseUtilityWindow_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_collapseUtilityWindow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_collapseUtilityWindow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_collapseUtilityWindow_presult {
 public:


  virtual ~Pendant_collapseUtilityWindow_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_expandUtilityWindow_args__isset {
  _Pendant_expandUtilityWindow_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_expandUtilityWindow_args__isset;

class Pendant_expandUtilityWindow_args {
 public:

  Pendant_expandUtilityWindow_args(const Pendant_expandUtilityWindow_args&);
  Pendant_expandUtilityWindow_args& operator=(const Pendant_expandUtilityWindow_args&);
  Pendant_expandUtilityWindow_args() noexcept
                                   : p(0),
                                     identifier() {
  }

  virtual ~Pendant_expandUtilityWindow_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_expandUtilityWindow_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_expandUtilityWindow_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_expandUtilityWindow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_expandUtilityWindow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_expandUtilityWindow_pargs {
 public:


  virtual ~Pendant_expandUtilityWindow_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_expandUtilityWindow_result {
 public:

  Pendant_expandUtilityWindow_result(const Pendant_expandUtilityWindow_result&) noexcept;
  Pendant_expandUtilityWindow_result& operator=(const Pendant_expandUtilityWindow_result&) noexcept;
  Pendant_expandUtilityWindow_result() noexcept {
  }

  virtual ~Pendant_expandUtilityWindow_result() noexcept;

  bool operator == (const Pendant_expandUtilityWindow_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_expandUtilityWindow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_expandUtilityWindow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_expandUtilityWindow_presult {
 public:


  virtual ~Pendant_expandUtilityWindow_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_registerIntegration_args__isset {
  _Pendant_registerIntegration_args__isset() : p(false), identifier(false), integrationPoint(false), itemType(false), buttonLabel(false), buttonImage(false) {}
  bool p :1;
  bool identifier :1;
  bool integrationPoint :1;
  bool itemType :1;
  bool buttonLabel :1;
  bool buttonImage :1;
} _Pendant_registerIntegration_args__isset;

class Pendant_registerIntegration_args {
 public:

  Pendant_registerIntegration_args(const Pendant_registerIntegration_args&);
  Pendant_registerIntegration_args& operator=(const Pendant_registerIntegration_args&);
  Pendant_registerIntegration_args() noexcept
                                   : p(0),
                                     identifier(),
                                     integrationPoint(static_cast<IntegrationPoint::type>(0)),
                                     itemType(),
                                     buttonLabel(),
                                     buttonImage() {
  }

  virtual ~Pendant_registerIntegration_args() noexcept;
  PendantID p;
  std::string identifier;
  /**
   * 
   * @see IntegrationPoint
   */
  IntegrationPoint::type integrationPoint;
  std::string itemType;
  std::string buttonLabel;
  std::string buttonImage;

  _Pendant_registerIntegration_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  void __set_integrationPoint(const IntegrationPoint::type val);

  void __set_itemType(const std::string& val);

  void __set_buttonLabel(const std::string& val);

  void __set_buttonImage(const std::string& val);

  bool operator == (const Pendant_registerIntegration_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    if (!(integrationPoint == rhs.integrationPoint))
      return false;
    if (!(itemType == rhs.itemType))
      return false;
    if (!(buttonLabel == rhs.buttonLabel))
      return false;
    if (!(buttonImage == rhs.buttonImage))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerIntegration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerIntegration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_registerIntegration_pargs {
 public:


  virtual ~Pendant_registerIntegration_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;
  /**
   * 
   * @see IntegrationPoint
   */
  const IntegrationPoint::type* integrationPoint;
  const std::string* itemType;
  const std::string* buttonLabel;
  const std::string* buttonImage;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerIntegration_result__isset {
  _Pendant_registerIntegration_result__isset() : e(false) {}
  bool e :1;
} _Pendant_registerIntegration_result__isset;

class Pendant_registerIntegration_result {
 public:

  Pendant_registerIntegration_result(const Pendant_registerIntegration_result&);
  Pendant_registerIntegration_result& operator=(const Pendant_registerIntegration_result&);
  Pendant_registerIntegration_result() noexcept {
  }

  virtual ~Pendant_registerIntegration_result() noexcept;
  IllegalArgument e;

  _Pendant_registerIntegration_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_registerIntegration_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_registerIntegration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_registerIntegration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_registerIntegration_presult__isset {
  _Pendant_registerIntegration_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_registerIntegration_presult__isset;

class Pendant_registerIntegration_presult {
 public:


  virtual ~Pendant_registerIntegration_presult() noexcept;
  IllegalArgument e;

  _Pendant_registerIntegration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_unregisterIntegration_args__isset {
  _Pendant_unregisterIntegration_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_unregisterIntegration_args__isset;

class Pendant_unregisterIntegration_args {
 public:

  Pendant_unregisterIntegration_args(const Pendant_unregisterIntegration_args&);
  Pendant_unregisterIntegration_args& operator=(const Pendant_unregisterIntegration_args&);
  Pendant_unregisterIntegration_args() noexcept
                                     : p(0),
                                       identifier() {
  }

  virtual ~Pendant_unregisterIntegration_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_unregisterIntegration_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_unregisterIntegration_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_unregisterIntegration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_unregisterIntegration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_unregisterIntegration_pargs {
 public:


  virtual ~Pendant_unregisterIntegration_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_unregisterIntegration_result__isset {
  _Pendant_unregisterIntegration_result__isset() : e(false) {}
  bool e :1;
} _Pendant_unregisterIntegration_result__isset;

class Pendant_unregisterIntegration_result {
 public:

  Pendant_unregisterIntegration_result(const Pendant_unregisterIntegration_result&);
  Pendant_unregisterIntegration_result& operator=(const Pendant_unregisterIntegration_result&);
  Pendant_unregisterIntegration_result() noexcept {
  }

  virtual ~Pendant_unregisterIntegration_result() noexcept;
  IllegalArgument e;

  _Pendant_unregisterIntegration_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_unregisterIntegration_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_unregisterIntegration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_unregisterIntegration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_unregisterIntegration_presult__isset {
  _Pendant_unregisterIntegration_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_unregisterIntegration_presult__isset;

class Pendant_unregisterIntegration_presult {
 public:


  virtual ~Pendant_unregisterIntegration_presult() noexcept;
  IllegalArgument e;

  _Pendant_unregisterIntegration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_property_args__isset {
  _Pendant_property_args__isset() : p(false), itemID(false), name(false) {}
  bool p :1;
  bool itemID :1;
  bool name :1;
} _Pendant_property_args__isset;

class Pendant_property_args {
 public:

  Pendant_property_args(const Pendant_property_args&);
  Pendant_property_args& operator=(const Pendant_property_args&);
  Pendant_property_args() noexcept
                        : p(0),
                          itemID(),
                          name() {
  }

  virtual ~Pendant_property_args() noexcept;
  PendantID p;
  std::string itemID;
  std::string name;

  _Pendant_property_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_itemID(const std::string& val);

  void __set_name(const std::string& val);

  bool operator == (const Pendant_property_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(itemID == rhs.itemID))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Pendant_property_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_property_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_property_pargs {
 public:


  virtual ~Pendant_property_pargs() noexcept;
  const PendantID* p;
  const std::string* itemID;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_property_result__isset {
  _Pendant_property_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_property_result__isset;

class Pendant_property_result {
 public:

  Pendant_property_result(const Pendant_property_result&);
  Pendant_property_result& operator=(const Pendant_property_result&);
  Pendant_property_result() noexcept {
  }

  virtual ~Pendant_property_result() noexcept;
  Any success;
  IllegalArgument e;

  _Pendant_property_result__isset __isset;

  void __set_success(const Any& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_property_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_property_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_property_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_property_presult__isset {
  _Pendant_property_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_property_presult__isset;

class Pendant_property_presult {
 public:


  virtual ~Pendant_property_presult() noexcept;
  Any* success;
  IllegalArgument e;

  _Pendant_property_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_setProperty_args__isset {
  _Pendant_setProperty_args__isset() : p(false), itemID(false), name(false), value(false) {}
  bool p :1;
  bool itemID :1;
  bool name :1;
  bool value :1;
} _Pendant_setProperty_args__isset;

class Pendant_setProperty_args {
 public:

  Pendant_setProperty_args(const Pendant_setProperty_args&);
  Pendant_setProperty_args& operator=(const Pendant_setProperty_args&);
  Pendant_setProperty_args() noexcept
                           : p(0),
                             itemID(),
                             name() {
  }

  virtual ~Pendant_setProperty_args() noexcept;
  PendantID p;
  std::string itemID;
  std::string name;
  Any value;

  _Pendant_setProperty_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_itemID(const std::string& val);

  void __set_name(const std::string& val);

  void __set_value(const Any& val);

  bool operator == (const Pendant_setProperty_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(itemID == rhs.itemID))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Pendant_setProperty_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_setProperty_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_setProperty_pargs {
 public:


  virtual ~Pendant_setProperty_pargs() noexcept;
  const PendantID* p;
  const std::string* itemID;
  const std::string* name;
  const Any* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_setProperty_result__isset {
  _Pendant_setProperty_result__isset() : e(false) {}
  bool e :1;
} _Pendant_setProperty_result__isset;

class Pendant_setProperty_result {
 public:

  Pendant_setProperty_result(const Pendant_setProperty_result&);
  Pendant_setProperty_result& operator=(const Pendant_setProperty_result&);
  Pendant_setProperty_result() noexcept {
  }

  virtual ~Pendant_setProperty_result() noexcept;
  IllegalArgument e;

  _Pendant_setProperty_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_setProperty_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_setProperty_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_setProperty_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_setProperty_presult__isset {
  _Pendant_setProperty_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_setProperty_presult__isset;

class Pendant_setProperty_presult {
 public:


  virtual ~Pendant_setProperty_presult() noexcept;
  IllegalArgument e;

  _Pendant_setProperty_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_setProperties_args__isset {
  _Pendant_setProperties_args__isset() : p(false), propValuesList(false) {}
  bool p :1;
  bool propValuesList :1;
} _Pendant_setProperties_args__isset;

class Pendant_setProperties_args {
 public:

  Pendant_setProperties_args(const Pendant_setProperties_args&);
  Pendant_setProperties_args& operator=(const Pendant_setProperties_args&);
  Pendant_setProperties_args() noexcept
                             : p(0) {
  }

  virtual ~Pendant_setProperties_args() noexcept;
  PendantID p;
  std::vector<PropValues>  propValuesList;

  _Pendant_setProperties_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_propValuesList(const std::vector<PropValues> & val);

  bool operator == (const Pendant_setProperties_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(propValuesList == rhs.propValuesList))
      return false;
    return true;
  }
  bool operator != (const Pendant_setProperties_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_setProperties_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_setProperties_pargs {
 public:


  virtual ~Pendant_setProperties_pargs() noexcept;
  const PendantID* p;
  const std::vector<PropValues> * propValuesList;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_setChartConfig_args__isset {
  _Pendant_setChartConfig_args__isset() : p(false), chartID(false), config(false) {}
  bool p :1;
  bool chartID :1;
  bool config :1;
} _Pendant_setChartConfig_args__isset;

class Pendant_setChartConfig_args {
 public:

  Pendant_setChartConfig_args(const Pendant_setChartConfig_args&);
  Pendant_setChartConfig_args& operator=(const Pendant_setChartConfig_args&);
  Pendant_setChartConfig_args() noexcept
                              : p(0),
                                chartID() {
  }

  virtual ~Pendant_setChartConfig_args() noexcept;
  PendantID p;
  std::string chartID;
  Any config;

  _Pendant_setChartConfig_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_config(const Any& val);

  bool operator == (const Pendant_setChartConfig_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(config == rhs.config))
      return false;
    return true;
  }
  bool operator != (const Pendant_setChartConfig_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_setChartConfig_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_setChartConfig_pargs {
 public:


  virtual ~Pendant_setChartConfig_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const Any* config;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_setChartConfig_result__isset {
  _Pendant_setChartConfig_result__isset() : e(false) {}
  bool e :1;
} _Pendant_setChartConfig_result__isset;

class Pendant_setChartConfig_result {
 public:

  Pendant_setChartConfig_result(const Pendant_setChartConfig_result&);
  Pendant_setChartConfig_result& operator=(const Pendant_setChartConfig_result&);
  Pendant_setChartConfig_result() noexcept {
  }

  virtual ~Pendant_setChartConfig_result() noexcept;
  IllegalArgument e;

  _Pendant_setChartConfig_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_setChartConfig_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_setChartConfig_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_setChartConfig_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_setChartConfig_presult__isset {
  _Pendant_setChartConfig_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_setChartConfig_presult__isset;

class Pendant_setChartConfig_presult {
 public:


  virtual ~Pendant_setChartConfig_presult() noexcept;
  IllegalArgument e;

  _Pendant_setChartConfig_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_getChartConfig_args__isset {
  _Pendant_getChartConfig_args__isset() : p(false), chartID(false) {}
  bool p :1;
  bool chartID :1;
} _Pendant_getChartConfig_args__isset;

class Pendant_getChartConfig_args {
 public:

  Pendant_getChartConfig_args(const Pendant_getChartConfig_args&);
  Pendant_getChartConfig_args& operator=(const Pendant_getChartConfig_args&);
  Pendant_getChartConfig_args() noexcept
                              : p(0),
                                chartID() {
  }

  virtual ~Pendant_getChartConfig_args() noexcept;
  PendantID p;
  std::string chartID;

  _Pendant_getChartConfig_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  bool operator == (const Pendant_getChartConfig_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    return true;
  }
  bool operator != (const Pendant_getChartConfig_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_getChartConfig_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_getChartConfig_pargs {
 public:


  virtual ~Pendant_getChartConfig_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_getChartConfig_result__isset {
  _Pendant_getChartConfig_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_getChartConfig_result__isset;

class Pendant_getChartConfig_result {
 public:

  Pendant_getChartConfig_result(const Pendant_getChartConfig_result&);
  Pendant_getChartConfig_result& operator=(const Pendant_getChartConfig_result&);
  Pendant_getChartConfig_result() noexcept {
  }

  virtual ~Pendant_getChartConfig_result() noexcept;
  Any success;
  IllegalArgument e;

  _Pendant_getChartConfig_result__isset __isset;

  void __set_success(const Any& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_getChartConfig_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_getChartConfig_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_getChartConfig_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_getChartConfig_presult__isset {
  _Pendant_getChartConfig_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_getChartConfig_presult__isset;

class Pendant_getChartConfig_presult {
 public:


  virtual ~Pendant_getChartConfig_presult() noexcept;
  Any* success;
  IllegalArgument e;

  _Pendant_getChartConfig_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_setChartData_args__isset {
  _Pendant_setChartData_args__isset() : p(false), chartID(false), dataset(false), right(false) {}
  bool p :1;
  bool chartID :1;
  bool dataset :1;
  bool right :1;
} _Pendant_setChartData_args__isset;

class Pendant_setChartData_args {
 public:

  Pendant_setChartData_args(const Pendant_setChartData_args&);
  Pendant_setChartData_args& operator=(const Pendant_setChartData_args&);
  Pendant_setChartData_args() noexcept
                            : p(0),
                              chartID(),
                              right(0) {
  }

  virtual ~Pendant_setChartData_args() noexcept;
  PendantID p;
  std::string chartID;
  DataSet dataset;
  bool right;

  _Pendant_setChartData_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_dataset(const DataSet& val);

  void __set_right(const bool val);

  bool operator == (const Pendant_setChartData_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(dataset == rhs.dataset))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const Pendant_setChartData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_setChartData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_setChartData_pargs {
 public:


  virtual ~Pendant_setChartData_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const DataSet* dataset;
  const bool* right;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_setChartData_result__isset {
  _Pendant_setChartData_result__isset() : e(false) {}
  bool e :1;
} _Pendant_setChartData_result__isset;

class Pendant_setChartData_result {
 public:

  Pendant_setChartData_result(const Pendant_setChartData_result&);
  Pendant_setChartData_result& operator=(const Pendant_setChartData_result&);
  Pendant_setChartData_result() noexcept {
  }

  virtual ~Pendant_setChartData_result() noexcept;
  IllegalArgument e;

  _Pendant_setChartData_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_setChartData_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_setChartData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_setChartData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_setChartData_presult__isset {
  _Pendant_setChartData_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_setChartData_presult__isset;

class Pendant_setChartData_presult {
 public:


  virtual ~Pendant_setChartData_presult() noexcept;
  IllegalArgument e;

  _Pendant_setChartData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_getChartData_args__isset {
  _Pendant_getChartData_args__isset() : p(false), chartID(false), right(false) {}
  bool p :1;
  bool chartID :1;
  bool right :1;
} _Pendant_getChartData_args__isset;

class Pendant_getChartData_args {
 public:

  Pendant_getChartData_args(const Pendant_getChartData_args&);
  Pendant_getChartData_args& operator=(const Pendant_getChartData_args&);
  Pendant_getChartData_args() noexcept
                            : p(0),
                              chartID(),
                              right(0) {
  }

  virtual ~Pendant_getChartData_args() noexcept;
  PendantID p;
  std::string chartID;
  bool right;

  _Pendant_getChartData_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_right(const bool val);

  bool operator == (const Pendant_getChartData_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const Pendant_getChartData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_getChartData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_getChartData_pargs {
 public:


  virtual ~Pendant_getChartData_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const bool* right;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_getChartData_result__isset {
  _Pendant_getChartData_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_getChartData_result__isset;

class Pendant_getChartData_result {
 public:

  Pendant_getChartData_result(const Pendant_getChartData_result&);
  Pendant_getChartData_result& operator=(const Pendant_getChartData_result&);
  Pendant_getChartData_result() noexcept {
  }

  virtual ~Pendant_getChartData_result() noexcept;
  DataSet success;
  IllegalArgument e;

  _Pendant_getChartData_result__isset __isset;

  void __set_success(const DataSet& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_getChartData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_getChartData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_getChartData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_getChartData_presult__isset {
  _Pendant_getChartData_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_getChartData_presult__isset;

class Pendant_getChartData_presult {
 public:


  virtual ~Pendant_getChartData_presult() noexcept;
  DataSet* success;
  IllegalArgument e;

  _Pendant_getChartData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_addChartKey_args__isset {
  _Pendant_addChartKey_args__isset() : p(false), chartID(false), key(false), data(false), right(false) {}
  bool p :1;
  bool chartID :1;
  bool key :1;
  bool data :1;
  bool right :1;
} _Pendant_addChartKey_args__isset;

class Pendant_addChartKey_args {
 public:

  Pendant_addChartKey_args(const Pendant_addChartKey_args&);
  Pendant_addChartKey_args& operator=(const Pendant_addChartKey_args&);
  Pendant_addChartKey_args() noexcept
                           : p(0),
                             chartID(),
                             key(),
                             right(0) {
  }

  virtual ~Pendant_addChartKey_args() noexcept;
  PendantID p;
  std::string chartID;
  std::string key;
  Data data;
  bool right;

  _Pendant_addChartKey_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_key(const std::string& val);

  void __set_data(const Data& val);

  void __set_right(const bool val);

  bool operator == (const Pendant_addChartKey_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const Pendant_addChartKey_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_addChartKey_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_addChartKey_pargs {
 public:


  virtual ~Pendant_addChartKey_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const std::string* key;
  const Data* data;
  const bool* right;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_addChartKey_result__isset {
  _Pendant_addChartKey_result__isset() : e(false) {}
  bool e :1;
} _Pendant_addChartKey_result__isset;

class Pendant_addChartKey_result {
 public:

  Pendant_addChartKey_result(const Pendant_addChartKey_result&);
  Pendant_addChartKey_result& operator=(const Pendant_addChartKey_result&);
  Pendant_addChartKey_result() noexcept {
  }

  virtual ~Pendant_addChartKey_result() noexcept;
  IllegalArgument e;

  _Pendant_addChartKey_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_addChartKey_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_addChartKey_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_addChartKey_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_addChartKey_presult__isset {
  _Pendant_addChartKey_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_addChartKey_presult__isset;

class Pendant_addChartKey_presult {
 public:


  virtual ~Pendant_addChartKey_presult() noexcept;
  IllegalArgument e;

  _Pendant_addChartKey_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_removeChartKey_args__isset {
  _Pendant_removeChartKey_args__isset() : p(false), chartID(false), key(false), right(false) {}
  bool p :1;
  bool chartID :1;
  bool key :1;
  bool right :1;
} _Pendant_removeChartKey_args__isset;

class Pendant_removeChartKey_args {
 public:

  Pendant_removeChartKey_args(const Pendant_removeChartKey_args&);
  Pendant_removeChartKey_args& operator=(const Pendant_removeChartKey_args&);
  Pendant_removeChartKey_args() noexcept
                              : p(0),
                                chartID(),
                                key(),
                                right(0) {
  }

  virtual ~Pendant_removeChartKey_args() noexcept;
  PendantID p;
  std::string chartID;
  std::string key;
  bool right;

  _Pendant_removeChartKey_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_key(const std::string& val);

  void __set_right(const bool val);

  bool operator == (const Pendant_removeChartKey_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const Pendant_removeChartKey_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_removeChartKey_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_removeChartKey_pargs {
 public:


  virtual ~Pendant_removeChartKey_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const std::string* key;
  const bool* right;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_removeChartKey_result__isset {
  _Pendant_removeChartKey_result__isset() : e(false) {}
  bool e :1;
} _Pendant_removeChartKey_result__isset;

class Pendant_removeChartKey_result {
 public:

  Pendant_removeChartKey_result(const Pendant_removeChartKey_result&);
  Pendant_removeChartKey_result& operator=(const Pendant_removeChartKey_result&);
  Pendant_removeChartKey_result() noexcept {
  }

  virtual ~Pendant_removeChartKey_result() noexcept;
  IllegalArgument e;

  _Pendant_removeChartKey_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_removeChartKey_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_removeChartKey_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_removeChartKey_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_removeChartKey_presult__isset {
  _Pendant_removeChartKey_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_removeChartKey_presult__isset;

class Pendant_removeChartKey_presult {
 public:


  virtual ~Pendant_removeChartKey_presult() noexcept;
  IllegalArgument e;

  _Pendant_removeChartKey_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_hideChartKey_args__isset {
  _Pendant_hideChartKey_args__isset() : p(false), chartID(false), key(false), hidden(false), right(false) {}
  bool p :1;
  bool chartID :1;
  bool key :1;
  bool hidden :1;
  bool right :1;
} _Pendant_hideChartKey_args__isset;

class Pendant_hideChartKey_args {
 public:

  Pendant_hideChartKey_args(const Pendant_hideChartKey_args&);
  Pendant_hideChartKey_args& operator=(const Pendant_hideChartKey_args&);
  Pendant_hideChartKey_args() noexcept
                            : p(0),
                              chartID(),
                              key(),
                              hidden(0),
                              right(0) {
  }

  virtual ~Pendant_hideChartKey_args() noexcept;
  PendantID p;
  std::string chartID;
  std::string key;
  bool hidden;
  bool right;

  _Pendant_hideChartKey_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_key(const std::string& val);

  void __set_hidden(const bool val);

  void __set_right(const bool val);

  bool operator == (const Pendant_hideChartKey_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(hidden == rhs.hidden))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const Pendant_hideChartKey_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_hideChartKey_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_hideChartKey_pargs {
 public:


  virtual ~Pendant_hideChartKey_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const std::string* key;
  const bool* hidden;
  const bool* right;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_hideChartKey_result__isset {
  _Pendant_hideChartKey_result__isset() : e(false) {}
  bool e :1;
} _Pendant_hideChartKey_result__isset;

class Pendant_hideChartKey_result {
 public:

  Pendant_hideChartKey_result(const Pendant_hideChartKey_result&);
  Pendant_hideChartKey_result& operator=(const Pendant_hideChartKey_result&);
  Pendant_hideChartKey_result() noexcept {
  }

  virtual ~Pendant_hideChartKey_result() noexcept;
  IllegalArgument e;

  _Pendant_hideChartKey_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_hideChartKey_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_hideChartKey_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_hideChartKey_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_hideChartKey_presult__isset {
  _Pendant_hideChartKey_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_hideChartKey_presult__isset;

class Pendant_hideChartKey_presult {
 public:


  virtual ~Pendant_hideChartKey_presult() noexcept;
  IllegalArgument e;

  _Pendant_hideChartKey_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_appendChartPoints_args__isset {
  _Pendant_appendChartPoints_args__isset() : p(false), chartID(false), key(false), points(false), right(false) {}
  bool p :1;
  bool chartID :1;
  bool key :1;
  bool points :1;
  bool right :1;
} _Pendant_appendChartPoints_args__isset;

class Pendant_appendChartPoints_args {
 public:

  Pendant_appendChartPoints_args(const Pendant_appendChartPoints_args&);
  Pendant_appendChartPoints_args& operator=(const Pendant_appendChartPoints_args&);
  Pendant_appendChartPoints_args() noexcept
                                 : p(0),
                                   chartID(),
                                   key(),
                                   right(0) {
  }

  virtual ~Pendant_appendChartPoints_args() noexcept;
  PendantID p;
  std::string chartID;
  std::string key;
  std::vector<DataPoint>  points;
  bool right;

  _Pendant_appendChartPoints_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_key(const std::string& val);

  void __set_points(const std::vector<DataPoint> & val);

  void __set_right(const bool val);

  bool operator == (const Pendant_appendChartPoints_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(points == rhs.points))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const Pendant_appendChartPoints_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_appendChartPoints_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_appendChartPoints_pargs {
 public:


  virtual ~Pendant_appendChartPoints_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const std::string* key;
  const std::vector<DataPoint> * points;
  const bool* right;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_incrementChartKey_args__isset {
  _Pendant_incrementChartKey_args__isset() : p(false), chartID(false), key(false), val(false) {}
  bool p :1;
  bool chartID :1;
  bool key :1;
  bool val :1;
} _Pendant_incrementChartKey_args__isset;

class Pendant_incrementChartKey_args {
 public:

  Pendant_incrementChartKey_args(const Pendant_incrementChartKey_args&);
  Pendant_incrementChartKey_args& operator=(const Pendant_incrementChartKey_args&);
  Pendant_incrementChartKey_args() noexcept
                                 : p(0),
                                   chartID(),
                                   key(),
                                   val(0) {
  }

  virtual ~Pendant_incrementChartKey_args() noexcept;
  PendantID p;
  std::string chartID;
  std::string key;
  double val;

  _Pendant_incrementChartKey_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_key(const std::string& val);

  void __set_val(const double val);

  bool operator == (const Pendant_incrementChartKey_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(val == rhs.val))
      return false;
    return true;
  }
  bool operator != (const Pendant_incrementChartKey_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_incrementChartKey_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_incrementChartKey_pargs {
 public:


  virtual ~Pendant_incrementChartKey_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const std::string* key;
  const double* val;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_incrementChartKey_result__isset {
  _Pendant_incrementChartKey_result__isset() : e(false) {}
  bool e :1;
} _Pendant_incrementChartKey_result__isset;

class Pendant_incrementChartKey_result {
 public:

  Pendant_incrementChartKey_result(const Pendant_incrementChartKey_result&);
  Pendant_incrementChartKey_result& operator=(const Pendant_incrementChartKey_result&);
  Pendant_incrementChartKey_result() noexcept {
  }

  virtual ~Pendant_incrementChartKey_result() noexcept;
  IllegalArgument e;

  _Pendant_incrementChartKey_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_incrementChartKey_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_incrementChartKey_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_incrementChartKey_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_incrementChartKey_presult__isset {
  _Pendant_incrementChartKey_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_incrementChartKey_presult__isset;

class Pendant_incrementChartKey_presult {
 public:


  virtual ~Pendant_incrementChartKey_presult() noexcept;
  IllegalArgument e;

  _Pendant_incrementChartKey_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_exportChartImage_args__isset {
  _Pendant_exportChartImage_args__isset() : p(false), chartID(false), imageFileName(false) {}
  bool p :1;
  bool chartID :1;
  bool imageFileName :1;
} _Pendant_exportChartImage_args__isset;

class Pendant_exportChartImage_args {
 public:

  Pendant_exportChartImage_args(const Pendant_exportChartImage_args&);
  Pendant_exportChartImage_args& operator=(const Pendant_exportChartImage_args&);
  Pendant_exportChartImage_args() noexcept
                                : p(0),
                                  chartID(),
                                  imageFileName() {
  }

  virtual ~Pendant_exportChartImage_args() noexcept;
  PendantID p;
  std::string chartID;
  std::string imageFileName;

  _Pendant_exportChartImage_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_imageFileName(const std::string& val);

  bool operator == (const Pendant_exportChartImage_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(imageFileName == rhs.imageFileName))
      return false;
    return true;
  }
  bool operator != (const Pendant_exportChartImage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_exportChartImage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_exportChartImage_pargs {
 public:


  virtual ~Pendant_exportChartImage_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const std::string* imageFileName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_exportChartImage_result__isset {
  _Pendant_exportChartImage_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_exportChartImage_result__isset;

class Pendant_exportChartImage_result {
 public:

  Pendant_exportChartImage_result(const Pendant_exportChartImage_result&);
  Pendant_exportChartImage_result& operator=(const Pendant_exportChartImage_result&);
  Pendant_exportChartImage_result() noexcept
                                  : success() {
  }

  virtual ~Pendant_exportChartImage_result() noexcept;
  std::string success;
  IllegalArgument e;

  _Pendant_exportChartImage_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_exportChartImage_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_exportChartImage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_exportChartImage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_exportChartImage_presult__isset {
  _Pendant_exportChartImage_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_exportChartImage_presult__isset;

class Pendant_exportChartImage_presult {
 public:


  virtual ~Pendant_exportChartImage_presult() noexcept;
  std::string* success;
  IllegalArgument e;

  _Pendant_exportChartImage_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_exportChartImageData_args__isset {
  _Pendant_exportChartImageData_args__isset() : p(false), chartID(false), imageFileName(false) {}
  bool p :1;
  bool chartID :1;
  bool imageFileName :1;
} _Pendant_exportChartImageData_args__isset;

class Pendant_exportChartImageData_args {
 public:

  Pendant_exportChartImageData_args(const Pendant_exportChartImageData_args&);
  Pendant_exportChartImageData_args& operator=(const Pendant_exportChartImageData_args&);
  Pendant_exportChartImageData_args() noexcept
                                    : p(0),
                                      chartID(),
                                      imageFileName() {
  }

  virtual ~Pendant_exportChartImageData_args() noexcept;
  PendantID p;
  std::string chartID;
  std::string imageFileName;

  _Pendant_exportChartImageData_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_chartID(const std::string& val);

  void __set_imageFileName(const std::string& val);

  bool operator == (const Pendant_exportChartImageData_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(chartID == rhs.chartID))
      return false;
    if (!(imageFileName == rhs.imageFileName))
      return false;
    return true;
  }
  bool operator != (const Pendant_exportChartImageData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_exportChartImageData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_exportChartImageData_pargs {
 public:


  virtual ~Pendant_exportChartImageData_pargs() noexcept;
  const PendantID* p;
  const std::string* chartID;
  const std::string* imageFileName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_exportChartImageData_result__isset {
  _Pendant_exportChartImageData_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_exportChartImageData_result__isset;

class Pendant_exportChartImageData_result {
 public:

  Pendant_exportChartImageData_result(const Pendant_exportChartImageData_result&);
  Pendant_exportChartImageData_result& operator=(const Pendant_exportChartImageData_result&);
  Pendant_exportChartImageData_result() noexcept
                                      : success() {
  }

  virtual ~Pendant_exportChartImageData_result() noexcept;
  std::string success;
  IllegalArgument e;

  _Pendant_exportChartImageData_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_exportChartImageData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_exportChartImageData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_exportChartImageData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_exportChartImageData_presult__isset {
  _Pendant_exportChartImageData_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _Pendant_exportChartImageData_presult__isset;

class Pendant_exportChartImageData_presult {
 public:


  virtual ~Pendant_exportChartImageData_presult() noexcept;
  std::string* success;
  IllegalArgument e;

  _Pendant_exportChartImageData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_notice_args__isset {
  _Pendant_notice_args__isset() : p(false), title(false), message(false), log(false) {}
  bool p :1;
  bool title :1;
  bool message :1;
  bool log :1;
} _Pendant_notice_args__isset;

class Pendant_notice_args {
 public:

  Pendant_notice_args(const Pendant_notice_args&);
  Pendant_notice_args& operator=(const Pendant_notice_args&);
  Pendant_notice_args() noexcept
                      : p(0),
                        title(),
                        message(),
                        log() {
  }

  virtual ~Pendant_notice_args() noexcept;
  PendantID p;
  std::string title;
  std::string message;
  std::string log;

  _Pendant_notice_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_title(const std::string& val);

  void __set_message(const std::string& val);

  void __set_log(const std::string& val);

  bool operator == (const Pendant_notice_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(title == rhs.title))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(log == rhs.log))
      return false;
    return true;
  }
  bool operator != (const Pendant_notice_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_notice_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_notice_pargs {
 public:


  virtual ~Pendant_notice_pargs() noexcept;
  const PendantID* p;
  const std::string* title;
  const std::string* message;
  const std::string* log;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_dispNotice_args__isset {
  _Pendant_dispNotice_args__isset() : p(false), disposition(false), title(false), message(false), log(false) {}
  bool p :1;
  bool disposition :1;
  bool title :1;
  bool message :1;
  bool log :1;
} _Pendant_dispNotice_args__isset;

class Pendant_dispNotice_args {
 public:

  Pendant_dispNotice_args(const Pendant_dispNotice_args&);
  Pendant_dispNotice_args& operator=(const Pendant_dispNotice_args&);
  Pendant_dispNotice_args() noexcept
                          : p(0),
                            disposition(static_cast<Disposition::type>(0)),
                            title(),
                            message(),
                            log() {
  }

  virtual ~Pendant_dispNotice_args() noexcept;
  PendantID p;
  /**
   * 
   * @see Disposition
   */
  Disposition::type disposition;
  std::string title;
  std::string message;
  std::string log;

  _Pendant_dispNotice_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_disposition(const Disposition::type val);

  void __set_title(const std::string& val);

  void __set_message(const std::string& val);

  void __set_log(const std::string& val);

  bool operator == (const Pendant_dispNotice_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(disposition == rhs.disposition))
      return false;
    if (!(title == rhs.title))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(log == rhs.log))
      return false;
    return true;
  }
  bool operator != (const Pendant_dispNotice_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_dispNotice_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_dispNotice_pargs {
 public:


  virtual ~Pendant_dispNotice_pargs() noexcept;
  const PendantID* p;
  /**
   * 
   * @see Disposition
   */
  const Disposition::type* disposition;
  const std::string* title;
  const std::string* message;
  const std::string* log;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_error_args__isset {
  _Pendant_error_args__isset() : p(false), title(false), message(false), log(false) {}
  bool p :1;
  bool title :1;
  bool message :1;
  bool log :1;
} _Pendant_error_args__isset;

class Pendant_error_args {
 public:

  Pendant_error_args(const Pendant_error_args&);
  Pendant_error_args& operator=(const Pendant_error_args&);
  Pendant_error_args() noexcept
                     : p(0),
                       title(),
                       message(),
                       log() {
  }

  virtual ~Pendant_error_args() noexcept;
  PendantID p;
  std::string title;
  std::string message;
  std::string log;

  _Pendant_error_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_title(const std::string& val);

  void __set_message(const std::string& val);

  void __set_log(const std::string& val);

  bool operator == (const Pendant_error_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(title == rhs.title))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(log == rhs.log))
      return false;
    return true;
  }
  bool operator != (const Pendant_error_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_error_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_error_pargs {
 public:


  virtual ~Pendant_error_pargs() noexcept;
  const PendantID* p;
  const std::string* title;
  const std::string* message;
  const std::string* log;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_popupDialog_args__isset {
  _Pendant_popupDialog_args__isset() : p(false), identifier(false), title(false), message(false), positiveOption(false), negativeOption(false) {}
  bool p :1;
  bool identifier :1;
  bool title :1;
  bool message :1;
  bool positiveOption :1;
  bool negativeOption :1;
} _Pendant_popupDialog_args__isset;

class Pendant_popupDialog_args {
 public:

  Pendant_popupDialog_args(const Pendant_popupDialog_args&);
  Pendant_popupDialog_args& operator=(const Pendant_popupDialog_args&);
  Pendant_popupDialog_args() noexcept
                           : p(0),
                             identifier(),
                             title(),
                             message(),
                             positiveOption(),
                             negativeOption() {
  }

  virtual ~Pendant_popupDialog_args() noexcept;
  PendantID p;
  std::string identifier;
  std::string title;
  std::string message;
  std::string positiveOption;
  std::string negativeOption;

  _Pendant_popupDialog_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  void __set_title(const std::string& val);

  void __set_message(const std::string& val);

  void __set_positiveOption(const std::string& val);

  void __set_negativeOption(const std::string& val);

  bool operator == (const Pendant_popupDialog_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    if (!(title == rhs.title))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(positiveOption == rhs.positiveOption))
      return false;
    if (!(negativeOption == rhs.negativeOption))
      return false;
    return true;
  }
  bool operator != (const Pendant_popupDialog_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_popupDialog_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_popupDialog_pargs {
 public:


  virtual ~Pendant_popupDialog_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;
  const std::string* title;
  const std::string* message;
  const std::string* positiveOption;
  const std::string* negativeOption;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_popupDialog_result__isset {
  _Pendant_popupDialog_result__isset() : e(false) {}
  bool e :1;
} _Pendant_popupDialog_result__isset;

class Pendant_popupDialog_result {
 public:

  Pendant_popupDialog_result(const Pendant_popupDialog_result&);
  Pendant_popupDialog_result& operator=(const Pendant_popupDialog_result&);
  Pendant_popupDialog_result() noexcept {
  }

  virtual ~Pendant_popupDialog_result() noexcept;
  IllegalArgument e;

  _Pendant_popupDialog_result__isset __isset;

  void __set_e(const IllegalArgument& val);

  bool operator == (const Pendant_popupDialog_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Pendant_popupDialog_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_popupDialog_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_popupDialog_presult__isset {
  _Pendant_popupDialog_presult__isset() : e(false) {}
  bool e :1;
} _Pendant_popupDialog_presult__isset;

class Pendant_popupDialog_presult {
 public:


  virtual ~Pendant_popupDialog_presult() noexcept;
  IllegalArgument e;

  _Pendant_popupDialog_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_cancelPopupDialog_args__isset {
  _Pendant_cancelPopupDialog_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_cancelPopupDialog_args__isset;

class Pendant_cancelPopupDialog_args {
 public:

  Pendant_cancelPopupDialog_args(const Pendant_cancelPopupDialog_args&);
  Pendant_cancelPopupDialog_args& operator=(const Pendant_cancelPopupDialog_args&);
  Pendant_cancelPopupDialog_args() noexcept
                                 : p(0),
                                   identifier() {
  }

  virtual ~Pendant_cancelPopupDialog_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_cancelPopupDialog_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_cancelPopupDialog_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_cancelPopupDialog_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_cancelPopupDialog_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_cancelPopupDialog_pargs {
 public:


  virtual ~Pendant_cancelPopupDialog_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_cancelPopupDialog_result {
 public:

  Pendant_cancelPopupDialog_result(const Pendant_cancelPopupDialog_result&) noexcept;
  Pendant_cancelPopupDialog_result& operator=(const Pendant_cancelPopupDialog_result&) noexcept;
  Pendant_cancelPopupDialog_result() noexcept {
  }

  virtual ~Pendant_cancelPopupDialog_result() noexcept;

  bool operator == (const Pendant_cancelPopupDialog_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_cancelPopupDialog_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_cancelPopupDialog_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_cancelPopupDialog_presult {
 public:


  virtual ~Pendant_cancelPopupDialog_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_insertInstructionAtSelectedLine_args__isset {
  _Pendant_insertInstructionAtSelectedLine_args__isset() : p(false), instruction(false) {}
  bool p :1;
  bool instruction :1;
} _Pendant_insertInstructionAtSelectedLine_args__isset;

class Pendant_insertInstructionAtSelectedLine_args {
 public:

  Pendant_insertInstructionAtSelectedLine_args(const Pendant_insertInstructionAtSelectedLine_args&);
  Pendant_insertInstructionAtSelectedLine_args& operator=(const Pendant_insertInstructionAtSelectedLine_args&);
  Pendant_insertInstructionAtSelectedLine_args() noexcept
                                               : p(0),
                                                 instruction() {
  }

  virtual ~Pendant_insertInstructionAtSelectedLine_args() noexcept;
  PendantID p;
  std::string instruction;

  _Pendant_insertInstructionAtSelectedLine_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_instruction(const std::string& val);

  bool operator == (const Pendant_insertInstructionAtSelectedLine_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(instruction == rhs.instruction))
      return false;
    return true;
  }
  bool operator != (const Pendant_insertInstructionAtSelectedLine_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_insertInstructionAtSelectedLine_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_insertInstructionAtSelectedLine_pargs {
 public:


  virtual ~Pendant_insertInstructionAtSelectedLine_pargs() noexcept;
  const PendantID* p;
  const std::string* instruction;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_insertInstructionAtSelectedLine_result__isset {
  _Pendant_insertInstructionAtSelectedLine_result__isset() : success(false) {}
  bool success :1;
} _Pendant_insertInstructionAtSelectedLine_result__isset;

class Pendant_insertInstructionAtSelectedLine_result {
 public:

  Pendant_insertInstructionAtSelectedLine_result(const Pendant_insertInstructionAtSelectedLine_result&);
  Pendant_insertInstructionAtSelectedLine_result& operator=(const Pendant_insertInstructionAtSelectedLine_result&);
  Pendant_insertInstructionAtSelectedLine_result() noexcept
                                                 : success() {
  }

  virtual ~Pendant_insertInstructionAtSelectedLine_result() noexcept;
  std::string success;

  _Pendant_insertInstructionAtSelectedLine_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Pendant_insertInstructionAtSelectedLine_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Pendant_insertInstructionAtSelectedLine_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_insertInstructionAtSelectedLine_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Pendant_insertInstructionAtSelectedLine_presult__isset {
  _Pendant_insertInstructionAtSelectedLine_presult__isset() : success(false) {}
  bool success :1;
} _Pendant_insertInstructionAtSelectedLine_presult__isset;

class Pendant_insertInstructionAtSelectedLine_presult {
 public:


  virtual ~Pendant_insertInstructionAtSelectedLine_presult() noexcept;
  std::string* success;

  _Pendant_insertInstructionAtSelectedLine_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Pendant_displayScreen_args__isset {
  _Pendant_displayScreen_args__isset() : p(false), identifier(false) {}
  bool p :1;
  bool identifier :1;
} _Pendant_displayScreen_args__isset;

class Pendant_displayScreen_args {
 public:

  Pendant_displayScreen_args(const Pendant_displayScreen_args&);
  Pendant_displayScreen_args& operator=(const Pendant_displayScreen_args&);
  Pendant_displayScreen_args() noexcept
                             : p(0),
                               identifier() {
  }

  virtual ~Pendant_displayScreen_args() noexcept;
  PendantID p;
  std::string identifier;

  _Pendant_displayScreen_args__isset __isset;

  void __set_p(const PendantID val);

  void __set_identifier(const std::string& val);

  bool operator == (const Pendant_displayScreen_args & rhs) const
  {
    if (!(p == rhs.p))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const Pendant_displayScreen_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_displayScreen_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_displayScreen_pargs {
 public:


  virtual ~Pendant_displayScreen_pargs() noexcept;
  const PendantID* p;
  const std::string* identifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_displayScreen_result {
 public:

  Pendant_displayScreen_result(const Pendant_displayScreen_result&) noexcept;
  Pendant_displayScreen_result& operator=(const Pendant_displayScreen_result&) noexcept;
  Pendant_displayScreen_result() noexcept {
  }

  virtual ~Pendant_displayScreen_result() noexcept;

  bool operator == (const Pendant_displayScreen_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Pendant_displayScreen_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pendant_displayScreen_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Pendant_displayScreen_presult {
 public:


  virtual ~Pendant_displayScreen_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class PendantClient : virtual public PendantIf {
 public:
  PendantClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  PendantClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Version of the Smart Pendant itself
   * (avoid using this for conditional feature use - use the Extension apiVersion() instead)
   * 
   * @param p
   */
  void pendantVersion(Version& _return, const PendantID p) override;
  void send_pendantVersion(const PendantID p);
  void recv_pendantVersion(Version& _return);
  /**
   * Subscribe to specified set of Pendant service events.  May be called multiple times to add to subscription.
   * 
   * @param p
   * @param types
   */
  void subscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) override;
  void send_subscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types);
  void recv_subscribeEventTypes();
  /**
   * Unsubscribe from specified set of Pendant service events.
   * 
   * @param p
   * @param types
   */
  void unsubscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) override;
  void send_unsubscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types);
  void recv_unsubscribeEventTypes();
  /**
   * Obtain list of Pendant service events that have occured since last call
   * 
   * @param p
   */
  void events(std::vector<PendantEvent> & _return, const PendantID p) override;
  void send_events(const PendantID p);
  void recv_events(std::vector<PendantEvent> & _return);
  /**
   * Query the current UI language of the pendant interface.
   * Returns IETF language codes (RFCs 5646, 5645, 4647) of languages
   * (typically ISO 693-1 code when region insignificant)
   * 
   * @param p
   */
  void currentLanguage(std::string& _return, const PendantID p) override;
  void send_currentLanguage(const PendantID p);
  void recv_currentLanguage(std::string& _return);
  void currentLocale(std::string& _return, const PendantID p) override;
  void send_currentLocale(const PendantID p);
  void recv_currentLocale(std::string& _return);
  /**
   * The UI screen currently shown to the pendant user
   * 
   * @param p
   */
  void currentScreenName(std::string& _return, const PendantID p) override;
  void send_currentScreenName(const PendantID p);
  void recv_currentScreenName(std::string& _return);
  /**
   * Register an Item type described using a YML source code string
   * Returns a list of parsing errors (0 on success)
   * 
   * @param p
   * @param ymlSource
   */
  void registerYML(std::vector<std::string> & _return, const PendantID p, const std::string& ymlSource) override;
  void send_registerYML(const PendantID p, const std::string& ymlSource);
  void recv_registerYML(std::vector<std::string> & _return);
  /**
   * Register an image file for later reference by filename (must be uniquely named, with .jpg or .png).
   * If file cannot be accessed by service, it will be locally read and registerImageData called instead.
   * 
   * @param p
   * @param imageFileName
   */
  void registerImageFile(const PendantID p, const std::string& imageFileName) override;
  void send_registerImageFile(const PendantID p, const std::string& imageFileName);
  void recv_registerImageFile();
  /**
   * Register an image for later reference by name (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param imageData
   * @param imageName
   */
  void registerImageData(const PendantID p, const std::string& imageData, const std::string& imageName) override;
  void send_registerImageData(const PendantID p, const std::string& imageData, const std::string& imageName);
  void recv_registerImageData();
  /**
   * Register a HTML file for later reference by filename (must be uniquely named, with .html).
   * If file cannot be accessed by service, it will be locally read and registerHTMLData called instead.
   * 
   * @param p
   * @param htmlFileName
   */
  void registerHTMLFile(const PendantID p, const std::string& htmlFileName) override;
  void send_registerHTMLFile(const PendantID p, const std::string& htmlFileName);
  void recv_registerHTMLFile();
  /**
   * Register HTML for later reference by name (must be uniquely named, with .html extension)
   * 
   * @param p
   * @param htmlData
   * @param htmlName
   */
  void registerHTMLData(const PendantID p, const std::string& htmlData, const std::string& htmlName) override;
  void send_registerHTMLData(const PendantID p, const std::string& htmlData, const std::string& htmlName);
  void recv_registerHTMLData();
  /**
   * Register a translation file (e.g. a Java properties file for a language); extension is used to determine format
   * 
   * @param p
   * @param locale
   * @param translationFileName
   */
  void registerTranslationFile(const PendantID p, const std::string& locale, const std::string& translationFileName) override;
  void send_registerTranslationFile(const PendantID p, const std::string& locale, const std::string& translationFileName);
  void recv_registerTranslationFile();
  /**
   * Register translation file data (translationName typically filename-like; extension is used to determine format)
   * 
   * @param p
   * @param locale
   * @param translationData
   * @param translationName
   */
  void registerTranslationData(const PendantID p, const std::string& locale, const std::string& translationData, const std::string& translationName) override;
  void send_registerTranslationData(const PendantID p, const std::string& locale, const std::string& translationData, const std::string& translationName);
  void recv_registerTranslationData();
  /**
   * Register a Utility window with the UI.
   * The itemType references a previously registered YML item instantiated for the window
   * UI content.
   * A main menu entry will automatically be added to the pendant UI, for opening the utility window.
   * 
   * @param p
   * @param identifier
   * @param itemType
   * @param menuItemName
   * @param windowTitle
   */
  void registerUtilityWindow(const PendantID p, const std::string& identifier, const std::string& itemType, const std::string& menuItemName, const std::string& windowTitle) override;
  void send_registerUtilityWindow(const PendantID p, const std::string& identifier, const std::string& itemType, const std::string& menuItemName, const std::string& windowTitle);
  void recv_registerUtilityWindow();
  void unregisterUtilityWindow(const PendantID p, const std::string& identifier) override;
  void send_unregisterUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_unregisterUtilityWindow();
  /**
   * Open (make visible) previously registered Utility Window
   * 
   * @param p
   * @param identifier
   */
  void openUtilityWindow(const PendantID p, const std::string& identifier) override;
  void send_openUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_openUtilityWindow();
  /**
   * Close a visible Utility Window (make invisible - state is maintained)
   * 
   * @param p
   * @param identifier
   */
  void closeUtilityWindow(const PendantID p, const std::string& identifier) override;
  void send_closeUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_closeUtilityWindow();
  /**
   * Collapse previously registered Utility Window, if in expanded state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void collapseUtilityWindow(const PendantID p, const std::string& identifier) override;
  void send_collapseUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_collapseUtilityWindow();
  /**
   * Expand previously registered Utility Window, if in collapsed state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void expandUtilityWindow(const PendantID p, const std::string& identifier) override;
  void send_expandUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_expandUtilityWindow();
  /**
   * Register UI content at the specified integration point in the pendant UI.
   * The itemType should reference a YML item previouslt registered via registerYML().
   * 
   * @param p
   * @param identifier
   * @param integrationPoint
   * @param itemType
   * @param buttonLabel
   * @param buttonImage
   */
  void registerIntegration(const PendantID p, const std::string& identifier, const IntegrationPoint::type integrationPoint, const std::string& itemType, const std::string& buttonLabel, const std::string& buttonImage) override;
  void send_registerIntegration(const PendantID p, const std::string& identifier, const IntegrationPoint::type integrationPoint, const std::string& itemType, const std::string& buttonLabel, const std::string& buttonImage);
  void recv_registerIntegration();
  void unregisterIntegration(const PendantID p, const std::string& identifier) override;
  void send_unregisterIntegration(const PendantID p, const std::string& identifier);
  void recv_unregisterIntegration();
  /**
   * get property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   */
  void property(Any& _return, const PendantID p, const std::string& itemID, const std::string& name) override;
  void send_property(const PendantID p, const std::string& itemID, const std::string& name);
  void recv_property(Any& _return);
  /**
   * Set property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   * @param value
   */
  void setProperty(const PendantID p, const std::string& itemID, const std::string& name, const Any& value) override;
  void send_setProperty(const PendantID p, const std::string& itemID, const std::string& name, const Any& value);
  void recv_setProperty();
  /**
   * Set several properties (potentially for different items) at once.  This is more
   * efficient that many repeated calls to setProperty().  Note it is async so no
   * errors/exceptions are thrown
   * 
   * @param p
   * @param propValuesList
   */
  void setProperties(const PendantID p, const std::vector<PropValues> & propValuesList) override;
  void send_setProperties(const PendantID p, const std::vector<PropValues> & propValuesList);
  /**
   * Set the configuration of a chart by ID.
   * 
   * @param p
   * @param chartID
   * @param config
   */
  void setChartConfig(const PendantID p, const std::string& chartID, const Any& config) override;
  void send_setChartConfig(const PendantID p, const std::string& chartID, const Any& config);
  void recv_setChartConfig();
  /**
   * Get the configuration of a chart by ID
   * 
   * @param p
   * @param chartID
   */
  void getChartConfig(Any& _return, const PendantID p, const std::string& chartID) override;
  void send_getChartConfig(const PendantID p, const std::string& chartID);
  void recv_getChartConfig(Any& _return);
  /**
   * Set the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param dataset
   * @param right
   */
  void setChartData(const PendantID p, const std::string& chartID, const DataSet& dataset, const bool right) override;
  void send_setChartData(const PendantID p, const std::string& chartID, const DataSet& dataset, const bool right);
  void recv_setChartData();
  /**
   * Get the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to access the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param right
   */
  void getChartData(DataSet& _return, const PendantID p, const std::string& chartID, const bool right) override;
  void send_getChartData(const PendantID p, const std::string& chartID, const bool right);
  void recv_getChartData(DataSet& _return);
  /**
   * Add a new key to the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param data
   * @param right
   */
  void addChartKey(const PendantID p, const std::string& chartID, const std::string& key, const Data& data, const bool right) override;
  void send_addChartKey(const PendantID p, const std::string& chartID, const std::string& key, const Data& data, const bool right);
  void recv_addChartKey();
  /**
   * Removes an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to remove from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param right
   */
  void removeChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool right) override;
  void send_removeChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool right);
  void recv_removeChartKey();
  /**
   * Hides an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to hide a key from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param hidden
   * @param right
   */
  void hideChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool hidden, const bool right) override;
  void send_hideChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool hidden, const bool right);
  void recv_hideChartKey();
  /**
   * Append new data points to a specified key in the data of a chart by ID.
   * This function will only have an effect on line/scatter charts. Set
   * 'right' to true to pass the dataset for a secondary scale on the right
   * hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param points
   * @param right
   */
  void appendChartPoints(const PendantID p, const std::string& chartID, const std::string& key, const std::vector<DataPoint> & points, const bool right) override;
  void send_appendChartPoints(const PendantID p, const std::string& chartID, const std::string& key, const std::vector<DataPoint> & points, const bool right);
  /**
   * Increments a category value by `val`.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param val
   */
  void incrementChartKey(const PendantID p, const std::string& chartID, const std::string& key, const double val) override;
  void send_incrementChartKey(const PendantID p, const std::string& chartID, const std::string& key, const double val);
  void recv_incrementChartKey();
  /**
   * Export the current chart contents to the specified filename (must be uniquely named, with .jpg or .png).
   * Calls exportChartImageData if the extension is unable to access the file.
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImage(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) override;
  void send_exportChartImage(const PendantID p, const std::string& chartID, const std::string& imageFileName);
  void recv_exportChartImage(std::string& _return);
  /**
   * Export the current chart contents to a binary blob (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImageData(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) override;
  void send_exportChartImageData(const PendantID p, const std::string& chartID, const std::string& imageFileName);
  void recv_exportChartImageData(std::string& _return);
  /**
   * Show notice to user.
   * Notices are automaticlly hidden after a short display period.
   * Notice messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void notice(const PendantID p, const std::string& title, const std::string& message, const std::string& log) override;
  void send_notice(const PendantID p, const std::string& title, const std::string& message, const std::string& log);
  /**
   * Show notice to user with specified disposition.
   * As for notice() but displayed in a way that connotes the specified disposition.
   * For example, a Positive disposition may be shown in green.
   * (API version 2.1 and later)
   * 
   * @param p
   * @param disposition
   * @param title
   * @param message
   * @param log
   */
  void dispNotice(const PendantID p, const Disposition::type disposition, const std::string& title, const std::string& message, const std::string& log) override;
  void send_dispNotice(const PendantID p, const Disposition::type disposition, const std::string& title, const std::string& message, const std::string& log);
  /**
   * Show error to user.
   * Errors should only indicate important situations that the user must be aware of and for which deliberate
   * acknowledgement is required before proceeding.  Typically, some action will be required to correct the situation.
   * Errors are displayed until dismissed by the user.
   * Error messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void error(const PendantID p, const std::string& title, const std::string& message, const std::string& log) override;
  void send_error(const PendantID p, const std::string& title, const std::string& message, const std::string& log);
  /**
   * Display modal pop-up dialog.  Typically, Yes/No, although negativeOption can be omitted
   * The identifier can be used to associate the corresponding PopupOpened & PopupClosed events triggered by
   * user positive/negative selection or automatic dismissal/cancellation - for example is screen switched, alarm etc.
   * 
   * @param p
   * @param identifier
   * @param title
   * @param message
   * @param positiveOption
   * @param negativeOption
   */
  void popupDialog(const PendantID p, const std::string& identifier, const std::string& title, const std::string& message, const std::string& positiveOption, const std::string& negativeOption) override;
  void send_popupDialog(const PendantID p, const std::string& identifier, const std::string& title, const std::string& message, const std::string& positiveOption, const std::string& negativeOption);
  void recv_popupDialog();
  /**
   * Cancel an open popup dialog.  If the dialog has a negative option, behaves as if user selected it, otherwise
   * no event is generated
   * 
   * @param p
   * @param identifier
   */
  void cancelPopupDialog(const PendantID p, const std::string& identifier) override;
  void send_cancelPopupDialog(const PendantID p, const std::string& identifier);
  void recv_cancelPopupDialog();
  /**
   * Inserts an instruction, returns a string:
   * Success,
   * UnsupportedCommand,
   * InvalidFormat,
   * ProgrammingViewClosed,
   * JobDoesNotExist,
   * CallingJobFromSameJob,
   * ExceededMaxArguments,
   * JobNotEditable,
   * MultiSelectActive,
   * TimedOut,
   * Unknown
   * 
   * @param p
   * @param instruction
   */
  void insertInstructionAtSelectedLine(std::string& _return, const PendantID p, const std::string& instruction) override;
  void send_insertInstructionAtSelectedLine(const PendantID p, const std::string& instruction);
  void recv_insertInstructionAtSelectedLine(std::string& _return);
  /**
   * Displays a standard pendant UI screen by passing a string with the screen identifier. (Only available from SDK API 2.2 onward)
   * Refer to the YML - URI Links documentation for the list of supported screens and settings.
   * Do not include the URI "&lt;a href&gt; screen:" portion in the identifier.  For example to display the jogging panel use:
   * pendant.displayScreen("programmingView?panel=jogging");
   * 
   * @param p
   * @param identifier
   */
  void displayScreen(const PendantID p, const std::string& identifier) override;
  void send_displayScreen(const PendantID p, const std::string& identifier);
  void recv_displayScreen();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class PendantProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<PendantIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) override;
 private:
  typedef  void (PendantProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_pendantVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_subscribeEventTypes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unsubscribeEventTypes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_events(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_currentLanguage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_currentLocale(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_currentScreenName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerYML(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerImageFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerImageData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerHTMLFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerHTMLData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerTranslationFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerTranslationData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerUtilityWindow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unregisterUtilityWindow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_openUtilityWindow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeUtilityWindow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_collapseUtilityWindow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_expandUtilityWindow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_registerIntegration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unregisterIntegration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_property(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setProperties(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setChartConfig(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getChartConfig(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setChartData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getChartData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addChartKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeChartKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hideChartKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_appendChartPoints(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_incrementChartKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exportChartImage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exportChartImageData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_notice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_dispNotice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_error(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_popupDialog(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cancelPopupDialog(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_insertInstructionAtSelectedLine(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_displayScreen(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  PendantProcessor(::std::shared_ptr<PendantIf> iface) :
    iface_(iface) {
    processMap_["pendantVersion"] = &PendantProcessor::process_pendantVersion;
    processMap_["subscribeEventTypes"] = &PendantProcessor::process_subscribeEventTypes;
    processMap_["unsubscribeEventTypes"] = &PendantProcessor::process_unsubscribeEventTypes;
    processMap_["events"] = &PendantProcessor::process_events;
    processMap_["currentLanguage"] = &PendantProcessor::process_currentLanguage;
    processMap_["currentLocale"] = &PendantProcessor::process_currentLocale;
    processMap_["currentScreenName"] = &PendantProcessor::process_currentScreenName;
    processMap_["registerYML"] = &PendantProcessor::process_registerYML;
    processMap_["registerImageFile"] = &PendantProcessor::process_registerImageFile;
    processMap_["registerImageData"] = &PendantProcessor::process_registerImageData;
    processMap_["registerHTMLFile"] = &PendantProcessor::process_registerHTMLFile;
    processMap_["registerHTMLData"] = &PendantProcessor::process_registerHTMLData;
    processMap_["registerTranslationFile"] = &PendantProcessor::process_registerTranslationFile;
    processMap_["registerTranslationData"] = &PendantProcessor::process_registerTranslationData;
    processMap_["registerUtilityWindow"] = &PendantProcessor::process_registerUtilityWindow;
    processMap_["unregisterUtilityWindow"] = &PendantProcessor::process_unregisterUtilityWindow;
    processMap_["openUtilityWindow"] = &PendantProcessor::process_openUtilityWindow;
    processMap_["closeUtilityWindow"] = &PendantProcessor::process_closeUtilityWindow;
    processMap_["collapseUtilityWindow"] = &PendantProcessor::process_collapseUtilityWindow;
    processMap_["expandUtilityWindow"] = &PendantProcessor::process_expandUtilityWindow;
    processMap_["registerIntegration"] = &PendantProcessor::process_registerIntegration;
    processMap_["unregisterIntegration"] = &PendantProcessor::process_unregisterIntegration;
    processMap_["property"] = &PendantProcessor::process_property;
    processMap_["setProperty"] = &PendantProcessor::process_setProperty;
    processMap_["setProperties"] = &PendantProcessor::process_setProperties;
    processMap_["setChartConfig"] = &PendantProcessor::process_setChartConfig;
    processMap_["getChartConfig"] = &PendantProcessor::process_getChartConfig;
    processMap_["setChartData"] = &PendantProcessor::process_setChartData;
    processMap_["getChartData"] = &PendantProcessor::process_getChartData;
    processMap_["addChartKey"] = &PendantProcessor::process_addChartKey;
    processMap_["removeChartKey"] = &PendantProcessor::process_removeChartKey;
    processMap_["hideChartKey"] = &PendantProcessor::process_hideChartKey;
    processMap_["appendChartPoints"] = &PendantProcessor::process_appendChartPoints;
    processMap_["incrementChartKey"] = &PendantProcessor::process_incrementChartKey;
    processMap_["exportChartImage"] = &PendantProcessor::process_exportChartImage;
    processMap_["exportChartImageData"] = &PendantProcessor::process_exportChartImageData;
    processMap_["notice"] = &PendantProcessor::process_notice;
    processMap_["dispNotice"] = &PendantProcessor::process_dispNotice;
    processMap_["error"] = &PendantProcessor::process_error;
    processMap_["popupDialog"] = &PendantProcessor::process_popupDialog;
    processMap_["cancelPopupDialog"] = &PendantProcessor::process_cancelPopupDialog;
    processMap_["insertInstructionAtSelectedLine"] = &PendantProcessor::process_insertInstructionAtSelectedLine;
    processMap_["displayScreen"] = &PendantProcessor::process_displayScreen;
  }

  virtual ~PendantProcessor() {}
};

class PendantProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  PendantProcessorFactory(const ::std::shared_ptr< PendantIfFactory >& handlerFactory) noexcept :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) override;

 protected:
  ::std::shared_ptr< PendantIfFactory > handlerFactory_;
};

class PendantMultiface : virtual public PendantIf {
 public:
  PendantMultiface(std::vector<std::shared_ptr<PendantIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~PendantMultiface() {}
 protected:
  std::vector<std::shared_ptr<PendantIf> > ifaces_;
  PendantMultiface() {}
  void add(::std::shared_ptr<PendantIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  /**
   * Version of the Smart Pendant itself
   * (avoid using this for conditional feature use - use the Extension apiVersion() instead)
   * 
   * @param p
   */
  void pendantVersion(Version& _return, const PendantID p) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pendantVersion(_return, p);
    }
    ifaces_[i]->pendantVersion(_return, p);
    return;
  }

  /**
   * Subscribe to specified set of Pendant service events.  May be called multiple times to add to subscription.
   * 
   * @param p
   * @param types
   */
  void subscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->subscribeEventTypes(p, types);
    }
    ifaces_[i]->subscribeEventTypes(p, types);
  }

  /**
   * Unsubscribe from specified set of Pendant service events.
   * 
   * @param p
   * @param types
   */
  void unsubscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unsubscribeEventTypes(p, types);
    }
    ifaces_[i]->unsubscribeEventTypes(p, types);
  }

  /**
   * Obtain list of Pendant service events that have occured since last call
   * 
   * @param p
   */
  void events(std::vector<PendantEvent> & _return, const PendantID p) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->events(_return, p);
    }
    ifaces_[i]->events(_return, p);
    return;
  }

  /**
   * Query the current UI language of the pendant interface.
   * Returns IETF language codes (RFCs 5646, 5645, 4647) of languages
   * (typically ISO 693-1 code when region insignificant)
   * 
   * @param p
   */
  void currentLanguage(std::string& _return, const PendantID p) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->currentLanguage(_return, p);
    }
    ifaces_[i]->currentLanguage(_return, p);
    return;
  }

  void currentLocale(std::string& _return, const PendantID p) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->currentLocale(_return, p);
    }
    ifaces_[i]->currentLocale(_return, p);
    return;
  }

  /**
   * The UI screen currently shown to the pendant user
   * 
   * @param p
   */
  void currentScreenName(std::string& _return, const PendantID p) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->currentScreenName(_return, p);
    }
    ifaces_[i]->currentScreenName(_return, p);
    return;
  }

  /**
   * Register an Item type described using a YML source code string
   * Returns a list of parsing errors (0 on success)
   * 
   * @param p
   * @param ymlSource
   */
  void registerYML(std::vector<std::string> & _return, const PendantID p, const std::string& ymlSource) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerYML(_return, p, ymlSource);
    }
    ifaces_[i]->registerYML(_return, p, ymlSource);
    return;
  }

  /**
   * Register an image file for later reference by filename (must be uniquely named, with .jpg or .png).
   * If file cannot be accessed by service, it will be locally read and registerImageData called instead.
   * 
   * @param p
   * @param imageFileName
   */
  void registerImageFile(const PendantID p, const std::string& imageFileName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerImageFile(p, imageFileName);
    }
    ifaces_[i]->registerImageFile(p, imageFileName);
  }

  /**
   * Register an image for later reference by name (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param imageData
   * @param imageName
   */
  void registerImageData(const PendantID p, const std::string& imageData, const std::string& imageName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerImageData(p, imageData, imageName);
    }
    ifaces_[i]->registerImageData(p, imageData, imageName);
  }

  /**
   * Register a HTML file for later reference by filename (must be uniquely named, with .html).
   * If file cannot be accessed by service, it will be locally read and registerHTMLData called instead.
   * 
   * @param p
   * @param htmlFileName
   */
  void registerHTMLFile(const PendantID p, const std::string& htmlFileName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerHTMLFile(p, htmlFileName);
    }
    ifaces_[i]->registerHTMLFile(p, htmlFileName);
  }

  /**
   * Register HTML for later reference by name (must be uniquely named, with .html extension)
   * 
   * @param p
   * @param htmlData
   * @param htmlName
   */
  void registerHTMLData(const PendantID p, const std::string& htmlData, const std::string& htmlName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerHTMLData(p, htmlData, htmlName);
    }
    ifaces_[i]->registerHTMLData(p, htmlData, htmlName);
  }

  /**
   * Register a translation file (e.g. a Java properties file for a language); extension is used to determine format
   * 
   * @param p
   * @param locale
   * @param translationFileName
   */
  void registerTranslationFile(const PendantID p, const std::string& locale, const std::string& translationFileName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerTranslationFile(p, locale, translationFileName);
    }
    ifaces_[i]->registerTranslationFile(p, locale, translationFileName);
  }

  /**
   * Register translation file data (translationName typically filename-like; extension is used to determine format)
   * 
   * @param p
   * @param locale
   * @param translationData
   * @param translationName
   */
  void registerTranslationData(const PendantID p, const std::string& locale, const std::string& translationData, const std::string& translationName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerTranslationData(p, locale, translationData, translationName);
    }
    ifaces_[i]->registerTranslationData(p, locale, translationData, translationName);
  }

  /**
   * Register a Utility window with the UI.
   * The itemType references a previously registered YML item instantiated for the window
   * UI content.
   * A main menu entry will automatically be added to the pendant UI, for opening the utility window.
   * 
   * @param p
   * @param identifier
   * @param itemType
   * @param menuItemName
   * @param windowTitle
   */
  void registerUtilityWindow(const PendantID p, const std::string& identifier, const std::string& itemType, const std::string& menuItemName, const std::string& windowTitle) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerUtilityWindow(p, identifier, itemType, menuItemName, windowTitle);
    }
    ifaces_[i]->registerUtilityWindow(p, identifier, itemType, menuItemName, windowTitle);
  }

  void unregisterUtilityWindow(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unregisterUtilityWindow(p, identifier);
    }
    ifaces_[i]->unregisterUtilityWindow(p, identifier);
  }

  /**
   * Open (make visible) previously registered Utility Window
   * 
   * @param p
   * @param identifier
   */
  void openUtilityWindow(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->openUtilityWindow(p, identifier);
    }
    ifaces_[i]->openUtilityWindow(p, identifier);
  }

  /**
   * Close a visible Utility Window (make invisible - state is maintained)
   * 
   * @param p
   * @param identifier
   */
  void closeUtilityWindow(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeUtilityWindow(p, identifier);
    }
    ifaces_[i]->closeUtilityWindow(p, identifier);
  }

  /**
   * Collapse previously registered Utility Window, if in expanded state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void collapseUtilityWindow(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->collapseUtilityWindow(p, identifier);
    }
    ifaces_[i]->collapseUtilityWindow(p, identifier);
  }

  /**
   * Expand previously registered Utility Window, if in collapsed state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void expandUtilityWindow(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->expandUtilityWindow(p, identifier);
    }
    ifaces_[i]->expandUtilityWindow(p, identifier);
  }

  /**
   * Register UI content at the specified integration point in the pendant UI.
   * The itemType should reference a YML item previouslt registered via registerYML().
   * 
   * @param p
   * @param identifier
   * @param integrationPoint
   * @param itemType
   * @param buttonLabel
   * @param buttonImage
   */
  void registerIntegration(const PendantID p, const std::string& identifier, const IntegrationPoint::type integrationPoint, const std::string& itemType, const std::string& buttonLabel, const std::string& buttonImage) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->registerIntegration(p, identifier, integrationPoint, itemType, buttonLabel, buttonImage);
    }
    ifaces_[i]->registerIntegration(p, identifier, integrationPoint, itemType, buttonLabel, buttonImage);
  }

  void unregisterIntegration(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unregisterIntegration(p, identifier);
    }
    ifaces_[i]->unregisterIntegration(p, identifier);
  }

  /**
   * get property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   */
  void property(Any& _return, const PendantID p, const std::string& itemID, const std::string& name) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->property(_return, p, itemID, name);
    }
    ifaces_[i]->property(_return, p, itemID, name);
    return;
  }

  /**
   * Set property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   * @param value
   */
  void setProperty(const PendantID p, const std::string& itemID, const std::string& name, const Any& value) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setProperty(p, itemID, name, value);
    }
    ifaces_[i]->setProperty(p, itemID, name, value);
  }

  /**
   * Set several properties (potentially for different items) at once.  This is more
   * efficient that many repeated calls to setProperty().  Note it is async so no
   * errors/exceptions are thrown
   * 
   * @param p
   * @param propValuesList
   */
  void setProperties(const PendantID p, const std::vector<PropValues> & propValuesList) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setProperties(p, propValuesList);
    }
    ifaces_[i]->setProperties(p, propValuesList);
  }

  /**
   * Set the configuration of a chart by ID.
   * 
   * @param p
   * @param chartID
   * @param config
   */
  void setChartConfig(const PendantID p, const std::string& chartID, const Any& config) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setChartConfig(p, chartID, config);
    }
    ifaces_[i]->setChartConfig(p, chartID, config);
  }

  /**
   * Get the configuration of a chart by ID
   * 
   * @param p
   * @param chartID
   */
  void getChartConfig(Any& _return, const PendantID p, const std::string& chartID) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getChartConfig(_return, p, chartID);
    }
    ifaces_[i]->getChartConfig(_return, p, chartID);
    return;
  }

  /**
   * Set the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param dataset
   * @param right
   */
  void setChartData(const PendantID p, const std::string& chartID, const DataSet& dataset, const bool right) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setChartData(p, chartID, dataset, right);
    }
    ifaces_[i]->setChartData(p, chartID, dataset, right);
  }

  /**
   * Get the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to access the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param right
   */
  void getChartData(DataSet& _return, const PendantID p, const std::string& chartID, const bool right) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getChartData(_return, p, chartID, right);
    }
    ifaces_[i]->getChartData(_return, p, chartID, right);
    return;
  }

  /**
   * Add a new key to the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param data
   * @param right
   */
  void addChartKey(const PendantID p, const std::string& chartID, const std::string& key, const Data& data, const bool right) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->addChartKey(p, chartID, key, data, right);
    }
    ifaces_[i]->addChartKey(p, chartID, key, data, right);
  }

  /**
   * Removes an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to remove from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param right
   */
  void removeChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool right) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeChartKey(p, chartID, key, right);
    }
    ifaces_[i]->removeChartKey(p, chartID, key, right);
  }

  /**
   * Hides an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to hide a key from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param hidden
   * @param right
   */
  void hideChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool hidden, const bool right) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hideChartKey(p, chartID, key, hidden, right);
    }
    ifaces_[i]->hideChartKey(p, chartID, key, hidden, right);
  }

  /**
   * Append new data points to a specified key in the data of a chart by ID.
   * This function will only have an effect on line/scatter charts. Set
   * 'right' to true to pass the dataset for a secondary scale on the right
   * hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param points
   * @param right
   */
  void appendChartPoints(const PendantID p, const std::string& chartID, const std::string& key, const std::vector<DataPoint> & points, const bool right) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->appendChartPoints(p, chartID, key, points, right);
    }
    ifaces_[i]->appendChartPoints(p, chartID, key, points, right);
  }

  /**
   * Increments a category value by `val`.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param val
   */
  void incrementChartKey(const PendantID p, const std::string& chartID, const std::string& key, const double val) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->incrementChartKey(p, chartID, key, val);
    }
    ifaces_[i]->incrementChartKey(p, chartID, key, val);
  }

  /**
   * Export the current chart contents to the specified filename (must be uniquely named, with .jpg or .png).
   * Calls exportChartImageData if the extension is unable to access the file.
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImage(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exportChartImage(_return, p, chartID, imageFileName);
    }
    ifaces_[i]->exportChartImage(_return, p, chartID, imageFileName);
    return;
  }

  /**
   * Export the current chart contents to a binary blob (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImageData(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exportChartImageData(_return, p, chartID, imageFileName);
    }
    ifaces_[i]->exportChartImageData(_return, p, chartID, imageFileName);
    return;
  }

  /**
   * Show notice to user.
   * Notices are automaticlly hidden after a short display period.
   * Notice messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void notice(const PendantID p, const std::string& title, const std::string& message, const std::string& log) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->notice(p, title, message, log);
    }
    ifaces_[i]->notice(p, title, message, log);
  }

  /**
   * Show notice to user with specified disposition.
   * As for notice() but displayed in a way that connotes the specified disposition.
   * For example, a Positive disposition may be shown in green.
   * (API version 2.1 and later)
   * 
   * @param p
   * @param disposition
   * @param title
   * @param message
   * @param log
   */
  void dispNotice(const PendantID p, const Disposition::type disposition, const std::string& title, const std::string& message, const std::string& log) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->dispNotice(p, disposition, title, message, log);
    }
    ifaces_[i]->dispNotice(p, disposition, title, message, log);
  }

  /**
   * Show error to user.
   * Errors should only indicate important situations that the user must be aware of and for which deliberate
   * acknowledgement is required before proceeding.  Typically, some action will be required to correct the situation.
   * Errors are displayed until dismissed by the user.
   * Error messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void error(const PendantID p, const std::string& title, const std::string& message, const std::string& log) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->error(p, title, message, log);
    }
    ifaces_[i]->error(p, title, message, log);
  }

  /**
   * Display modal pop-up dialog.  Typically, Yes/No, although negativeOption can be omitted
   * The identifier can be used to associate the corresponding PopupOpened & PopupClosed events triggered by
   * user positive/negative selection or automatic dismissal/cancellation - for example is screen switched, alarm etc.
   * 
   * @param p
   * @param identifier
   * @param title
   * @param message
   * @param positiveOption
   * @param negativeOption
   */
  void popupDialog(const PendantID p, const std::string& identifier, const std::string& title, const std::string& message, const std::string& positiveOption, const std::string& negativeOption) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->popupDialog(p, identifier, title, message, positiveOption, negativeOption);
    }
    ifaces_[i]->popupDialog(p, identifier, title, message, positiveOption, negativeOption);
  }

  /**
   * Cancel an open popup dialog.  If the dialog has a negative option, behaves as if user selected it, otherwise
   * no event is generated
   * 
   * @param p
   * @param identifier
   */
  void cancelPopupDialog(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cancelPopupDialog(p, identifier);
    }
    ifaces_[i]->cancelPopupDialog(p, identifier);
  }

  /**
   * Inserts an instruction, returns a string:
   * Success,
   * UnsupportedCommand,
   * InvalidFormat,
   * ProgrammingViewClosed,
   * JobDoesNotExist,
   * CallingJobFromSameJob,
   * ExceededMaxArguments,
   * JobNotEditable,
   * MultiSelectActive,
   * TimedOut,
   * Unknown
   * 
   * @param p
   * @param instruction
   */
  void insertInstructionAtSelectedLine(std::string& _return, const PendantID p, const std::string& instruction) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->insertInstructionAtSelectedLine(_return, p, instruction);
    }
    ifaces_[i]->insertInstructionAtSelectedLine(_return, p, instruction);
    return;
  }

  /**
   * Displays a standard pendant UI screen by passing a string with the screen identifier. (Only available from SDK API 2.2 onward)
   * Refer to the YML - URI Links documentation for the list of supported screens and settings.
   * Do not include the URI "&lt;a href&gt; screen:" portion in the identifier.  For example to display the jogging panel use:
   * pendant.displayScreen("programmingView?panel=jogging");
   * 
   * @param p
   * @param identifier
   */
  void displayScreen(const PendantID p, const std::string& identifier) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->displayScreen(p, identifier);
    }
    ifaces_[i]->displayScreen(p, identifier);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class PendantConcurrentClient : virtual public PendantIf {
 public:
  PendantConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  PendantConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Version of the Smart Pendant itself
   * (avoid using this for conditional feature use - use the Extension apiVersion() instead)
   * 
   * @param p
   */
  void pendantVersion(Version& _return, const PendantID p) override;
  int32_t send_pendantVersion(const PendantID p);
  void recv_pendantVersion(Version& _return, const int32_t seqid);
  /**
   * Subscribe to specified set of Pendant service events.  May be called multiple times to add to subscription.
   * 
   * @param p
   * @param types
   */
  void subscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) override;
  int32_t send_subscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types);
  void recv_subscribeEventTypes(const int32_t seqid);
  /**
   * Unsubscribe from specified set of Pendant service events.
   * 
   * @param p
   * @param types
   */
  void unsubscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types) override;
  int32_t send_unsubscribeEventTypes(const PendantID p, const std::set<PendantEventType::type> & types);
  void recv_unsubscribeEventTypes(const int32_t seqid);
  /**
   * Obtain list of Pendant service events that have occured since last call
   * 
   * @param p
   */
  void events(std::vector<PendantEvent> & _return, const PendantID p) override;
  int32_t send_events(const PendantID p);
  void recv_events(std::vector<PendantEvent> & _return, const int32_t seqid);
  /**
   * Query the current UI language of the pendant interface.
   * Returns IETF language codes (RFCs 5646, 5645, 4647) of languages
   * (typically ISO 693-1 code when region insignificant)
   * 
   * @param p
   */
  void currentLanguage(std::string& _return, const PendantID p) override;
  int32_t send_currentLanguage(const PendantID p);
  void recv_currentLanguage(std::string& _return, const int32_t seqid);
  void currentLocale(std::string& _return, const PendantID p) override;
  int32_t send_currentLocale(const PendantID p);
  void recv_currentLocale(std::string& _return, const int32_t seqid);
  /**
   * The UI screen currently shown to the pendant user
   * 
   * @param p
   */
  void currentScreenName(std::string& _return, const PendantID p) override;
  int32_t send_currentScreenName(const PendantID p);
  void recv_currentScreenName(std::string& _return, const int32_t seqid);
  /**
   * Register an Item type described using a YML source code string
   * Returns a list of parsing errors (0 on success)
   * 
   * @param p
   * @param ymlSource
   */
  void registerYML(std::vector<std::string> & _return, const PendantID p, const std::string& ymlSource) override;
  int32_t send_registerYML(const PendantID p, const std::string& ymlSource);
  void recv_registerYML(std::vector<std::string> & _return, const int32_t seqid);
  /**
   * Register an image file for later reference by filename (must be uniquely named, with .jpg or .png).
   * If file cannot be accessed by service, it will be locally read and registerImageData called instead.
   * 
   * @param p
   * @param imageFileName
   */
  void registerImageFile(const PendantID p, const std::string& imageFileName) override;
  int32_t send_registerImageFile(const PendantID p, const std::string& imageFileName);
  void recv_registerImageFile(const int32_t seqid);
  /**
   * Register an image for later reference by name (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param imageData
   * @param imageName
   */
  void registerImageData(const PendantID p, const std::string& imageData, const std::string& imageName) override;
  int32_t send_registerImageData(const PendantID p, const std::string& imageData, const std::string& imageName);
  void recv_registerImageData(const int32_t seqid);
  /**
   * Register a HTML file for later reference by filename (must be uniquely named, with .html).
   * If file cannot be accessed by service, it will be locally read and registerHTMLData called instead.
   * 
   * @param p
   * @param htmlFileName
   */
  void registerHTMLFile(const PendantID p, const std::string& htmlFileName) override;
  int32_t send_registerHTMLFile(const PendantID p, const std::string& htmlFileName);
  void recv_registerHTMLFile(const int32_t seqid);
  /**
   * Register HTML for later reference by name (must be uniquely named, with .html extension)
   * 
   * @param p
   * @param htmlData
   * @param htmlName
   */
  void registerHTMLData(const PendantID p, const std::string& htmlData, const std::string& htmlName) override;
  int32_t send_registerHTMLData(const PendantID p, const std::string& htmlData, const std::string& htmlName);
  void recv_registerHTMLData(const int32_t seqid);
  /**
   * Register a translation file (e.g. a Java properties file for a language); extension is used to determine format
   * 
   * @param p
   * @param locale
   * @param translationFileName
   */
  void registerTranslationFile(const PendantID p, const std::string& locale, const std::string& translationFileName) override;
  int32_t send_registerTranslationFile(const PendantID p, const std::string& locale, const std::string& translationFileName);
  void recv_registerTranslationFile(const int32_t seqid);
  /**
   * Register translation file data (translationName typically filename-like; extension is used to determine format)
   * 
   * @param p
   * @param locale
   * @param translationData
   * @param translationName
   */
  void registerTranslationData(const PendantID p, const std::string& locale, const std::string& translationData, const std::string& translationName) override;
  int32_t send_registerTranslationData(const PendantID p, const std::string& locale, const std::string& translationData, const std::string& translationName);
  void recv_registerTranslationData(const int32_t seqid);
  /**
   * Register a Utility window with the UI.
   * The itemType references a previously registered YML item instantiated for the window
   * UI content.
   * A main menu entry will automatically be added to the pendant UI, for opening the utility window.
   * 
   * @param p
   * @param identifier
   * @param itemType
   * @param menuItemName
   * @param windowTitle
   */
  void registerUtilityWindow(const PendantID p, const std::string& identifier, const std::string& itemType, const std::string& menuItemName, const std::string& windowTitle) override;
  int32_t send_registerUtilityWindow(const PendantID p, const std::string& identifier, const std::string& itemType, const std::string& menuItemName, const std::string& windowTitle);
  void recv_registerUtilityWindow(const int32_t seqid);
  void unregisterUtilityWindow(const PendantID p, const std::string& identifier) override;
  int32_t send_unregisterUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_unregisterUtilityWindow(const int32_t seqid);
  /**
   * Open (make visible) previously registered Utility Window
   * 
   * @param p
   * @param identifier
   */
  void openUtilityWindow(const PendantID p, const std::string& identifier) override;
  int32_t send_openUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_openUtilityWindow(const int32_t seqid);
  /**
   * Close a visible Utility Window (make invisible - state is maintained)
   * 
   * @param p
   * @param identifier
   */
  void closeUtilityWindow(const PendantID p, const std::string& identifier) override;
  int32_t send_closeUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_closeUtilityWindow(const int32_t seqid);
  /**
   * Collapse previously registered Utility Window, if in expanded state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void collapseUtilityWindow(const PendantID p, const std::string& identifier) override;
  int32_t send_collapseUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_collapseUtilityWindow(const int32_t seqid);
  /**
   * Expand previously registered Utility Window, if in collapsed state (and expandCollapseResize true)
   * 
   * @param p
   * @param identifier
   */
  void expandUtilityWindow(const PendantID p, const std::string& identifier) override;
  int32_t send_expandUtilityWindow(const PendantID p, const std::string& identifier);
  void recv_expandUtilityWindow(const int32_t seqid);
  /**
   * Register UI content at the specified integration point in the pendant UI.
   * The itemType should reference a YML item previouslt registered via registerYML().
   * 
   * @param p
   * @param identifier
   * @param integrationPoint
   * @param itemType
   * @param buttonLabel
   * @param buttonImage
   */
  void registerIntegration(const PendantID p, const std::string& identifier, const IntegrationPoint::type integrationPoint, const std::string& itemType, const std::string& buttonLabel, const std::string& buttonImage) override;
  int32_t send_registerIntegration(const PendantID p, const std::string& identifier, const IntegrationPoint::type integrationPoint, const std::string& itemType, const std::string& buttonLabel, const std::string& buttonImage);
  void recv_registerIntegration(const int32_t seqid);
  void unregisterIntegration(const PendantID p, const std::string& identifier) override;
  int32_t send_unregisterIntegration(const PendantID p, const std::string& identifier);
  void recv_unregisterIntegration(const int32_t seqid);
  /**
   * get property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   */
  void property(Any& _return, const PendantID p, const std::string& itemID, const std::string& name) override;
  int32_t send_property(const PendantID p, const std::string& itemID, const std::string& name);
  void recv_property(Any& _return, const int32_t seqid);
  /**
   * Set property of an item by id
   * 
   * @param p
   * @param itemID
   * @param name
   * @param value
   */
  void setProperty(const PendantID p, const std::string& itemID, const std::string& name, const Any& value) override;
  int32_t send_setProperty(const PendantID p, const std::string& itemID, const std::string& name, const Any& value);
  void recv_setProperty(const int32_t seqid);
  /**
   * Set several properties (potentially for different items) at once.  This is more
   * efficient that many repeated calls to setProperty().  Note it is async so no
   * errors/exceptions are thrown
   * 
   * @param p
   * @param propValuesList
   */
  void setProperties(const PendantID p, const std::vector<PropValues> & propValuesList) override;
  void send_setProperties(const PendantID p, const std::vector<PropValues> & propValuesList);
  /**
   * Set the configuration of a chart by ID.
   * 
   * @param p
   * @param chartID
   * @param config
   */
  void setChartConfig(const PendantID p, const std::string& chartID, const Any& config) override;
  int32_t send_setChartConfig(const PendantID p, const std::string& chartID, const Any& config);
  void recv_setChartConfig(const int32_t seqid);
  /**
   * Get the configuration of a chart by ID
   * 
   * @param p
   * @param chartID
   */
  void getChartConfig(Any& _return, const PendantID p, const std::string& chartID) override;
  int32_t send_getChartConfig(const PendantID p, const std::string& chartID);
  void recv_getChartConfig(Any& _return, const int32_t seqid);
  /**
   * Set the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param dataset
   * @param right
   */
  void setChartData(const PendantID p, const std::string& chartID, const DataSet& dataset, const bool right) override;
  int32_t send_setChartData(const PendantID p, const std::string& chartID, const DataSet& dataset, const bool right);
  void recv_setChartData(const int32_t seqid);
  /**
   * Get the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to access the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param right
   */
  void getChartData(DataSet& _return, const PendantID p, const std::string& chartID, const bool right) override;
  int32_t send_getChartData(const PendantID p, const std::string& chartID, const bool right);
  void recv_getChartData(DataSet& _return, const int32_t seqid);
  /**
   * Add a new key to the dataset of a chart by ID. In line and scatter charts,
   * you can set 'right' to true to pass the dataset for a secondary
   * scale on the right hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param data
   * @param right
   */
  void addChartKey(const PendantID p, const std::string& chartID, const std::string& key, const Data& data, const bool right) override;
  int32_t send_addChartKey(const PendantID p, const std::string& chartID, const std::string& key, const Data& data, const bool right);
  void recv_addChartKey(const int32_t seqid);
  /**
   * Removes an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to remove from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param right
   */
  void removeChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool right) override;
  int32_t send_removeChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool right);
  void recv_removeChartKey(const int32_t seqid);
  /**
   * Hides an existing key from the dataset of a chart by ID. In line and
   * scatter charts, you can set 'right' to true to hide a key from the
   * secondary dataset.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param hidden
   * @param right
   */
  void hideChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool hidden, const bool right) override;
  int32_t send_hideChartKey(const PendantID p, const std::string& chartID, const std::string& key, const bool hidden, const bool right);
  void recv_hideChartKey(const int32_t seqid);
  /**
   * Append new data points to a specified key in the data of a chart by ID.
   * This function will only have an effect on line/scatter charts. Set
   * 'right' to true to pass the dataset for a secondary scale on the right
   * hand side.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param points
   * @param right
   */
  void appendChartPoints(const PendantID p, const std::string& chartID, const std::string& key, const std::vector<DataPoint> & points, const bool right) override;
  void send_appendChartPoints(const PendantID p, const std::string& chartID, const std::string& key, const std::vector<DataPoint> & points, const bool right);
  /**
   * Increments a category value by `val`.
   * 
   * @param p
   * @param chartID
   * @param key
   * @param val
   */
  void incrementChartKey(const PendantID p, const std::string& chartID, const std::string& key, const double val) override;
  int32_t send_incrementChartKey(const PendantID p, const std::string& chartID, const std::string& key, const double val);
  void recv_incrementChartKey(const int32_t seqid);
  /**
   * Export the current chart contents to the specified filename (must be uniquely named, with .jpg or .png).
   * Calls exportChartImageData if the extension is unable to access the file.
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImage(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) override;
  int32_t send_exportChartImage(const PendantID p, const std::string& chartID, const std::string& imageFileName);
  void recv_exportChartImage(std::string& _return, const int32_t seqid);
  /**
   * Export the current chart contents to a binary blob (must be uniquely named, with .jpg or .png extension)
   * 
   * @param p
   * @param chartID
   * @param imageFileName
   */
  void exportChartImageData(std::string& _return, const PendantID p, const std::string& chartID, const std::string& imageFileName) override;
  int32_t send_exportChartImageData(const PendantID p, const std::string& chartID, const std::string& imageFileName);
  void recv_exportChartImageData(std::string& _return, const int32_t seqid);
  /**
   * Show notice to user.
   * Notices are automaticlly hidden after a short display period.
   * Notice messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void notice(const PendantID p, const std::string& title, const std::string& message, const std::string& log) override;
  void send_notice(const PendantID p, const std::string& title, const std::string& message, const std::string& log);
  /**
   * Show notice to user with specified disposition.
   * As for notice() but displayed in a way that connotes the specified disposition.
   * For example, a Positive disposition may be shown in green.
   * (API version 2.1 and later)
   * 
   * @param p
   * @param disposition
   * @param title
   * @param message
   * @param log
   */
  void dispNotice(const PendantID p, const Disposition::type disposition, const std::string& title, const std::string& message, const std::string& log) override;
  void send_dispNotice(const PendantID p, const Disposition::type disposition, const std::string& title, const std::string& message, const std::string& log);
  /**
   * Show error to user.
   * Errors should only indicate important situations that the user must be aware of and for which deliberate
   * acknowledgement is required before proceeding.  Typically, some action will be required to correct the situation.
   * Errors are displayed until dismissed by the user.
   * Error messages are logged, if log parameter if provided, that will be logged instead of title & message.
   * 
   * @param p
   * @param title
   * @param message
   * @param log
   */
  void error(const PendantID p, const std::string& title, const std::string& message, const std::string& log) override;
  void send_error(const PendantID p, const std::string& title, const std::string& message, const std::string& log);
  /**
   * Display modal pop-up dialog.  Typically, Yes/No, although negativeOption can be omitted
   * The identifier can be used to associate the corresponding PopupOpened & PopupClosed events triggered by
   * user positive/negative selection or automatic dismissal/cancellation - for example is screen switched, alarm etc.
   * 
   * @param p
   * @param identifier
   * @param title
   * @param message
   * @param positiveOption
   * @param negativeOption
   */
  void popupDialog(const PendantID p, const std::string& identifier, const std::string& title, const std::string& message, const std::string& positiveOption, const std::string& negativeOption) override;
  int32_t send_popupDialog(const PendantID p, const std::string& identifier, const std::string& title, const std::string& message, const std::string& positiveOption, const std::string& negativeOption);
  void recv_popupDialog(const int32_t seqid);
  /**
   * Cancel an open popup dialog.  If the dialog has a negative option, behaves as if user selected it, otherwise
   * no event is generated
   * 
   * @param p
   * @param identifier
   */
  void cancelPopupDialog(const PendantID p, const std::string& identifier) override;
  int32_t send_cancelPopupDialog(const PendantID p, const std::string& identifier);
  void recv_cancelPopupDialog(const int32_t seqid);
  /**
   * Inserts an instruction, returns a string:
   * Success,
   * UnsupportedCommand,
   * InvalidFormat,
   * ProgrammingViewClosed,
   * JobDoesNotExist,
   * CallingJobFromSameJob,
   * ExceededMaxArguments,
   * JobNotEditable,
   * MultiSelectActive,
   * TimedOut,
   * Unknown
   * 
   * @param p
   * @param instruction
   */
  void insertInstructionAtSelectedLine(std::string& _return, const PendantID p, const std::string& instruction) override;
  int32_t send_insertInstructionAtSelectedLine(const PendantID p, const std::string& instruction);
  void recv_insertInstructionAtSelectedLine(std::string& _return, const int32_t seqid);
  /**
   * Displays a standard pendant UI screen by passing a string with the screen identifier. (Only available from SDK API 2.2 onward)
   * Refer to the YML - URI Links documentation for the list of supported screens and settings.
   * Do not include the URI "&lt;a href&gt; screen:" portion in the identifier.  For example to display the jogging panel use:
   * pendant.displayScreen("programmingView?panel=jogging");
   * 
   * @param p
   * @param identifier
   */
  void displayScreen(const PendantID p, const std::string& identifier) override;
  int32_t send_displayScreen(const PendantID p, const std::string& identifier);
  void recv_displayScreen(const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}}} // namespace

#endif
